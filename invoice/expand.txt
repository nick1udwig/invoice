#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
use hyperprocess_macro::*;
use hyperware_process_lib::{
    our, homepage::add_to_homepage,
    vfs::{self, create_drive, create_file, open_file, open_dir, remove_file},
};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
pub struct InvoiceSettings {
    pub invoicer: ContactInfo,
    pub invoicee: ContactInfo,
    pub payment_info: Option<String>,
    pub payment_image_path: Option<String>,
    pub invoice_number_prefix: String,
    pub next_invoice_number: u32,
}
#[automatically_derived]
impl ::core::fmt::Debug for InvoiceSettings {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        let names: &'static _ = &[
            "invoicer",
            "invoicee",
            "payment_info",
            "payment_image_path",
            "invoice_number_prefix",
            "next_invoice_number",
        ];
        let values: &[&dyn ::core::fmt::Debug] = &[
            &self.invoicer,
            &self.invoicee,
            &self.payment_info,
            &self.payment_image_path,
            &self.invoice_number_prefix,
            &&self.next_invoice_number,
        ];
        ::core::fmt::Formatter::debug_struct_fields_finish(
            f,
            "InvoiceSettings",
            names,
            values,
        )
    }
}
#[automatically_derived]
impl ::core::clone::Clone for InvoiceSettings {
    #[inline]
    fn clone(&self) -> InvoiceSettings {
        InvoiceSettings {
            invoicer: ::core::clone::Clone::clone(&self.invoicer),
            invoicee: ::core::clone::Clone::clone(&self.invoicee),
            payment_info: ::core::clone::Clone::clone(&self.payment_info),
            payment_image_path: ::core::clone::Clone::clone(&self.payment_image_path),
            invoice_number_prefix: ::core::clone::Clone::clone(
                &self.invoice_number_prefix,
            ),
            next_invoice_number: ::core::clone::Clone::clone(&self.next_invoice_number),
        }
    }
}
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for InvoiceSettings {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(
                __serializer,
                "InvoiceSettings",
                false as usize + 1 + 1 + 1 + 1 + 1 + 1,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "invoicer",
                &self.invoicer,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "invoicee",
                &self.invoicee,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "payment_info",
                &self.payment_info,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "payment_image_path",
                &self.payment_image_path,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "invoice_number_prefix",
                &self.invoice_number_prefix,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "next_invoice_number",
                &self.next_invoice_number,
            )?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for InvoiceSettings {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __field3,
                __field4,
                __field5,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "field identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        2u64 => _serde::__private::Ok(__Field::__field2),
                        3u64 => _serde::__private::Ok(__Field::__field3),
                        4u64 => _serde::__private::Ok(__Field::__field4),
                        5u64 => _serde::__private::Ok(__Field::__field5),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "invoicer" => _serde::__private::Ok(__Field::__field0),
                        "invoicee" => _serde::__private::Ok(__Field::__field1),
                        "payment_info" => _serde::__private::Ok(__Field::__field2),
                        "payment_image_path" => _serde::__private::Ok(__Field::__field3),
                        "invoice_number_prefix" => {
                            _serde::__private::Ok(__Field::__field4)
                        }
                        "next_invoice_number" => _serde::__private::Ok(__Field::__field5),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"invoicer" => _serde::__private::Ok(__Field::__field0),
                        b"invoicee" => _serde::__private::Ok(__Field::__field1),
                        b"payment_info" => _serde::__private::Ok(__Field::__field2),
                        b"payment_image_path" => _serde::__private::Ok(__Field::__field3),
                        b"invoice_number_prefix" => {
                            _serde::__private::Ok(__Field::__field4)
                        }
                        b"next_invoice_number" => {
                            _serde::__private::Ok(__Field::__field5)
                        }
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<InvoiceSettings>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = InvoiceSettings;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "struct InvoiceSettings",
                    )
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 = match _serde::de::SeqAccess::next_element::<
                        ContactInfo,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct InvoiceSettings with 6 elements",
                                ),
                            );
                        }
                    };
                    let __field1 = match _serde::de::SeqAccess::next_element::<
                        ContactInfo,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct InvoiceSettings with 6 elements",
                                ),
                            );
                        }
                    };
                    let __field2 = match _serde::de::SeqAccess::next_element::<
                        Option<String>,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct InvoiceSettings with 6 elements",
                                ),
                            );
                        }
                    };
                    let __field3 = match _serde::de::SeqAccess::next_element::<
                        Option<String>,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    3usize,
                                    &"struct InvoiceSettings with 6 elements",
                                ),
                            );
                        }
                    };
                    let __field4 = match _serde::de::SeqAccess::next_element::<
                        String,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    4usize,
                                    &"struct InvoiceSettings with 6 elements",
                                ),
                            );
                        }
                    };
                    let __field5 = match _serde::de::SeqAccess::next_element::<
                        u32,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    5usize,
                                    &"struct InvoiceSettings with 6 elements",
                                ),
                            );
                        }
                    };
                    _serde::__private::Ok(InvoiceSettings {
                        invoicer: __field0,
                        invoicee: __field1,
                        payment_info: __field2,
                        payment_image_path: __field3,
                        invoice_number_prefix: __field4,
                        next_invoice_number: __field5,
                    })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::__private::Option<ContactInfo> = _serde::__private::None;
                    let mut __field1: _serde::__private::Option<ContactInfo> = _serde::__private::None;
                    let mut __field2: _serde::__private::Option<Option<String>> = _serde::__private::None;
                    let mut __field3: _serde::__private::Option<Option<String>> = _serde::__private::None;
                    let mut __field4: _serde::__private::Option<String> = _serde::__private::None;
                    let mut __field5: _serde::__private::Option<u32> = _serde::__private::None;
                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                        __Field,
                    >(&mut __map)? {
                        match __key {
                            __Field::__field0 => {
                                if _serde::__private::Option::is_some(&__field0) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "invoicer",
                                        ),
                                    );
                                }
                                __field0 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        ContactInfo,
                                    >(&mut __map)?,
                                );
                            }
                            __Field::__field1 => {
                                if _serde::__private::Option::is_some(&__field1) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "invoicee",
                                        ),
                                    );
                                }
                                __field1 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        ContactInfo,
                                    >(&mut __map)?,
                                );
                            }
                            __Field::__field2 => {
                                if _serde::__private::Option::is_some(&__field2) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "payment_info",
                                        ),
                                    );
                                }
                                __field2 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        Option<String>,
                                    >(&mut __map)?,
                                );
                            }
                            __Field::__field3 => {
                                if _serde::__private::Option::is_some(&__field3) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "payment_image_path",
                                        ),
                                    );
                                }
                                __field3 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        Option<String>,
                                    >(&mut __map)?,
                                );
                            }
                            __Field::__field4 => {
                                if _serde::__private::Option::is_some(&__field4) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "invoice_number_prefix",
                                        ),
                                    );
                                }
                                __field4 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                );
                            }
                            __Field::__field5 => {
                                if _serde::__private::Option::is_some(&__field5) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "next_invoice_number",
                                        ),
                                    );
                                }
                                __field5 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<u32>(&mut __map)?,
                                );
                            }
                            _ => {
                                let _ = _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map)?;
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::__private::Some(__field0) => __field0,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("invoicer")?
                        }
                    };
                    let __field1 = match __field1 {
                        _serde::__private::Some(__field1) => __field1,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("invoicee")?
                        }
                    };
                    let __field2 = match __field2 {
                        _serde::__private::Some(__field2) => __field2,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("payment_info")?
                        }
                    };
                    let __field3 = match __field3 {
                        _serde::__private::Some(__field3) => __field3,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("payment_image_path")?
                        }
                    };
                    let __field4 = match __field4 {
                        _serde::__private::Some(__field4) => __field4,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field(
                                "invoice_number_prefix",
                            )?
                        }
                    };
                    let __field5 = match __field5 {
                        _serde::__private::Some(__field5) => __field5,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("next_invoice_number")?
                        }
                    };
                    _serde::__private::Ok(InvoiceSettings {
                        invoicer: __field0,
                        invoicee: __field1,
                        payment_info: __field2,
                        payment_image_path: __field3,
                        invoice_number_prefix: __field4,
                        next_invoice_number: __field5,
                    })
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &[
                "invoicer",
                "invoicee",
                "payment_info",
                "payment_image_path",
                "invoice_number_prefix",
                "next_invoice_number",
            ];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "InvoiceSettings",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<InvoiceSettings>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
#[automatically_derived]
impl ::core::marker::StructuralPartialEq for InvoiceSettings {}
#[automatically_derived]
impl ::core::cmp::PartialEq for InvoiceSettings {
    #[inline]
    fn eq(&self, other: &InvoiceSettings) -> bool {
        self.invoicer == other.invoicer && self.invoicee == other.invoicee
            && self.payment_info == other.payment_info
            && self.payment_image_path == other.payment_image_path
            && self.invoice_number_prefix == other.invoice_number_prefix
            && self.next_invoice_number == other.next_invoice_number
    }
}
pub struct ContactInfo {
    pub name: String,
    pub company: Option<String>,
    pub address: String,
    pub email: Option<String>,
    pub phone: Option<String>,
    pub logo_path: Option<String>,
}
#[automatically_derived]
impl ::core::fmt::Debug for ContactInfo {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        let names: &'static _ = &[
            "name",
            "company",
            "address",
            "email",
            "phone",
            "logo_path",
        ];
        let values: &[&dyn ::core::fmt::Debug] = &[
            &self.name,
            &self.company,
            &self.address,
            &self.email,
            &self.phone,
            &&self.logo_path,
        ];
        ::core::fmt::Formatter::debug_struct_fields_finish(
            f,
            "ContactInfo",
            names,
            values,
        )
    }
}
#[automatically_derived]
impl ::core::clone::Clone for ContactInfo {
    #[inline]
    fn clone(&self) -> ContactInfo {
        ContactInfo {
            name: ::core::clone::Clone::clone(&self.name),
            company: ::core::clone::Clone::clone(&self.company),
            address: ::core::clone::Clone::clone(&self.address),
            email: ::core::clone::Clone::clone(&self.email),
            phone: ::core::clone::Clone::clone(&self.phone),
            logo_path: ::core::clone::Clone::clone(&self.logo_path),
        }
    }
}
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for ContactInfo {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(
                __serializer,
                "ContactInfo",
                false as usize + 1 + 1 + 1 + 1 + 1 + 1,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "name",
                &self.name,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "company",
                &self.company,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "address",
                &self.address,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "email",
                &self.email,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "phone",
                &self.phone,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "logo_path",
                &self.logo_path,
            )?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for ContactInfo {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __field3,
                __field4,
                __field5,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "field identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        2u64 => _serde::__private::Ok(__Field::__field2),
                        3u64 => _serde::__private::Ok(__Field::__field3),
                        4u64 => _serde::__private::Ok(__Field::__field4),
                        5u64 => _serde::__private::Ok(__Field::__field5),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "name" => _serde::__private::Ok(__Field::__field0),
                        "company" => _serde::__private::Ok(__Field::__field1),
                        "address" => _serde::__private::Ok(__Field::__field2),
                        "email" => _serde::__private::Ok(__Field::__field3),
                        "phone" => _serde::__private::Ok(__Field::__field4),
                        "logo_path" => _serde::__private::Ok(__Field::__field5),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"name" => _serde::__private::Ok(__Field::__field0),
                        b"company" => _serde::__private::Ok(__Field::__field1),
                        b"address" => _serde::__private::Ok(__Field::__field2),
                        b"email" => _serde::__private::Ok(__Field::__field3),
                        b"phone" => _serde::__private::Ok(__Field::__field4),
                        b"logo_path" => _serde::__private::Ok(__Field::__field5),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<ContactInfo>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = ContactInfo;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "struct ContactInfo",
                    )
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 = match _serde::de::SeqAccess::next_element::<
                        String,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct ContactInfo with 6 elements",
                                ),
                            );
                        }
                    };
                    let __field1 = match _serde::de::SeqAccess::next_element::<
                        Option<String>,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct ContactInfo with 6 elements",
                                ),
                            );
                        }
                    };
                    let __field2 = match _serde::de::SeqAccess::next_element::<
                        String,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct ContactInfo with 6 elements",
                                ),
                            );
                        }
                    };
                    let __field3 = match _serde::de::SeqAccess::next_element::<
                        Option<String>,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    3usize,
                                    &"struct ContactInfo with 6 elements",
                                ),
                            );
                        }
                    };
                    let __field4 = match _serde::de::SeqAccess::next_element::<
                        Option<String>,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    4usize,
                                    &"struct ContactInfo with 6 elements",
                                ),
                            );
                        }
                    };
                    let __field5 = match _serde::de::SeqAccess::next_element::<
                        Option<String>,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    5usize,
                                    &"struct ContactInfo with 6 elements",
                                ),
                            );
                        }
                    };
                    _serde::__private::Ok(ContactInfo {
                        name: __field0,
                        company: __field1,
                        address: __field2,
                        email: __field3,
                        phone: __field4,
                        logo_path: __field5,
                    })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                    let mut __field1: _serde::__private::Option<Option<String>> = _serde::__private::None;
                    let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                    let mut __field3: _serde::__private::Option<Option<String>> = _serde::__private::None;
                    let mut __field4: _serde::__private::Option<Option<String>> = _serde::__private::None;
                    let mut __field5: _serde::__private::Option<Option<String>> = _serde::__private::None;
                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                        __Field,
                    >(&mut __map)? {
                        match __key {
                            __Field::__field0 => {
                                if _serde::__private::Option::is_some(&__field0) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                    );
                                }
                                __field0 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                );
                            }
                            __Field::__field1 => {
                                if _serde::__private::Option::is_some(&__field1) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "company",
                                        ),
                                    );
                                }
                                __field1 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        Option<String>,
                                    >(&mut __map)?,
                                );
                            }
                            __Field::__field2 => {
                                if _serde::__private::Option::is_some(&__field2) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "address",
                                        ),
                                    );
                                }
                                __field2 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                );
                            }
                            __Field::__field3 => {
                                if _serde::__private::Option::is_some(&__field3) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("email"),
                                    );
                                }
                                __field3 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        Option<String>,
                                    >(&mut __map)?,
                                );
                            }
                            __Field::__field4 => {
                                if _serde::__private::Option::is_some(&__field4) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("phone"),
                                    );
                                }
                                __field4 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        Option<String>,
                                    >(&mut __map)?,
                                );
                            }
                            __Field::__field5 => {
                                if _serde::__private::Option::is_some(&__field5) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "logo_path",
                                        ),
                                    );
                                }
                                __field5 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        Option<String>,
                                    >(&mut __map)?,
                                );
                            }
                            _ => {
                                let _ = _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map)?;
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::__private::Some(__field0) => __field0,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("name")?
                        }
                    };
                    let __field1 = match __field1 {
                        _serde::__private::Some(__field1) => __field1,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("company")?
                        }
                    };
                    let __field2 = match __field2 {
                        _serde::__private::Some(__field2) => __field2,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("address")?
                        }
                    };
                    let __field3 = match __field3 {
                        _serde::__private::Some(__field3) => __field3,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("email")?
                        }
                    };
                    let __field4 = match __field4 {
                        _serde::__private::Some(__field4) => __field4,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("phone")?
                        }
                    };
                    let __field5 = match __field5 {
                        _serde::__private::Some(__field5) => __field5,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("logo_path")?
                        }
                    };
                    _serde::__private::Ok(ContactInfo {
                        name: __field0,
                        company: __field1,
                        address: __field2,
                        email: __field3,
                        phone: __field4,
                        logo_path: __field5,
                    })
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &[
                "name",
                "company",
                "address",
                "email",
                "phone",
                "logo_path",
            ];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "ContactInfo",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<ContactInfo>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
#[automatically_derived]
impl ::core::marker::StructuralPartialEq for ContactInfo {}
#[automatically_derived]
impl ::core::cmp::PartialEq for ContactInfo {
    #[inline]
    fn eq(&self, other: &ContactInfo) -> bool {
        self.name == other.name && self.company == other.company
            && self.address == other.address && self.email == other.email
            && self.phone == other.phone && self.logo_path == other.logo_path
    }
}
pub struct Invoice {
    pub id: String,
    pub number: String,
    pub name: Option<String>,
    pub date: String,
    pub due_date: Option<String>,
    pub invoicer: ContactInfo,
    pub invoicee: ContactInfo,
    pub line_items: Vec<LineItem>,
    pub discount_percent: f64,
    pub tax_percent: f64,
    pub notes: Option<String>,
    pub payment_info: Option<String>,
    pub payment_image_path: Option<String>,
    pub status: InvoiceStatus,
    pub created_at: u64,
    pub updated_at: u64,
}
#[automatically_derived]
impl ::core::fmt::Debug for Invoice {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        let names: &'static _ = &[
            "id",
            "number",
            "name",
            "date",
            "due_date",
            "invoicer",
            "invoicee",
            "line_items",
            "discount_percent",
            "tax_percent",
            "notes",
            "payment_info",
            "payment_image_path",
            "status",
            "created_at",
            "updated_at",
        ];
        let values: &[&dyn ::core::fmt::Debug] = &[
            &self.id,
            &self.number,
            &self.name,
            &self.date,
            &self.due_date,
            &self.invoicer,
            &self.invoicee,
            &self.line_items,
            &self.discount_percent,
            &self.tax_percent,
            &self.notes,
            &self.payment_info,
            &self.payment_image_path,
            &self.status,
            &self.created_at,
            &&self.updated_at,
        ];
        ::core::fmt::Formatter::debug_struct_fields_finish(f, "Invoice", names, values)
    }
}
#[automatically_derived]
impl ::core::clone::Clone for Invoice {
    #[inline]
    fn clone(&self) -> Invoice {
        Invoice {
            id: ::core::clone::Clone::clone(&self.id),
            number: ::core::clone::Clone::clone(&self.number),
            name: ::core::clone::Clone::clone(&self.name),
            date: ::core::clone::Clone::clone(&self.date),
            due_date: ::core::clone::Clone::clone(&self.due_date),
            invoicer: ::core::clone::Clone::clone(&self.invoicer),
            invoicee: ::core::clone::Clone::clone(&self.invoicee),
            line_items: ::core::clone::Clone::clone(&self.line_items),
            discount_percent: ::core::clone::Clone::clone(&self.discount_percent),
            tax_percent: ::core::clone::Clone::clone(&self.tax_percent),
            notes: ::core::clone::Clone::clone(&self.notes),
            payment_info: ::core::clone::Clone::clone(&self.payment_info),
            payment_image_path: ::core::clone::Clone::clone(&self.payment_image_path),
            status: ::core::clone::Clone::clone(&self.status),
            created_at: ::core::clone::Clone::clone(&self.created_at),
            updated_at: ::core::clone::Clone::clone(&self.updated_at),
        }
    }
}
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for Invoice {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(
                __serializer,
                "Invoice",
                false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1
                    + 1 + 1,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "id",
                &self.id,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "number",
                &self.number,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "name",
                &self.name,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "date",
                &self.date,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "due_date",
                &self.due_date,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "invoicer",
                &self.invoicer,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "invoicee",
                &self.invoicee,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "line_items",
                &self.line_items,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "discount_percent",
                &self.discount_percent,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "tax_percent",
                &self.tax_percent,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "notes",
                &self.notes,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "payment_info",
                &self.payment_info,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "payment_image_path",
                &self.payment_image_path,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "status",
                &self.status,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "created_at",
                &self.created_at,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "updated_at",
                &self.updated_at,
            )?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for Invoice {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __field3,
                __field4,
                __field5,
                __field6,
                __field7,
                __field8,
                __field9,
                __field10,
                __field11,
                __field12,
                __field13,
                __field14,
                __field15,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "field identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        2u64 => _serde::__private::Ok(__Field::__field2),
                        3u64 => _serde::__private::Ok(__Field::__field3),
                        4u64 => _serde::__private::Ok(__Field::__field4),
                        5u64 => _serde::__private::Ok(__Field::__field5),
                        6u64 => _serde::__private::Ok(__Field::__field6),
                        7u64 => _serde::__private::Ok(__Field::__field7),
                        8u64 => _serde::__private::Ok(__Field::__field8),
                        9u64 => _serde::__private::Ok(__Field::__field9),
                        10u64 => _serde::__private::Ok(__Field::__field10),
                        11u64 => _serde::__private::Ok(__Field::__field11),
                        12u64 => _serde::__private::Ok(__Field::__field12),
                        13u64 => _serde::__private::Ok(__Field::__field13),
                        14u64 => _serde::__private::Ok(__Field::__field14),
                        15u64 => _serde::__private::Ok(__Field::__field15),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "id" => _serde::__private::Ok(__Field::__field0),
                        "number" => _serde::__private::Ok(__Field::__field1),
                        "name" => _serde::__private::Ok(__Field::__field2),
                        "date" => _serde::__private::Ok(__Field::__field3),
                        "due_date" => _serde::__private::Ok(__Field::__field4),
                        "invoicer" => _serde::__private::Ok(__Field::__field5),
                        "invoicee" => _serde::__private::Ok(__Field::__field6),
                        "line_items" => _serde::__private::Ok(__Field::__field7),
                        "discount_percent" => _serde::__private::Ok(__Field::__field8),
                        "tax_percent" => _serde::__private::Ok(__Field::__field9),
                        "notes" => _serde::__private::Ok(__Field::__field10),
                        "payment_info" => _serde::__private::Ok(__Field::__field11),
                        "payment_image_path" => _serde::__private::Ok(__Field::__field12),
                        "status" => _serde::__private::Ok(__Field::__field13),
                        "created_at" => _serde::__private::Ok(__Field::__field14),
                        "updated_at" => _serde::__private::Ok(__Field::__field15),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"id" => _serde::__private::Ok(__Field::__field0),
                        b"number" => _serde::__private::Ok(__Field::__field1),
                        b"name" => _serde::__private::Ok(__Field::__field2),
                        b"date" => _serde::__private::Ok(__Field::__field3),
                        b"due_date" => _serde::__private::Ok(__Field::__field4),
                        b"invoicer" => _serde::__private::Ok(__Field::__field5),
                        b"invoicee" => _serde::__private::Ok(__Field::__field6),
                        b"line_items" => _serde::__private::Ok(__Field::__field7),
                        b"discount_percent" => _serde::__private::Ok(__Field::__field8),
                        b"tax_percent" => _serde::__private::Ok(__Field::__field9),
                        b"notes" => _serde::__private::Ok(__Field::__field10),
                        b"payment_info" => _serde::__private::Ok(__Field::__field11),
                        b"payment_image_path" => {
                            _serde::__private::Ok(__Field::__field12)
                        }
                        b"status" => _serde::__private::Ok(__Field::__field13),
                        b"created_at" => _serde::__private::Ok(__Field::__field14),
                        b"updated_at" => _serde::__private::Ok(__Field::__field15),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<Invoice>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = Invoice;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "struct Invoice",
                    )
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 = match _serde::de::SeqAccess::next_element::<
                        String,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct Invoice with 16 elements",
                                ),
                            );
                        }
                    };
                    let __field1 = match _serde::de::SeqAccess::next_element::<
                        String,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct Invoice with 16 elements",
                                ),
                            );
                        }
                    };
                    let __field2 = match _serde::de::SeqAccess::next_element::<
                        Option<String>,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct Invoice with 16 elements",
                                ),
                            );
                        }
                    };
                    let __field3 = match _serde::de::SeqAccess::next_element::<
                        String,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    3usize,
                                    &"struct Invoice with 16 elements",
                                ),
                            );
                        }
                    };
                    let __field4 = match _serde::de::SeqAccess::next_element::<
                        Option<String>,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    4usize,
                                    &"struct Invoice with 16 elements",
                                ),
                            );
                        }
                    };
                    let __field5 = match _serde::de::SeqAccess::next_element::<
                        ContactInfo,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    5usize,
                                    &"struct Invoice with 16 elements",
                                ),
                            );
                        }
                    };
                    let __field6 = match _serde::de::SeqAccess::next_element::<
                        ContactInfo,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    6usize,
                                    &"struct Invoice with 16 elements",
                                ),
                            );
                        }
                    };
                    let __field7 = match _serde::de::SeqAccess::next_element::<
                        Vec<LineItem>,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    7usize,
                                    &"struct Invoice with 16 elements",
                                ),
                            );
                        }
                    };
                    let __field8 = match _serde::de::SeqAccess::next_element::<
                        f64,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    8usize,
                                    &"struct Invoice with 16 elements",
                                ),
                            );
                        }
                    };
                    let __field9 = match _serde::de::SeqAccess::next_element::<
                        f64,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    9usize,
                                    &"struct Invoice with 16 elements",
                                ),
                            );
                        }
                    };
                    let __field10 = match _serde::de::SeqAccess::next_element::<
                        Option<String>,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    10usize,
                                    &"struct Invoice with 16 elements",
                                ),
                            );
                        }
                    };
                    let __field11 = match _serde::de::SeqAccess::next_element::<
                        Option<String>,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    11usize,
                                    &"struct Invoice with 16 elements",
                                ),
                            );
                        }
                    };
                    let __field12 = match _serde::de::SeqAccess::next_element::<
                        Option<String>,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    12usize,
                                    &"struct Invoice with 16 elements",
                                ),
                            );
                        }
                    };
                    let __field13 = match _serde::de::SeqAccess::next_element::<
                        InvoiceStatus,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    13usize,
                                    &"struct Invoice with 16 elements",
                                ),
                            );
                        }
                    };
                    let __field14 = match _serde::de::SeqAccess::next_element::<
                        u64,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    14usize,
                                    &"struct Invoice with 16 elements",
                                ),
                            );
                        }
                    };
                    let __field15 = match _serde::de::SeqAccess::next_element::<
                        u64,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    15usize,
                                    &"struct Invoice with 16 elements",
                                ),
                            );
                        }
                    };
                    _serde::__private::Ok(Invoice {
                        id: __field0,
                        number: __field1,
                        name: __field2,
                        date: __field3,
                        due_date: __field4,
                        invoicer: __field5,
                        invoicee: __field6,
                        line_items: __field7,
                        discount_percent: __field8,
                        tax_percent: __field9,
                        notes: __field10,
                        payment_info: __field11,
                        payment_image_path: __field12,
                        status: __field13,
                        created_at: __field14,
                        updated_at: __field15,
                    })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                    let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                    let mut __field2: _serde::__private::Option<Option<String>> = _serde::__private::None;
                    let mut __field3: _serde::__private::Option<String> = _serde::__private::None;
                    let mut __field4: _serde::__private::Option<Option<String>> = _serde::__private::None;
                    let mut __field5: _serde::__private::Option<ContactInfo> = _serde::__private::None;
                    let mut __field6: _serde::__private::Option<ContactInfo> = _serde::__private::None;
                    let mut __field7: _serde::__private::Option<Vec<LineItem>> = _serde::__private::None;
                    let mut __field8: _serde::__private::Option<f64> = _serde::__private::None;
                    let mut __field9: _serde::__private::Option<f64> = _serde::__private::None;
                    let mut __field10: _serde::__private::Option<Option<String>> = _serde::__private::None;
                    let mut __field11: _serde::__private::Option<Option<String>> = _serde::__private::None;
                    let mut __field12: _serde::__private::Option<Option<String>> = _serde::__private::None;
                    let mut __field13: _serde::__private::Option<InvoiceStatus> = _serde::__private::None;
                    let mut __field14: _serde::__private::Option<u64> = _serde::__private::None;
                    let mut __field15: _serde::__private::Option<u64> = _serde::__private::None;
                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                        __Field,
                    >(&mut __map)? {
                        match __key {
                            __Field::__field0 => {
                                if _serde::__private::Option::is_some(&__field0) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                    );
                                }
                                __field0 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                );
                            }
                            __Field::__field1 => {
                                if _serde::__private::Option::is_some(&__field1) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("number"),
                                    );
                                }
                                __field1 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                );
                            }
                            __Field::__field2 => {
                                if _serde::__private::Option::is_some(&__field2) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                    );
                                }
                                __field2 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        Option<String>,
                                    >(&mut __map)?,
                                );
                            }
                            __Field::__field3 => {
                                if _serde::__private::Option::is_some(&__field3) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("date"),
                                    );
                                }
                                __field3 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                );
                            }
                            __Field::__field4 => {
                                if _serde::__private::Option::is_some(&__field4) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "due_date",
                                        ),
                                    );
                                }
                                __field4 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        Option<String>,
                                    >(&mut __map)?,
                                );
                            }
                            __Field::__field5 => {
                                if _serde::__private::Option::is_some(&__field5) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "invoicer",
                                        ),
                                    );
                                }
                                __field5 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        ContactInfo,
                                    >(&mut __map)?,
                                );
                            }
                            __Field::__field6 => {
                                if _serde::__private::Option::is_some(&__field6) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "invoicee",
                                        ),
                                    );
                                }
                                __field6 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        ContactInfo,
                                    >(&mut __map)?,
                                );
                            }
                            __Field::__field7 => {
                                if _serde::__private::Option::is_some(&__field7) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "line_items",
                                        ),
                                    );
                                }
                                __field7 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        Vec<LineItem>,
                                    >(&mut __map)?,
                                );
                            }
                            __Field::__field8 => {
                                if _serde::__private::Option::is_some(&__field8) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "discount_percent",
                                        ),
                                    );
                                }
                                __field8 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<f64>(&mut __map)?,
                                );
                            }
                            __Field::__field9 => {
                                if _serde::__private::Option::is_some(&__field9) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "tax_percent",
                                        ),
                                    );
                                }
                                __field9 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<f64>(&mut __map)?,
                                );
                            }
                            __Field::__field10 => {
                                if _serde::__private::Option::is_some(&__field10) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("notes"),
                                    );
                                }
                                __field10 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        Option<String>,
                                    >(&mut __map)?,
                                );
                            }
                            __Field::__field11 => {
                                if _serde::__private::Option::is_some(&__field11) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "payment_info",
                                        ),
                                    );
                                }
                                __field11 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        Option<String>,
                                    >(&mut __map)?,
                                );
                            }
                            __Field::__field12 => {
                                if _serde::__private::Option::is_some(&__field12) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "payment_image_path",
                                        ),
                                    );
                                }
                                __field12 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        Option<String>,
                                    >(&mut __map)?,
                                );
                            }
                            __Field::__field13 => {
                                if _serde::__private::Option::is_some(&__field13) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("status"),
                                    );
                                }
                                __field13 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        InvoiceStatus,
                                    >(&mut __map)?,
                                );
                            }
                            __Field::__field14 => {
                                if _serde::__private::Option::is_some(&__field14) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "created_at",
                                        ),
                                    );
                                }
                                __field14 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                );
                            }
                            __Field::__field15 => {
                                if _serde::__private::Option::is_some(&__field15) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "updated_at",
                                        ),
                                    );
                                }
                                __field15 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                );
                            }
                            _ => {
                                let _ = _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map)?;
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::__private::Some(__field0) => __field0,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("id")?
                        }
                    };
                    let __field1 = match __field1 {
                        _serde::__private::Some(__field1) => __field1,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("number")?
                        }
                    };
                    let __field2 = match __field2 {
                        _serde::__private::Some(__field2) => __field2,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("name")?
                        }
                    };
                    let __field3 = match __field3 {
                        _serde::__private::Some(__field3) => __field3,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("date")?
                        }
                    };
                    let __field4 = match __field4 {
                        _serde::__private::Some(__field4) => __field4,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("due_date")?
                        }
                    };
                    let __field5 = match __field5 {
                        _serde::__private::Some(__field5) => __field5,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("invoicer")?
                        }
                    };
                    let __field6 = match __field6 {
                        _serde::__private::Some(__field6) => __field6,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("invoicee")?
                        }
                    };
                    let __field7 = match __field7 {
                        _serde::__private::Some(__field7) => __field7,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("line_items")?
                        }
                    };
                    let __field8 = match __field8 {
                        _serde::__private::Some(__field8) => __field8,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("discount_percent")?
                        }
                    };
                    let __field9 = match __field9 {
                        _serde::__private::Some(__field9) => __field9,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("tax_percent")?
                        }
                    };
                    let __field10 = match __field10 {
                        _serde::__private::Some(__field10) => __field10,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("notes")?
                        }
                    };
                    let __field11 = match __field11 {
                        _serde::__private::Some(__field11) => __field11,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("payment_info")?
                        }
                    };
                    let __field12 = match __field12 {
                        _serde::__private::Some(__field12) => __field12,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("payment_image_path")?
                        }
                    };
                    let __field13 = match __field13 {
                        _serde::__private::Some(__field13) => __field13,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("status")?
                        }
                    };
                    let __field14 = match __field14 {
                        _serde::__private::Some(__field14) => __field14,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("created_at")?
                        }
                    };
                    let __field15 = match __field15 {
                        _serde::__private::Some(__field15) => __field15,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("updated_at")?
                        }
                    };
                    _serde::__private::Ok(Invoice {
                        id: __field0,
                        number: __field1,
                        name: __field2,
                        date: __field3,
                        due_date: __field4,
                        invoicer: __field5,
                        invoicee: __field6,
                        line_items: __field7,
                        discount_percent: __field8,
                        tax_percent: __field9,
                        notes: __field10,
                        payment_info: __field11,
                        payment_image_path: __field12,
                        status: __field13,
                        created_at: __field14,
                        updated_at: __field15,
                    })
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &[
                "id",
                "number",
                "name",
                "date",
                "due_date",
                "invoicer",
                "invoicee",
                "line_items",
                "discount_percent",
                "tax_percent",
                "notes",
                "payment_info",
                "payment_image_path",
                "status",
                "created_at",
                "updated_at",
            ];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "Invoice",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<Invoice>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
#[automatically_derived]
impl ::core::marker::StructuralPartialEq for Invoice {}
#[automatically_derived]
impl ::core::cmp::PartialEq for Invoice {
    #[inline]
    fn eq(&self, other: &Invoice) -> bool {
        self.id == other.id && self.number == other.number && self.name == other.name
            && self.date == other.date && self.due_date == other.due_date
            && self.invoicer == other.invoicer && self.invoicee == other.invoicee
            && self.line_items == other.line_items
            && self.discount_percent == other.discount_percent
            && self.tax_percent == other.tax_percent && self.notes == other.notes
            && self.payment_info == other.payment_info
            && self.payment_image_path == other.payment_image_path
            && self.status == other.status && self.created_at == other.created_at
            && self.updated_at == other.updated_at
    }
}
pub struct LineItem {
    pub id: String,
    pub description: String,
    pub quantity: f64,
    pub rate: f64,
    pub discount_percent: f64,
}
#[automatically_derived]
impl ::core::fmt::Debug for LineItem {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field5_finish(
            f,
            "LineItem",
            "id",
            &self.id,
            "description",
            &self.description,
            "quantity",
            &self.quantity,
            "rate",
            &self.rate,
            "discount_percent",
            &&self.discount_percent,
        )
    }
}
#[automatically_derived]
impl ::core::clone::Clone for LineItem {
    #[inline]
    fn clone(&self) -> LineItem {
        LineItem {
            id: ::core::clone::Clone::clone(&self.id),
            description: ::core::clone::Clone::clone(&self.description),
            quantity: ::core::clone::Clone::clone(&self.quantity),
            rate: ::core::clone::Clone::clone(&self.rate),
            discount_percent: ::core::clone::Clone::clone(&self.discount_percent),
        }
    }
}
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for LineItem {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(
                __serializer,
                "LineItem",
                false as usize + 1 + 1 + 1 + 1 + 1,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "id",
                &self.id,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "description",
                &self.description,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "quantity",
                &self.quantity,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "rate",
                &self.rate,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "discount_percent",
                &self.discount_percent,
            )?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for LineItem {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __field3,
                __field4,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "field identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        2u64 => _serde::__private::Ok(__Field::__field2),
                        3u64 => _serde::__private::Ok(__Field::__field3),
                        4u64 => _serde::__private::Ok(__Field::__field4),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "id" => _serde::__private::Ok(__Field::__field0),
                        "description" => _serde::__private::Ok(__Field::__field1),
                        "quantity" => _serde::__private::Ok(__Field::__field2),
                        "rate" => _serde::__private::Ok(__Field::__field3),
                        "discount_percent" => _serde::__private::Ok(__Field::__field4),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"id" => _serde::__private::Ok(__Field::__field0),
                        b"description" => _serde::__private::Ok(__Field::__field1),
                        b"quantity" => _serde::__private::Ok(__Field::__field2),
                        b"rate" => _serde::__private::Ok(__Field::__field3),
                        b"discount_percent" => _serde::__private::Ok(__Field::__field4),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<LineItem>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = LineItem;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "struct LineItem",
                    )
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 = match _serde::de::SeqAccess::next_element::<
                        String,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct LineItem with 5 elements",
                                ),
                            );
                        }
                    };
                    let __field1 = match _serde::de::SeqAccess::next_element::<
                        String,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct LineItem with 5 elements",
                                ),
                            );
                        }
                    };
                    let __field2 = match _serde::de::SeqAccess::next_element::<
                        f64,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct LineItem with 5 elements",
                                ),
                            );
                        }
                    };
                    let __field3 = match _serde::de::SeqAccess::next_element::<
                        f64,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    3usize,
                                    &"struct LineItem with 5 elements",
                                ),
                            );
                        }
                    };
                    let __field4 = match _serde::de::SeqAccess::next_element::<
                        f64,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    4usize,
                                    &"struct LineItem with 5 elements",
                                ),
                            );
                        }
                    };
                    _serde::__private::Ok(LineItem {
                        id: __field0,
                        description: __field1,
                        quantity: __field2,
                        rate: __field3,
                        discount_percent: __field4,
                    })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                    let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                    let mut __field2: _serde::__private::Option<f64> = _serde::__private::None;
                    let mut __field3: _serde::__private::Option<f64> = _serde::__private::None;
                    let mut __field4: _serde::__private::Option<f64> = _serde::__private::None;
                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                        __Field,
                    >(&mut __map)? {
                        match __key {
                            __Field::__field0 => {
                                if _serde::__private::Option::is_some(&__field0) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                    );
                                }
                                __field0 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                );
                            }
                            __Field::__field1 => {
                                if _serde::__private::Option::is_some(&__field1) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "description",
                                        ),
                                    );
                                }
                                __field1 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                );
                            }
                            __Field::__field2 => {
                                if _serde::__private::Option::is_some(&__field2) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "quantity",
                                        ),
                                    );
                                }
                                __field2 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<f64>(&mut __map)?,
                                );
                            }
                            __Field::__field3 => {
                                if _serde::__private::Option::is_some(&__field3) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("rate"),
                                    );
                                }
                                __field3 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<f64>(&mut __map)?,
                                );
                            }
                            __Field::__field4 => {
                                if _serde::__private::Option::is_some(&__field4) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "discount_percent",
                                        ),
                                    );
                                }
                                __field4 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<f64>(&mut __map)?,
                                );
                            }
                            _ => {
                                let _ = _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map)?;
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::__private::Some(__field0) => __field0,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("id")?
                        }
                    };
                    let __field1 = match __field1 {
                        _serde::__private::Some(__field1) => __field1,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("description")?
                        }
                    };
                    let __field2 = match __field2 {
                        _serde::__private::Some(__field2) => __field2,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("quantity")?
                        }
                    };
                    let __field3 = match __field3 {
                        _serde::__private::Some(__field3) => __field3,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("rate")?
                        }
                    };
                    let __field4 = match __field4 {
                        _serde::__private::Some(__field4) => __field4,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("discount_percent")?
                        }
                    };
                    _serde::__private::Ok(LineItem {
                        id: __field0,
                        description: __field1,
                        quantity: __field2,
                        rate: __field3,
                        discount_percent: __field4,
                    })
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &[
                "id",
                "description",
                "quantity",
                "rate",
                "discount_percent",
            ];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "LineItem",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<LineItem>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
#[automatically_derived]
impl ::core::marker::StructuralPartialEq for LineItem {}
#[automatically_derived]
impl ::core::cmp::PartialEq for LineItem {
    #[inline]
    fn eq(&self, other: &LineItem) -> bool {
        self.id == other.id && self.description == other.description
            && self.quantity == other.quantity && self.rate == other.rate
            && self.discount_percent == other.discount_percent
    }
}
pub struct InvoiceSummary {
    pub id: String,
    pub number: String,
    pub name: Option<String>,
    pub date: String,
    pub total: f64,
    pub status: InvoiceStatus,
}
#[automatically_derived]
impl ::core::fmt::Debug for InvoiceSummary {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        let names: &'static _ = &["id", "number", "name", "date", "total", "status"];
        let values: &[&dyn ::core::fmt::Debug] = &[
            &self.id,
            &self.number,
            &self.name,
            &self.date,
            &self.total,
            &&self.status,
        ];
        ::core::fmt::Formatter::debug_struct_fields_finish(
            f,
            "InvoiceSummary",
            names,
            values,
        )
    }
}
#[automatically_derived]
impl ::core::clone::Clone for InvoiceSummary {
    #[inline]
    fn clone(&self) -> InvoiceSummary {
        InvoiceSummary {
            id: ::core::clone::Clone::clone(&self.id),
            number: ::core::clone::Clone::clone(&self.number),
            name: ::core::clone::Clone::clone(&self.name),
            date: ::core::clone::Clone::clone(&self.date),
            total: ::core::clone::Clone::clone(&self.total),
            status: ::core::clone::Clone::clone(&self.status),
        }
    }
}
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for InvoiceSummary {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(
                __serializer,
                "InvoiceSummary",
                false as usize + 1 + 1 + 1 + 1 + 1 + 1,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "id",
                &self.id,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "number",
                &self.number,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "name",
                &self.name,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "date",
                &self.date,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "total",
                &self.total,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "status",
                &self.status,
            )?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for InvoiceSummary {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __field3,
                __field4,
                __field5,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "field identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        2u64 => _serde::__private::Ok(__Field::__field2),
                        3u64 => _serde::__private::Ok(__Field::__field3),
                        4u64 => _serde::__private::Ok(__Field::__field4),
                        5u64 => _serde::__private::Ok(__Field::__field5),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "id" => _serde::__private::Ok(__Field::__field0),
                        "number" => _serde::__private::Ok(__Field::__field1),
                        "name" => _serde::__private::Ok(__Field::__field2),
                        "date" => _serde::__private::Ok(__Field::__field3),
                        "total" => _serde::__private::Ok(__Field::__field4),
                        "status" => _serde::__private::Ok(__Field::__field5),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"id" => _serde::__private::Ok(__Field::__field0),
                        b"number" => _serde::__private::Ok(__Field::__field1),
                        b"name" => _serde::__private::Ok(__Field::__field2),
                        b"date" => _serde::__private::Ok(__Field::__field3),
                        b"total" => _serde::__private::Ok(__Field::__field4),
                        b"status" => _serde::__private::Ok(__Field::__field5),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<InvoiceSummary>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = InvoiceSummary;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "struct InvoiceSummary",
                    )
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 = match _serde::de::SeqAccess::next_element::<
                        String,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct InvoiceSummary with 6 elements",
                                ),
                            );
                        }
                    };
                    let __field1 = match _serde::de::SeqAccess::next_element::<
                        String,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct InvoiceSummary with 6 elements",
                                ),
                            );
                        }
                    };
                    let __field2 = match _serde::de::SeqAccess::next_element::<
                        Option<String>,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct InvoiceSummary with 6 elements",
                                ),
                            );
                        }
                    };
                    let __field3 = match _serde::de::SeqAccess::next_element::<
                        String,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    3usize,
                                    &"struct InvoiceSummary with 6 elements",
                                ),
                            );
                        }
                    };
                    let __field4 = match _serde::de::SeqAccess::next_element::<
                        f64,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    4usize,
                                    &"struct InvoiceSummary with 6 elements",
                                ),
                            );
                        }
                    };
                    let __field5 = match _serde::de::SeqAccess::next_element::<
                        InvoiceStatus,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    5usize,
                                    &"struct InvoiceSummary with 6 elements",
                                ),
                            );
                        }
                    };
                    _serde::__private::Ok(InvoiceSummary {
                        id: __field0,
                        number: __field1,
                        name: __field2,
                        date: __field3,
                        total: __field4,
                        status: __field5,
                    })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                    let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                    let mut __field2: _serde::__private::Option<Option<String>> = _serde::__private::None;
                    let mut __field3: _serde::__private::Option<String> = _serde::__private::None;
                    let mut __field4: _serde::__private::Option<f64> = _serde::__private::None;
                    let mut __field5: _serde::__private::Option<InvoiceStatus> = _serde::__private::None;
                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                        __Field,
                    >(&mut __map)? {
                        match __key {
                            __Field::__field0 => {
                                if _serde::__private::Option::is_some(&__field0) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                    );
                                }
                                __field0 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                );
                            }
                            __Field::__field1 => {
                                if _serde::__private::Option::is_some(&__field1) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("number"),
                                    );
                                }
                                __field1 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                );
                            }
                            __Field::__field2 => {
                                if _serde::__private::Option::is_some(&__field2) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                    );
                                }
                                __field2 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        Option<String>,
                                    >(&mut __map)?,
                                );
                            }
                            __Field::__field3 => {
                                if _serde::__private::Option::is_some(&__field3) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("date"),
                                    );
                                }
                                __field3 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                );
                            }
                            __Field::__field4 => {
                                if _serde::__private::Option::is_some(&__field4) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("total"),
                                    );
                                }
                                __field4 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<f64>(&mut __map)?,
                                );
                            }
                            __Field::__field5 => {
                                if _serde::__private::Option::is_some(&__field5) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("status"),
                                    );
                                }
                                __field5 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        InvoiceStatus,
                                    >(&mut __map)?,
                                );
                            }
                            _ => {
                                let _ = _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map)?;
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::__private::Some(__field0) => __field0,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("id")?
                        }
                    };
                    let __field1 = match __field1 {
                        _serde::__private::Some(__field1) => __field1,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("number")?
                        }
                    };
                    let __field2 = match __field2 {
                        _serde::__private::Some(__field2) => __field2,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("name")?
                        }
                    };
                    let __field3 = match __field3 {
                        _serde::__private::Some(__field3) => __field3,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("date")?
                        }
                    };
                    let __field4 = match __field4 {
                        _serde::__private::Some(__field4) => __field4,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("total")?
                        }
                    };
                    let __field5 = match __field5 {
                        _serde::__private::Some(__field5) => __field5,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("status")?
                        }
                    };
                    _serde::__private::Ok(InvoiceSummary {
                        id: __field0,
                        number: __field1,
                        name: __field2,
                        date: __field3,
                        total: __field4,
                        status: __field5,
                    })
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &[
                "id",
                "number",
                "name",
                "date",
                "total",
                "status",
            ];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "InvoiceSummary",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<InvoiceSummary>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
#[automatically_derived]
impl ::core::marker::StructuralPartialEq for InvoiceSummary {}
#[automatically_derived]
impl ::core::cmp::PartialEq for InvoiceSummary {
    #[inline]
    fn eq(&self, other: &InvoiceSummary) -> bool {
        self.id == other.id && self.number == other.number && self.name == other.name
            && self.date == other.date && self.total == other.total
            && self.status == other.status
    }
}
pub enum InvoiceStatus {
    Draft,
    Sent,
    Paid,
    Overdue,
}
#[automatically_derived]
impl ::core::fmt::Debug for InvoiceStatus {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::write_str(
            f,
            match self {
                InvoiceStatus::Draft => "Draft",
                InvoiceStatus::Sent => "Sent",
                InvoiceStatus::Paid => "Paid",
                InvoiceStatus::Overdue => "Overdue",
            },
        )
    }
}
#[automatically_derived]
impl ::core::clone::Clone for InvoiceStatus {
    #[inline]
    fn clone(&self) -> InvoiceStatus {
        match self {
            InvoiceStatus::Draft => InvoiceStatus::Draft,
            InvoiceStatus::Sent => InvoiceStatus::Sent,
            InvoiceStatus::Paid => InvoiceStatus::Paid,
            InvoiceStatus::Overdue => InvoiceStatus::Overdue,
        }
    }
}
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for InvoiceStatus {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            match *self {
                InvoiceStatus::Draft => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "InvoiceStatus",
                        0u32,
                        "Draft",
                    )
                }
                InvoiceStatus::Sent => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "InvoiceStatus",
                        1u32,
                        "Sent",
                    )
                }
                InvoiceStatus::Paid => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "InvoiceStatus",
                        2u32,
                        "Paid",
                    )
                }
                InvoiceStatus::Overdue => {
                    _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "InvoiceStatus",
                        3u32,
                        "Overdue",
                    )
                }
            }
        }
    }
};
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for InvoiceStatus {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __field3,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "variant identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        2u64 => _serde::__private::Ok(__Field::__field2),
                        3u64 => _serde::__private::Ok(__Field::__field3),
                        _ => {
                            _serde::__private::Err(
                                _serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 4",
                                ),
                            )
                        }
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "Draft" => _serde::__private::Ok(__Field::__field0),
                        "Sent" => _serde::__private::Ok(__Field::__field1),
                        "Paid" => _serde::__private::Ok(__Field::__field2),
                        "Overdue" => _serde::__private::Ok(__Field::__field3),
                        _ => {
                            _serde::__private::Err(
                                _serde::de::Error::unknown_variant(__value, VARIANTS),
                            )
                        }
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"Draft" => _serde::__private::Ok(__Field::__field0),
                        b"Sent" => _serde::__private::Ok(__Field::__field1),
                        b"Paid" => _serde::__private::Ok(__Field::__field2),
                        b"Overdue" => _serde::__private::Ok(__Field::__field3),
                        _ => {
                            let __value = &_serde::__private::from_utf8_lossy(__value);
                            _serde::__private::Err(
                                _serde::de::Error::unknown_variant(__value, VARIANTS),
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<InvoiceStatus>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = InvoiceStatus;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "enum InvoiceStatus",
                    )
                }
                fn visit_enum<__A>(
                    self,
                    __data: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::EnumAccess<'de>,
                {
                    match _serde::de::EnumAccess::variant(__data)? {
                        (__Field::__field0, __variant) => {
                            _serde::de::VariantAccess::unit_variant(__variant)?;
                            _serde::__private::Ok(InvoiceStatus::Draft)
                        }
                        (__Field::__field1, __variant) => {
                            _serde::de::VariantAccess::unit_variant(__variant)?;
                            _serde::__private::Ok(InvoiceStatus::Sent)
                        }
                        (__Field::__field2, __variant) => {
                            _serde::de::VariantAccess::unit_variant(__variant)?;
                            _serde::__private::Ok(InvoiceStatus::Paid)
                        }
                        (__Field::__field3, __variant) => {
                            _serde::de::VariantAccess::unit_variant(__variant)?;
                            _serde::__private::Ok(InvoiceStatus::Overdue)
                        }
                    }
                }
            }
            #[doc(hidden)]
            const VARIANTS: &'static [&'static str] = &[
                "Draft",
                "Sent",
                "Paid",
                "Overdue",
            ];
            _serde::Deserializer::deserialize_enum(
                __deserializer,
                "InvoiceStatus",
                VARIANTS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<InvoiceStatus>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
#[automatically_derived]
impl ::core::marker::StructuralPartialEq for InvoiceStatus {}
#[automatically_derived]
impl ::core::cmp::PartialEq for InvoiceStatus {
    #[inline]
    fn eq(&self, other: &InvoiceStatus) -> bool {
        let __self_discr = ::core::intrinsics::discriminant_value(self);
        let __arg1_discr = ::core::intrinsics::discriminant_value(other);
        __self_discr == __arg1_discr
    }
}
pub struct InvoiceSnapshot {
    pub invoice: Invoice,
    pub timestamp: u64,
}
#[automatically_derived]
impl ::core::fmt::Debug for InvoiceSnapshot {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field2_finish(
            f,
            "InvoiceSnapshot",
            "invoice",
            &self.invoice,
            "timestamp",
            &&self.timestamp,
        )
    }
}
#[automatically_derived]
impl ::core::clone::Clone for InvoiceSnapshot {
    #[inline]
    fn clone(&self) -> InvoiceSnapshot {
        InvoiceSnapshot {
            invoice: ::core::clone::Clone::clone(&self.invoice),
            timestamp: ::core::clone::Clone::clone(&self.timestamp),
        }
    }
}
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for InvoiceSnapshot {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(
                __serializer,
                "InvoiceSnapshot",
                false as usize + 1 + 1,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "invoice",
                &self.invoice,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "timestamp",
                &self.timestamp,
            )?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for InvoiceSnapshot {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "field identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "invoice" => _serde::__private::Ok(__Field::__field0),
                        "timestamp" => _serde::__private::Ok(__Field::__field1),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"invoice" => _serde::__private::Ok(__Field::__field0),
                        b"timestamp" => _serde::__private::Ok(__Field::__field1),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<InvoiceSnapshot>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = InvoiceSnapshot;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "struct InvoiceSnapshot",
                    )
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 = match _serde::de::SeqAccess::next_element::<
                        Invoice,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct InvoiceSnapshot with 2 elements",
                                ),
                            );
                        }
                    };
                    let __field1 = match _serde::de::SeqAccess::next_element::<
                        u64,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct InvoiceSnapshot with 2 elements",
                                ),
                            );
                        }
                    };
                    _serde::__private::Ok(InvoiceSnapshot {
                        invoice: __field0,
                        timestamp: __field1,
                    })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::__private::Option<Invoice> = _serde::__private::None;
                    let mut __field1: _serde::__private::Option<u64> = _serde::__private::None;
                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                        __Field,
                    >(&mut __map)? {
                        match __key {
                            __Field::__field0 => {
                                if _serde::__private::Option::is_some(&__field0) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "invoice",
                                        ),
                                    );
                                }
                                __field0 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<Invoice>(&mut __map)?,
                                );
                            }
                            __Field::__field1 => {
                                if _serde::__private::Option::is_some(&__field1) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "timestamp",
                                        ),
                                    );
                                }
                                __field1 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                );
                            }
                            _ => {
                                let _ = _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map)?;
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::__private::Some(__field0) => __field0,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("invoice")?
                        }
                    };
                    let __field1 = match __field1 {
                        _serde::__private::Some(__field1) => __field1,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("timestamp")?
                        }
                    };
                    _serde::__private::Ok(InvoiceSnapshot {
                        invoice: __field0,
                        timestamp: __field1,
                    })
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &["invoice", "timestamp"];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "InvoiceSnapshot",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<InvoiceSnapshot>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
pub struct AppState {
    pub settings: Option<InvoiceSettings>,
    pub invoices: HashMap<String, InvoiceSummary>,
    pub current_invoice: Option<Invoice>,
    pub undo_stack: Vec<InvoiceSnapshot>,
    pub redo_stack: Vec<InvoiceSnapshot>,
    pub last_save_time: u64,
    pub has_unsaved_changes: bool,
}
#[automatically_derived]
impl ::core::default::Default for AppState {
    #[inline]
    fn default() -> AppState {
        AppState {
            settings: ::core::default::Default::default(),
            invoices: ::core::default::Default::default(),
            current_invoice: ::core::default::Default::default(),
            undo_stack: ::core::default::Default::default(),
            redo_stack: ::core::default::Default::default(),
            last_save_time: ::core::default::Default::default(),
            has_unsaved_changes: ::core::default::Default::default(),
        }
    }
}
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for AppState {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = _serde::Serializer::serialize_struct(
                __serializer,
                "AppState",
                false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "settings",
                &self.settings,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "invoices",
                &self.invoices,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "current_invoice",
                &self.current_invoice,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "undo_stack",
                &self.undo_stack,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "redo_stack",
                &self.redo_stack,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "last_save_time",
                &self.last_save_time,
            )?;
            _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "has_unsaved_changes",
                &self.has_unsaved_changes,
            )?;
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for AppState {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __field3,
                __field4,
                __field5,
                __field6,
                __ignore,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "field identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        2u64 => _serde::__private::Ok(__Field::__field2),
                        3u64 => _serde::__private::Ok(__Field::__field3),
                        4u64 => _serde::__private::Ok(__Field::__field4),
                        5u64 => _serde::__private::Ok(__Field::__field5),
                        6u64 => _serde::__private::Ok(__Field::__field6),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "settings" => _serde::__private::Ok(__Field::__field0),
                        "invoices" => _serde::__private::Ok(__Field::__field1),
                        "current_invoice" => _serde::__private::Ok(__Field::__field2),
                        "undo_stack" => _serde::__private::Ok(__Field::__field3),
                        "redo_stack" => _serde::__private::Ok(__Field::__field4),
                        "last_save_time" => _serde::__private::Ok(__Field::__field5),
                        "has_unsaved_changes" => _serde::__private::Ok(__Field::__field6),
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"settings" => _serde::__private::Ok(__Field::__field0),
                        b"invoices" => _serde::__private::Ok(__Field::__field1),
                        b"current_invoice" => _serde::__private::Ok(__Field::__field2),
                        b"undo_stack" => _serde::__private::Ok(__Field::__field3),
                        b"redo_stack" => _serde::__private::Ok(__Field::__field4),
                        b"last_save_time" => _serde::__private::Ok(__Field::__field5),
                        b"has_unsaved_changes" => {
                            _serde::__private::Ok(__Field::__field6)
                        }
                        _ => _serde::__private::Ok(__Field::__ignore),
                    }
                }
            }
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<AppState>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = AppState;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "struct AppState",
                    )
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 = match _serde::de::SeqAccess::next_element::<
                        Option<InvoiceSettings>,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct AppState with 7 elements",
                                ),
                            );
                        }
                    };
                    let __field1 = match _serde::de::SeqAccess::next_element::<
                        HashMap<String, InvoiceSummary>,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct AppState with 7 elements",
                                ),
                            );
                        }
                    };
                    let __field2 = match _serde::de::SeqAccess::next_element::<
                        Option<Invoice>,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct AppState with 7 elements",
                                ),
                            );
                        }
                    };
                    let __field3 = match _serde::de::SeqAccess::next_element::<
                        Vec<InvoiceSnapshot>,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    3usize,
                                    &"struct AppState with 7 elements",
                                ),
                            );
                        }
                    };
                    let __field4 = match _serde::de::SeqAccess::next_element::<
                        Vec<InvoiceSnapshot>,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    4usize,
                                    &"struct AppState with 7 elements",
                                ),
                            );
                        }
                    };
                    let __field5 = match _serde::de::SeqAccess::next_element::<
                        u64,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    5usize,
                                    &"struct AppState with 7 elements",
                                ),
                            );
                        }
                    };
                    let __field6 = match _serde::de::SeqAccess::next_element::<
                        bool,
                    >(&mut __seq)? {
                        _serde::__private::Some(__value) => __value,
                        _serde::__private::None => {
                            return _serde::__private::Err(
                                _serde::de::Error::invalid_length(
                                    6usize,
                                    &"struct AppState with 7 elements",
                                ),
                            );
                        }
                    };
                    _serde::__private::Ok(AppState {
                        settings: __field0,
                        invoices: __field1,
                        current_invoice: __field2,
                        undo_stack: __field3,
                        redo_stack: __field4,
                        last_save_time: __field5,
                        has_unsaved_changes: __field6,
                    })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::__private::Option<
                        Option<InvoiceSettings>,
                    > = _serde::__private::None;
                    let mut __field1: _serde::__private::Option<
                        HashMap<String, InvoiceSummary>,
                    > = _serde::__private::None;
                    let mut __field2: _serde::__private::Option<Option<Invoice>> = _serde::__private::None;
                    let mut __field3: _serde::__private::Option<Vec<InvoiceSnapshot>> = _serde::__private::None;
                    let mut __field4: _serde::__private::Option<Vec<InvoiceSnapshot>> = _serde::__private::None;
                    let mut __field5: _serde::__private::Option<u64> = _serde::__private::None;
                    let mut __field6: _serde::__private::Option<bool> = _serde::__private::None;
                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                        __Field,
                    >(&mut __map)? {
                        match __key {
                            __Field::__field0 => {
                                if _serde::__private::Option::is_some(&__field0) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "settings",
                                        ),
                                    );
                                }
                                __field0 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        Option<InvoiceSettings>,
                                    >(&mut __map)?,
                                );
                            }
                            __Field::__field1 => {
                                if _serde::__private::Option::is_some(&__field1) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "invoices",
                                        ),
                                    );
                                }
                                __field1 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        HashMap<String, InvoiceSummary>,
                                    >(&mut __map)?,
                                );
                            }
                            __Field::__field2 => {
                                if _serde::__private::Option::is_some(&__field2) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "current_invoice",
                                        ),
                                    );
                                }
                                __field2 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        Option<Invoice>,
                                    >(&mut __map)?,
                                );
                            }
                            __Field::__field3 => {
                                if _serde::__private::Option::is_some(&__field3) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "undo_stack",
                                        ),
                                    );
                                }
                                __field3 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        Vec<InvoiceSnapshot>,
                                    >(&mut __map)?,
                                );
                            }
                            __Field::__field4 => {
                                if _serde::__private::Option::is_some(&__field4) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "redo_stack",
                                        ),
                                    );
                                }
                                __field4 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<
                                        Vec<InvoiceSnapshot>,
                                    >(&mut __map)?,
                                );
                            }
                            __Field::__field5 => {
                                if _serde::__private::Option::is_some(&__field5) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "last_save_time",
                                        ),
                                    );
                                }
                                __field5 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                );
                            }
                            __Field::__field6 => {
                                if _serde::__private::Option::is_some(&__field6) {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "has_unsaved_changes",
                                        ),
                                    );
                                }
                                __field6 = _serde::__private::Some(
                                    _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                );
                            }
                            _ => {
                                let _ = _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map)?;
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::__private::Some(__field0) => __field0,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("settings")?
                        }
                    };
                    let __field1 = match __field1 {
                        _serde::__private::Some(__field1) => __field1,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("invoices")?
                        }
                    };
                    let __field2 = match __field2 {
                        _serde::__private::Some(__field2) => __field2,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("current_invoice")?
                        }
                    };
                    let __field3 = match __field3 {
                        _serde::__private::Some(__field3) => __field3,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("undo_stack")?
                        }
                    };
                    let __field4 = match __field4 {
                        _serde::__private::Some(__field4) => __field4,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("redo_stack")?
                        }
                    };
                    let __field5 = match __field5 {
                        _serde::__private::Some(__field5) => __field5,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("last_save_time")?
                        }
                    };
                    let __field6 = match __field6 {
                        _serde::__private::Some(__field6) => __field6,
                        _serde::__private::None => {
                            _serde::__private::de::missing_field("has_unsaved_changes")?
                        }
                    };
                    _serde::__private::Ok(AppState {
                        settings: __field0,
                        invoices: __field1,
                        current_invoice: __field2,
                        undo_stack: __field3,
                        redo_stack: __field4,
                        last_save_time: __field5,
                        has_unsaved_changes: __field6,
                    })
                }
            }
            #[doc(hidden)]
            const FIELDS: &'static [&'static str] = &[
                "settings",
                "invoices",
                "current_invoice",
                "undo_stack",
                "redo_stack",
                "last_save_time",
                "has_unsaved_changes",
            ];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "AppState",
                FIELDS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<AppState>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
const CURRENT_MESSAGE: ::std::thread::LocalKey<
    std::cell::RefCell<Option<hyperware_process_lib::Message>>,
> = {
    #[inline]
    fn __init() -> std::cell::RefCell<Option<hyperware_process_lib::Message>> {
        std::cell::RefCell::new(None)
    }
    unsafe {
        ::std::thread::LocalKey::new(const {
            if ::std::mem::needs_drop::<
                std::cell::RefCell<Option<hyperware_process_lib::Message>>,
            >() {
                |init| {
                    #[thread_local]
                    static VAL: ::std::thread::local_impl::LazyStorage<
                        std::cell::RefCell<Option<hyperware_process_lib::Message>>,
                        (),
                    > = ::std::thread::local_impl::LazyStorage::new();
                    VAL.get_or_init(init, __init)
                }
            } else {
                |init| {
                    #[thread_local]
                    static VAL: ::std::thread::local_impl::LazyStorage<
                        std::cell::RefCell<Option<hyperware_process_lib::Message>>,
                        !,
                    > = ::std::thread::local_impl::LazyStorage::new();
                    VAL.get_or_init(init, __init)
                }
            }
        })
    }
};
fn source() -> hyperware_process_lib::Address {
    CURRENT_MESSAGE
        .with(|cell| {
            cell.borrow()
                .as_ref()
                .expect("No message in current context")
                .source()
                .clone()
        })
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_init_cabi<T: Guest>(arg0: *mut u8, arg1: usize) {
    let len0 = arg1;
    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
    T::init(_rt::string_lift(bytes0));
}
pub trait Guest {
    fn init(our: _rt::String);
}
#[doc(hidden)]
pub(crate) use __export_world_invoice_os_v0_cabi;
#[allow(dead_code, clippy::all)]
pub mod hyperware {
    pub mod process {
        #[allow(dead_code, clippy::all)]
        pub mod standard {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            ///   
            /// System Types
            ///   
            /// JSON is passed over Wasm boundary as a string.
            pub type Json = _rt::String;
            /// In types passed from kernel, node-id will be a valid Kimap entry.
            pub type NodeId = _rt::String;
            /// Context, like a message body, is a protocol-defined serialized byte
            /// array. It is used when building a Request to save information that
            /// will not be part of a Response, in order to more easily handle
            /// ("contextualize") that Response.
            pub type Context = _rt::Vec<u8>;
            pub struct ProcessId {
                pub process_name: _rt::String,
                pub package_name: _rt::String,
                pub publisher_node: NodeId,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ProcessId {
                #[inline]
                fn clone(&self) -> ProcessId {
                    ProcessId {
                        process_name: ::core::clone::Clone::clone(&self.process_name),
                        package_name: ::core::clone::Clone::clone(&self.package_name),
                        publisher_node: ::core::clone::Clone::clone(&self.publisher_node),
                    }
                }
            }
            impl From<ProcessId> for Vec<u8> {
                fn from(value: ProcessId) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a ProcessId> for Vec<u8> {
                fn from(value: &'a ProcessId) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for ProcessId {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for ProcessId {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for ProcessId {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "process_name" => _serde::__private::Ok(__Field::__field0),
                                    "package_name" => _serde::__private::Ok(__Field::__field1),
                                    "publisher_node" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"process_name" => _serde::__private::Ok(__Field::__field0),
                                    b"package_name" => _serde::__private::Ok(__Field::__field1),
                                    b"publisher_node" => {
                                        _serde::__private::Ok(__Field::__field2)
                                    }
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<ProcessId>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = ProcessId;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct ProcessId",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct ProcessId with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct ProcessId with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    NodeId,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct ProcessId with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(ProcessId {
                                    process_name: __field0,
                                    package_name: __field1,
                                    publisher_node: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<NodeId> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "process_name",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "package_name",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "publisher_node",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<NodeId>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("process_name")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("package_name")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("publisher_node")?
                                    }
                                };
                                _serde::__private::Ok(ProcessId {
                                    process_name: __field0,
                                    package_name: __field1,
                                    publisher_node: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "process_name",
                            "package_name",
                            "publisher_node",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "ProcessId",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<ProcessId>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for ProcessId {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "ProcessId",
                            false as usize + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "process_name",
                            &self.process_name,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "package_name",
                            &self.package_name,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "publisher_node",
                            &self.publisher_node,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for ProcessId {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("ProcessId")
                        .field("process-name", &self.process_name)
                        .field("package-name", &self.package_name)
                        .field("publisher-node", &self.publisher_node)
                        .finish()
                }
            }
            pub struct PackageId {
                pub package_name: _rt::String,
                pub publisher_node: NodeId,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for PackageId {
                #[inline]
                fn clone(&self) -> PackageId {
                    PackageId {
                        package_name: ::core::clone::Clone::clone(&self.package_name),
                        publisher_node: ::core::clone::Clone::clone(&self.publisher_node),
                    }
                }
            }
            impl From<PackageId> for Vec<u8> {
                fn from(value: PackageId) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a PackageId> for Vec<u8> {
                fn from(value: &'a PackageId) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for PackageId {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for PackageId {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for PackageId {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "package_name" => _serde::__private::Ok(__Field::__field0),
                                    "publisher_node" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"package_name" => _serde::__private::Ok(__Field::__field0),
                                    b"publisher_node" => {
                                        _serde::__private::Ok(__Field::__field1)
                                    }
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<PackageId>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = PackageId;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct PackageId",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct PackageId with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    NodeId,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct PackageId with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(PackageId {
                                    package_name: __field0,
                                    publisher_node: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<NodeId> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "package_name",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "publisher_node",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<NodeId>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("package_name")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("publisher_node")?
                                    }
                                };
                                _serde::__private::Ok(PackageId {
                                    package_name: __field0,
                                    publisher_node: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "package_name",
                            "publisher_node",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "PackageId",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<PackageId>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for PackageId {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "PackageId",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "package_name",
                            &self.package_name,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "publisher_node",
                            &self.publisher_node,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for PackageId {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("PackageId")
                        .field("package-name", &self.package_name)
                        .field("publisher-node", &self.publisher_node)
                        .finish()
                }
            }
            pub struct Address {
                pub node: NodeId,
                pub process: ProcessId,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Address {
                #[inline]
                fn clone(&self) -> Address {
                    Address {
                        node: ::core::clone::Clone::clone(&self.node),
                        process: ::core::clone::Clone::clone(&self.process),
                    }
                }
            }
            impl From<Address> for Vec<u8> {
                fn from(value: Address) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a Address> for Vec<u8> {
                fn from(value: &'a Address) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for Address {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for Address {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for Address {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "node" => _serde::__private::Ok(__Field::__field0),
                                    "process" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"node" => _serde::__private::Ok(__Field::__field0),
                                    b"process" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<Address>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = Address;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct Address",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    NodeId,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct Address with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    ProcessId,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct Address with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(Address {
                                    node: __field0,
                                    process: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<NodeId> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<ProcessId> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("node"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<NodeId>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "process",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<ProcessId>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("node")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("process")?
                                    }
                                };
                                _serde::__private::Ok(Address {
                                    node: __field0,
                                    process: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["node", "process"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "Address",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<Address>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for Address {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "Address",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "node",
                            &self.node,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "process",
                            &self.process,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for Address {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Address")
                        .field("node", &self.node)
                        .field("process", &self.process)
                        .finish()
                }
            }
            pub struct LazyLoadBlob {
                pub mime: Option<_rt::String>,
                pub bytes: _rt::Vec<u8>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for LazyLoadBlob {
                #[inline]
                fn clone(&self) -> LazyLoadBlob {
                    LazyLoadBlob {
                        mime: ::core::clone::Clone::clone(&self.mime),
                        bytes: ::core::clone::Clone::clone(&self.bytes),
                    }
                }
            }
            impl From<LazyLoadBlob> for Vec<u8> {
                fn from(value: LazyLoadBlob) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a LazyLoadBlob> for Vec<u8> {
                fn from(value: &'a LazyLoadBlob) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for LazyLoadBlob {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for LazyLoadBlob {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for LazyLoadBlob {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "mime" => _serde::__private::Ok(__Field::__field0),
                                    "bytes" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"mime" => _serde::__private::Ok(__Field::__field0),
                                    b"bytes" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<LazyLoadBlob>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = LazyLoadBlob;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct LazyLoadBlob",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    Option<_rt::String>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct LazyLoadBlob with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    _rt::Vec<u8>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct LazyLoadBlob with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(LazyLoadBlob {
                                    mime: __field0,
                                    bytes: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<
                                    Option<_rt::String>,
                                > = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<_rt::Vec<u8>> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("mime"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Option<_rt::String>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("bytes"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::Vec<u8>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("mime")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("bytes")?
                                    }
                                };
                                _serde::__private::Ok(LazyLoadBlob {
                                    mime: __field0,
                                    bytes: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["mime", "bytes"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "LazyLoadBlob",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<LazyLoadBlob>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for LazyLoadBlob {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "LazyLoadBlob",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "mime",
                            &self.mime,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "bytes",
                            &self.bytes,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for LazyLoadBlob {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("LazyLoadBlob")
                        .field("mime", &self.mime)
                        .field("bytes", &self.bytes)
                        .finish()
                }
            }
            pub struct Capability {
                pub issuer: Address,
                pub params: Json,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Capability {
                #[inline]
                fn clone(&self) -> Capability {
                    Capability {
                        issuer: ::core::clone::Clone::clone(&self.issuer),
                        params: ::core::clone::Clone::clone(&self.params),
                    }
                }
            }
            impl From<Capability> for Vec<u8> {
                fn from(value: Capability) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a Capability> for Vec<u8> {
                fn from(value: &'a Capability) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for Capability {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for Capability {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for Capability {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "issuer" => _serde::__private::Ok(__Field::__field0),
                                    "params" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"issuer" => _serde::__private::Ok(__Field::__field0),
                                    b"params" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<Capability>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = Capability;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct Capability",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    Address,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct Capability with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Json,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct Capability with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(Capability {
                                    issuer: __field0,
                                    params: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<Address> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<Json> = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("issuer"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Address>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("params"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Json>(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("issuer")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("params")?
                                    }
                                };
                                _serde::__private::Ok(Capability {
                                    issuer: __field0,
                                    params: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["issuer", "params"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "Capability",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<Capability>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for Capability {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "Capability",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "issuer",
                            &self.issuer,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "params",
                            &self.params,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for Capability {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Capability")
                        .field("issuer", &self.issuer)
                        .field("params", &self.params)
                        .finish()
                }
            }
            pub struct Request {
                /// set in order to inherit lazy-load-blob from parent message, and if
                /// expects-response is none, direct response to source of parent.
                /// also carries forward certain aspects of parent message in kernel,
                /// see documentation for formal spec and examples:
                /// https://docs.rs/hyperware_process_lib/latest/hyperware_process_lib/struct.Request.html
                pub inherit: bool,
                /// if some, request expects a response in the given number of seconds
                pub expects_response: Option<u64>,
                pub body: _rt::Vec<u8>,
                pub metadata: Option<Json>,
                pub capabilities: _rt::Vec<Capability>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Request {
                #[inline]
                fn clone(&self) -> Request {
                    Request {
                        inherit: ::core::clone::Clone::clone(&self.inherit),
                        expects_response: ::core::clone::Clone::clone(
                            &self.expects_response,
                        ),
                        body: ::core::clone::Clone::clone(&self.body),
                        metadata: ::core::clone::Clone::clone(&self.metadata),
                        capabilities: ::core::clone::Clone::clone(&self.capabilities),
                    }
                }
            }
            impl From<Request> for Vec<u8> {
                fn from(value: Request) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a Request> for Vec<u8> {
                fn from(value: &'a Request) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for Request {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for Request {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for Request {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __field4,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    4u64 => _serde::__private::Ok(__Field::__field4),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "inherit" => _serde::__private::Ok(__Field::__field0),
                                    "expects_response" => {
                                        _serde::__private::Ok(__Field::__field1)
                                    }
                                    "body" => _serde::__private::Ok(__Field::__field2),
                                    "metadata" => _serde::__private::Ok(__Field::__field3),
                                    "capabilities" => _serde::__private::Ok(__Field::__field4),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"inherit" => _serde::__private::Ok(__Field::__field0),
                                    b"expects_response" => {
                                        _serde::__private::Ok(__Field::__field1)
                                    }
                                    b"body" => _serde::__private::Ok(__Field::__field2),
                                    b"metadata" => _serde::__private::Ok(__Field::__field3),
                                    b"capabilities" => _serde::__private::Ok(__Field::__field4),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<Request>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = Request;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct Request",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    bool,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct Request with 5 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Option<u64>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct Request with 5 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    _rt::Vec<u8>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct Request with 5 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field3 = match _serde::de::SeqAccess::next_element::<
                                    Option<Json>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                3usize,
                                                &"struct Request with 5 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field4 = match _serde::de::SeqAccess::next_element::<
                                    _rt::Vec<Capability>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                4usize,
                                                &"struct Request with 5 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(Request {
                                    inherit: __field0,
                                    expects_response: __field1,
                                    body: __field2,
                                    metadata: __field3,
                                    capabilities: __field4,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<bool> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<Option<u64>> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<_rt::Vec<u8>> = _serde::__private::None;
                                let mut __field3: _serde::__private::Option<Option<Json>> = _serde::__private::None;
                                let mut __field4: _serde::__private::Option<
                                    _rt::Vec<Capability>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "inherit",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "expects_response",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Option<u64>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("body"),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::Vec<u8>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field3 => {
                                            if _serde::__private::Option::is_some(&__field3) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "metadata",
                                                    ),
                                                );
                                            }
                                            __field3 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Option<Json>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field4 => {
                                            if _serde::__private::Option::is_some(&__field4) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "capabilities",
                                                    ),
                                                );
                                            }
                                            __field4 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::Vec<Capability>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("inherit")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("expects_response")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("body")?
                                    }
                                };
                                let __field3 = match __field3 {
                                    _serde::__private::Some(__field3) => __field3,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("metadata")?
                                    }
                                };
                                let __field4 = match __field4 {
                                    _serde::__private::Some(__field4) => __field4,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("capabilities")?
                                    }
                                };
                                _serde::__private::Ok(Request {
                                    inherit: __field0,
                                    expects_response: __field1,
                                    body: __field2,
                                    metadata: __field3,
                                    capabilities: __field4,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "inherit",
                            "expects_response",
                            "body",
                            "metadata",
                            "capabilities",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "Request",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<Request>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for Request {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "Request",
                            false as usize + 1 + 1 + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "inherit",
                            &self.inherit,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "expects_response",
                            &self.expects_response,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "body",
                            &self.body,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "metadata",
                            &self.metadata,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "capabilities",
                            &self.capabilities,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for Request {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Request")
                        .field("inherit", &self.inherit)
                        .field("expects-response", &self.expects_response)
                        .field("body", &self.body)
                        .field("metadata", &self.metadata)
                        .field("capabilities", &self.capabilities)
                        .finish()
                }
            }
            pub struct Response {
                pub inherit: bool,
                pub body: _rt::Vec<u8>,
                pub metadata: Option<Json>,
                pub capabilities: _rt::Vec<Capability>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Response {
                #[inline]
                fn clone(&self) -> Response {
                    Response {
                        inherit: ::core::clone::Clone::clone(&self.inherit),
                        body: ::core::clone::Clone::clone(&self.body),
                        metadata: ::core::clone::Clone::clone(&self.metadata),
                        capabilities: ::core::clone::Clone::clone(&self.capabilities),
                    }
                }
            }
            impl From<Response> for Vec<u8> {
                fn from(value: Response) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a Response> for Vec<u8> {
                fn from(value: &'a Response) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for Response {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for Response {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for Response {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "inherit" => _serde::__private::Ok(__Field::__field0),
                                    "body" => _serde::__private::Ok(__Field::__field1),
                                    "metadata" => _serde::__private::Ok(__Field::__field2),
                                    "capabilities" => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"inherit" => _serde::__private::Ok(__Field::__field0),
                                    b"body" => _serde::__private::Ok(__Field::__field1),
                                    b"metadata" => _serde::__private::Ok(__Field::__field2),
                                    b"capabilities" => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<Response>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = Response;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct Response",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    bool,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct Response with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    _rt::Vec<u8>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct Response with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    Option<Json>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct Response with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field3 = match _serde::de::SeqAccess::next_element::<
                                    _rt::Vec<Capability>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                3usize,
                                                &"struct Response with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(Response {
                                    inherit: __field0,
                                    body: __field1,
                                    metadata: __field2,
                                    capabilities: __field3,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<bool> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<_rt::Vec<u8>> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<Option<Json>> = _serde::__private::None;
                                let mut __field3: _serde::__private::Option<
                                    _rt::Vec<Capability>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "inherit",
                                                    ),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("body"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::Vec<u8>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "metadata",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Option<Json>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field3 => {
                                            if _serde::__private::Option::is_some(&__field3) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "capabilities",
                                                    ),
                                                );
                                            }
                                            __field3 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::Vec<Capability>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("inherit")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("body")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("metadata")?
                                    }
                                };
                                let __field3 = match __field3 {
                                    _serde::__private::Some(__field3) => __field3,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("capabilities")?
                                    }
                                };
                                _serde::__private::Ok(Response {
                                    inherit: __field0,
                                    body: __field1,
                                    metadata: __field2,
                                    capabilities: __field3,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "inherit",
                            "body",
                            "metadata",
                            "capabilities",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "Response",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<Response>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for Response {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "Response",
                            false as usize + 1 + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "inherit",
                            &self.inherit,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "body",
                            &self.body,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "metadata",
                            &self.metadata,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "capabilities",
                            &self.capabilities,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for Response {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Response")
                        .field("inherit", &self.inherit)
                        .field("body", &self.body)
                        .field("metadata", &self.metadata)
                        .field("capabilities", &self.capabilities)
                        .finish()
                }
            }
            /// A message can be a request or a response. Within a response, there is
            /// a result which surfaces any error that happened because of a request.
            /// A successful response will contain the context of the request it
            /// matches, if any was set.
            pub enum Message {
                Request(Request),
                Response((Response, Option<Context>)),
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Message {
                #[inline]
                fn clone(&self) -> Message {
                    match self {
                        Message::Request(__self_0) => {
                            Message::Request(::core::clone::Clone::clone(__self_0))
                        }
                        Message::Response(__self_0) => {
                            Message::Response(::core::clone::Clone::clone(__self_0))
                        }
                    }
                }
            }
            impl From<Message> for Vec<u8> {
                fn from(value: Message) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a Message> for Vec<u8> {
                fn from(value: &'a Message) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for Message {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for Message {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for Message {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "variant identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"variant index 0 <= i < 2",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "Request" => _serde::__private::Ok(__Field::__field0),
                                    "Response" => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"Request" => _serde::__private::Ok(__Field::__field0),
                                    b"Response" => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<Message>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = Message;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "enum Message",
                                )
                            }
                            fn visit_enum<__A>(
                                self,
                                __data: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::EnumAccess<'de>,
                            {
                                match _serde::de::EnumAccess::variant(__data)? {
                                    (__Field::__field0, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                Request,
                                            >(__variant),
                                            Message::Request,
                                        )
                                    }
                                    (__Field::__field1, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                (Response, Option<Context>),
                                            >(__variant),
                                            Message::Response,
                                        )
                                    }
                                }
                            }
                        }
                        #[doc(hidden)]
                        const VARIANTS: &'static [&'static str] = &[
                            "Request",
                            "Response",
                        ];
                        _serde::Deserializer::deserialize_enum(
                            __deserializer,
                            "Message",
                            VARIANTS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<Message>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for Message {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        match *self {
                            Message::Request(ref __field0) => {
                                _serde::Serializer::serialize_newtype_variant(
                                    __serializer,
                                    "Message",
                                    0u32,
                                    "Request",
                                    __field0,
                                )
                            }
                            Message::Response(ref __field0) => {
                                _serde::Serializer::serialize_newtype_variant(
                                    __serializer,
                                    "Message",
                                    1u32,
                                    "Response",
                                    __field0,
                                )
                            }
                        }
                    }
                }
            };
            impl ::core::fmt::Debug for Message {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        Message::Request(e) => {
                            f.debug_tuple("Message::Request").field(e).finish()
                        }
                        Message::Response(e) => {
                            f.debug_tuple("Message::Response").field(e).finish()
                        }
                    }
                }
            }
            /// On-exit is a setting that determines what happens when a process
            /// panics, completes, or otherwise "ends".
            /// NOTE: requests will always have expects-response set to false by kernel.
            pub enum OnExit {
                None,
                Restart,
                Requests(_rt::Vec<(Address, Request, Option<LazyLoadBlob>)>),
            }
            #[automatically_derived]
            impl ::core::clone::Clone for OnExit {
                #[inline]
                fn clone(&self) -> OnExit {
                    match self {
                        OnExit::None => OnExit::None,
                        OnExit::Restart => OnExit::Restart,
                        OnExit::Requests(__self_0) => {
                            OnExit::Requests(::core::clone::Clone::clone(__self_0))
                        }
                    }
                }
            }
            impl From<OnExit> for Vec<u8> {
                fn from(value: OnExit) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a OnExit> for Vec<u8> {
                fn from(value: &'a OnExit) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for OnExit {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for OnExit {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for OnExit {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "variant identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"variant index 0 <= i < 3",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "None" => _serde::__private::Ok(__Field::__field0),
                                    "Restart" => _serde::__private::Ok(__Field::__field1),
                                    "Requests" => _serde::__private::Ok(__Field::__field2),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"None" => _serde::__private::Ok(__Field::__field0),
                                    b"Restart" => _serde::__private::Ok(__Field::__field1),
                                    b"Requests" => _serde::__private::Ok(__Field::__field2),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<OnExit>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = OnExit;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "enum OnExit",
                                )
                            }
                            fn visit_enum<__A>(
                                self,
                                __data: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::EnumAccess<'de>,
                            {
                                match _serde::de::EnumAccess::variant(__data)? {
                                    (__Field::__field0, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(OnExit::None)
                                    }
                                    (__Field::__field1, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(OnExit::Restart)
                                    }
                                    (__Field::__field2, __variant) => {
                                        _serde::__private::Result::map(
                                            _serde::de::VariantAccess::newtype_variant::<
                                                _rt::Vec<(Address, Request, Option<LazyLoadBlob>)>,
                                            >(__variant),
                                            OnExit::Requests,
                                        )
                                    }
                                }
                            }
                        }
                        #[doc(hidden)]
                        const VARIANTS: &'static [&'static str] = &[
                            "None",
                            "Restart",
                            "Requests",
                        ];
                        _serde::Deserializer::deserialize_enum(
                            __deserializer,
                            "OnExit",
                            VARIANTS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<OnExit>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for OnExit {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        match *self {
                            OnExit::None => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "OnExit",
                                    0u32,
                                    "None",
                                )
                            }
                            OnExit::Restart => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "OnExit",
                                    1u32,
                                    "Restart",
                                )
                            }
                            OnExit::Requests(ref __field0) => {
                                _serde::Serializer::serialize_newtype_variant(
                                    __serializer,
                                    "OnExit",
                                    2u32,
                                    "Requests",
                                    __field0,
                                )
                            }
                        }
                    }
                }
            };
            impl ::core::fmt::Debug for OnExit {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        OnExit::None => f.debug_tuple("OnExit::None").finish(),
                        OnExit::Restart => f.debug_tuple("OnExit::Restart").finish(),
                        OnExit::Requests(e) => {
                            f.debug_tuple("OnExit::Requests").field(e).finish()
                        }
                    }
                }
            }
            #[repr(u8)]
            pub enum SendErrorKind {
                Offline,
                Timeout,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for SendErrorKind {
                #[inline]
                fn clone(&self) -> SendErrorKind {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for SendErrorKind {}
            #[automatically_derived]
            impl ::core::cmp::Eq for SendErrorKind {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for SendErrorKind {
                #[inline]
                fn cmp(&self, other: &SendErrorKind) -> ::core::cmp::Ordering {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr)
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for SendErrorKind {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for SendErrorKind {
                #[inline]
                fn eq(&self, other: &SendErrorKind) -> bool {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    __self_discr == __arg1_discr
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for SendErrorKind {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &SendErrorKind,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::PartialOrd::partial_cmp(&__self_discr, &__arg1_discr)
                }
            }
            impl From<SendErrorKind> for Vec<u8> {
                fn from(value: SendErrorKind) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a SendErrorKind> for Vec<u8> {
                fn from(value: &'a SendErrorKind) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for SendErrorKind {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for SendErrorKind {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for SendErrorKind {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "variant identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"variant index 0 <= i < 2",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "Offline" => _serde::__private::Ok(__Field::__field0),
                                    "Timeout" => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"Offline" => _serde::__private::Ok(__Field::__field0),
                                    b"Timeout" => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<SendErrorKind>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = SendErrorKind;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "enum SendErrorKind",
                                )
                            }
                            fn visit_enum<__A>(
                                self,
                                __data: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::EnumAccess<'de>,
                            {
                                match _serde::de::EnumAccess::variant(__data)? {
                                    (__Field::__field0, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(SendErrorKind::Offline)
                                    }
                                    (__Field::__field1, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(SendErrorKind::Timeout)
                                    }
                                }
                            }
                        }
                        #[doc(hidden)]
                        const VARIANTS: &'static [&'static str] = &[
                            "Offline",
                            "Timeout",
                        ];
                        _serde::Deserializer::deserialize_enum(
                            __deserializer,
                            "SendErrorKind",
                            VARIANTS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<SendErrorKind>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for SendErrorKind {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        match *self {
                            SendErrorKind::Offline => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "SendErrorKind",
                                    0u32,
                                    "Offline",
                                )
                            }
                            SendErrorKind::Timeout => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "SendErrorKind",
                                    1u32,
                                    "Timeout",
                                )
                            }
                        }
                    }
                }
            };
            impl ::core::fmt::Debug for SendErrorKind {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        SendErrorKind::Offline => {
                            f.debug_tuple("SendErrorKind::Offline").finish()
                        }
                        SendErrorKind::Timeout => {
                            f.debug_tuple("SendErrorKind::Timeout").finish()
                        }
                    }
                }
            }
            impl SendErrorKind {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> SendErrorKind {
                    if !true {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => SendErrorKind::Offline,
                        1 => SendErrorKind::Timeout,
                        _ => {
                            ::core::panicking::panic_fmt(
                                format_args!("invalid enum discriminant"),
                            );
                        }
                    }
                }
            }
            /// Send errors come from trying to send a message to another process,
            /// either locally or on another node.
            /// A message can fail by timing out, or by the node being entirely
            /// unreachable (offline or can't be found in PKI). In either case,
            /// the message is not delivered and the process that sent it receives
            /// that message back along with any assigned context and/or lazy-load-blob,
            /// and is free to handle it as it sees fit.
            /// In the local case, only timeout errors are possible and also cover the case
            /// in which a process is not running or does not exist.
            pub struct SendError {
                pub kind: SendErrorKind,
                pub target: Address,
                pub message: Message,
                pub lazy_load_blob: Option<LazyLoadBlob>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for SendError {
                #[inline]
                fn clone(&self) -> SendError {
                    SendError {
                        kind: ::core::clone::Clone::clone(&self.kind),
                        target: ::core::clone::Clone::clone(&self.target),
                        message: ::core::clone::Clone::clone(&self.message),
                        lazy_load_blob: ::core::clone::Clone::clone(&self.lazy_load_blob),
                    }
                }
            }
            impl From<SendError> for Vec<u8> {
                fn from(value: SendError) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a SendError> for Vec<u8> {
                fn from(value: &'a SendError) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for SendError {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for SendError {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for SendError {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    3u64 => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "kind" => _serde::__private::Ok(__Field::__field0),
                                    "target" => _serde::__private::Ok(__Field::__field1),
                                    "message" => _serde::__private::Ok(__Field::__field2),
                                    "lazy_load_blob" => _serde::__private::Ok(__Field::__field3),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"kind" => _serde::__private::Ok(__Field::__field0),
                                    b"target" => _serde::__private::Ok(__Field::__field1),
                                    b"message" => _serde::__private::Ok(__Field::__field2),
                                    b"lazy_load_blob" => {
                                        _serde::__private::Ok(__Field::__field3)
                                    }
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<SendError>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = SendError;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct SendError",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    SendErrorKind,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct SendError with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Address,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct SendError with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    Message,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct SendError with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field3 = match _serde::de::SeqAccess::next_element::<
                                    Option<LazyLoadBlob>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                3usize,
                                                &"struct SendError with 4 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(SendError {
                                    kind: __field0,
                                    target: __field1,
                                    message: __field2,
                                    lazy_load_blob: __field3,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<
                                    SendErrorKind,
                                > = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<Address> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<Message> = _serde::__private::None;
                                let mut __field3: _serde::__private::Option<
                                    Option<LazyLoadBlob>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("kind"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    SendErrorKind,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("target"),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Address>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "message",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<Message>(&mut __map)?,
                                            );
                                        }
                                        __Field::__field3 => {
                                            if _serde::__private::Option::is_some(&__field3) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "lazy_load_blob",
                                                    ),
                                                );
                                            }
                                            __field3 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Option<LazyLoadBlob>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("kind")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("target")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("message")?
                                    }
                                };
                                let __field3 = match __field3 {
                                    _serde::__private::Some(__field3) => __field3,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("lazy_load_blob")?
                                    }
                                };
                                _serde::__private::Ok(SendError {
                                    kind: __field0,
                                    target: __field1,
                                    message: __field2,
                                    lazy_load_blob: __field3,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "kind",
                            "target",
                            "message",
                            "lazy_load_blob",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "SendError",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<SendError>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for SendError {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "SendError",
                            false as usize + 1 + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "kind",
                            &self.kind,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "target",
                            &self.target,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "message",
                            &self.message,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "lazy_load_blob",
                            &self.lazy_load_blob,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for SendError {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("SendError")
                        .field("kind", &self.kind)
                        .field("target", &self.target)
                        .field("message", &self.message)
                        .field("lazy-load-blob", &self.lazy_load_blob)
                        .finish()
                }
            }
            impl ::core::fmt::Display for SendError {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.write_fmt(format_args!("{0:?}", self))
                }
            }
            impl std::error::Error for SendError {}
            #[repr(u8)]
            pub enum SpawnError {
                NameTaken,
                NoFileAtPath,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for SpawnError {
                #[inline]
                fn clone(&self) -> SpawnError {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for SpawnError {}
            #[automatically_derived]
            impl ::core::cmp::Eq for SpawnError {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {}
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for SpawnError {
                #[inline]
                fn cmp(&self, other: &SpawnError) -> ::core::cmp::Ordering {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr)
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for SpawnError {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for SpawnError {
                #[inline]
                fn eq(&self, other: &SpawnError) -> bool {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    __self_discr == __arg1_discr
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for SpawnError {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &SpawnError,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    let __self_discr = ::core::intrinsics::discriminant_value(self);
                    let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                    ::core::cmp::PartialOrd::partial_cmp(&__self_discr, &__arg1_discr)
                }
            }
            impl From<SpawnError> for Vec<u8> {
                fn from(value: SpawnError) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a SpawnError> for Vec<u8> {
                fn from(value: &'a SpawnError) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for SpawnError {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for SpawnError {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for SpawnError {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "variant identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::invalid_value(
                                                _serde::de::Unexpected::Unsigned(__value),
                                                &"variant index 0 <= i < 2",
                                            ),
                                        )
                                    }
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "NameTaken" => _serde::__private::Ok(__Field::__field0),
                                    "NoFileAtPath" => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"NameTaken" => _serde::__private::Ok(__Field::__field0),
                                    b"NoFileAtPath" => _serde::__private::Ok(__Field::__field1),
                                    _ => {
                                        let __value = &_serde::__private::from_utf8_lossy(__value);
                                        _serde::__private::Err(
                                            _serde::de::Error::unknown_variant(__value, VARIANTS),
                                        )
                                    }
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<SpawnError>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = SpawnError;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "enum SpawnError",
                                )
                            }
                            fn visit_enum<__A>(
                                self,
                                __data: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::EnumAccess<'de>,
                            {
                                match _serde::de::EnumAccess::variant(__data)? {
                                    (__Field::__field0, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(SpawnError::NameTaken)
                                    }
                                    (__Field::__field1, __variant) => {
                                        _serde::de::VariantAccess::unit_variant(__variant)?;
                                        _serde::__private::Ok(SpawnError::NoFileAtPath)
                                    }
                                }
                            }
                        }
                        #[doc(hidden)]
                        const VARIANTS: &'static [&'static str] = &[
                            "NameTaken",
                            "NoFileAtPath",
                        ];
                        _serde::Deserializer::deserialize_enum(
                            __deserializer,
                            "SpawnError",
                            VARIANTS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<SpawnError>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for SpawnError {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        match *self {
                            SpawnError::NameTaken => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "SpawnError",
                                    0u32,
                                    "NameTaken",
                                )
                            }
                            SpawnError::NoFileAtPath => {
                                _serde::Serializer::serialize_unit_variant(
                                    __serializer,
                                    "SpawnError",
                                    1u32,
                                    "NoFileAtPath",
                                )
                            }
                        }
                    }
                }
            };
            impl SpawnError {
                pub fn name(&self) -> &'static str {
                    match self {
                        SpawnError::NameTaken => "name-taken",
                        SpawnError::NoFileAtPath => "no-file-at-path",
                    }
                }
                pub fn message(&self) -> &'static str {
                    match self {
                        SpawnError::NameTaken => "",
                        SpawnError::NoFileAtPath => "",
                    }
                }
            }
            impl ::core::fmt::Debug for SpawnError {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("SpawnError")
                        .field("code", &(*self as i32))
                        .field("name", &self.name())
                        .field("message", &self.message())
                        .finish()
                }
            }
            impl ::core::fmt::Display for SpawnError {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.write_fmt(
                        format_args!("{0} (error {1})", self.name(), *self as i32),
                    )
                }
            }
            impl std::error::Error for SpawnError {}
            impl SpawnError {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> SpawnError {
                    if !true {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => SpawnError::NameTaken,
                        1 => SpawnError::NoFileAtPath,
                        _ => {
                            ::core::panicking::panic_fmt(
                                format_args!("invalid enum discriminant"),
                            );
                        }
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            ///   
            /// System Utils
            ///   
            /// Prints to the terminal at a given verbosity level.
            /// Higher verbosity levels print more information.
            /// Level 0 is always printed -- use sparingly.
            pub fn print_to_terminal(verbosity: u8, message: &str) {
                unsafe {
                    let vec0 = message;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: i32, _: *mut u8, _: usize) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(_rt::as_i32(&verbosity), ptr0.cast_mut(), len0);
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Returns the address of the process.
            pub fn our() -> Address {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 32]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 32]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(ptr0);
                    let l1 = *ptr0.add(0).cast::<*mut u8>();
                    let l2 = *ptr0.add(4).cast::<usize>();
                    let len3 = l2;
                    let bytes3 = _rt::Vec::from_raw_parts(l1.cast(), len3, len3);
                    let l4 = *ptr0.add(8).cast::<*mut u8>();
                    let l5 = *ptr0.add(12).cast::<usize>();
                    let len6 = l5;
                    let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
                    let l7 = *ptr0.add(16).cast::<*mut u8>();
                    let l8 = *ptr0.add(20).cast::<usize>();
                    let len9 = l8;
                    let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);
                    let l10 = *ptr0.add(24).cast::<*mut u8>();
                    let l11 = *ptr0.add(28).cast::<usize>();
                    let len12 = l11;
                    let bytes12 = _rt::Vec::from_raw_parts(l10.cast(), len12, len12);
                    Address {
                        node: _rt::string_lift(bytes3),
                        process: ProcessId {
                            process_name: _rt::string_lift(bytes6),
                            package_name: _rt::string_lift(bytes9),
                            publisher_node: _rt::string_lift(bytes12),
                        },
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            ///   
            /// Process Management
            ///   
            pub fn get_on_exit() -> OnExit {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 12]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(ptr0);
                    let l1 = i32::from(*ptr0.add(0).cast::<u8>());
                    let v53 = match l1 {
                        0 => OnExit::None,
                        1 => OnExit::Restart,
                        n => {
                            if true {
                                match (&n, &2) {
                                    (left_val, right_val) => {
                                        if !(*left_val == *right_val) {
                                            let kind = ::core::panicking::AssertKind::Eq;
                                            ::core::panicking::assert_failed(
                                                kind,
                                                &*left_val,
                                                &*right_val,
                                                ::core::option::Option::Some(
                                                    format_args!("invalid enum discriminant"),
                                                ),
                                            );
                                        }
                                    }
                                };
                            }
                            let e53 = {
                                let l2 = *ptr0.add(4).cast::<*mut u8>();
                                let l3 = *ptr0.add(8).cast::<usize>();
                                let base52 = l2;
                                let len52 = l3;
                                let mut result52 = _rt::Vec::with_capacity(len52);
                                for i in 0..len52 {
                                    let base = base52.add(i * 112);
                                    let e52 = {
                                        let l4 = *base.add(0).cast::<*mut u8>();
                                        let l5 = *base.add(4).cast::<usize>();
                                        let len6 = l5;
                                        let bytes6 = _rt::Vec::from_raw_parts(
                                            l4.cast(),
                                            len6,
                                            len6,
                                        );
                                        let l7 = *base.add(8).cast::<*mut u8>();
                                        let l8 = *base.add(12).cast::<usize>();
                                        let len9 = l8;
                                        let bytes9 = _rt::Vec::from_raw_parts(
                                            l7.cast(),
                                            len9,
                                            len9,
                                        );
                                        let l10 = *base.add(16).cast::<*mut u8>();
                                        let l11 = *base.add(20).cast::<usize>();
                                        let len12 = l11;
                                        let bytes12 = _rt::Vec::from_raw_parts(
                                            l10.cast(),
                                            len12,
                                            len12,
                                        );
                                        let l13 = *base.add(24).cast::<*mut u8>();
                                        let l14 = *base.add(28).cast::<usize>();
                                        let len15 = l14;
                                        let bytes15 = _rt::Vec::from_raw_parts(
                                            l13.cast(),
                                            len15,
                                            len15,
                                        );
                                        let l16 = i32::from(*base.add(32).cast::<u8>());
                                        let l17 = i32::from(*base.add(40).cast::<u8>());
                                        let l19 = *base.add(56).cast::<*mut u8>();
                                        let l20 = *base.add(60).cast::<usize>();
                                        let len21 = l20;
                                        let l22 = i32::from(*base.add(64).cast::<u8>());
                                        let l26 = *base.add(76).cast::<*mut u8>();
                                        let l27 = *base.add(80).cast::<usize>();
                                        let base43 = l26;
                                        let len43 = l27;
                                        let mut result43 = _rt::Vec::with_capacity(len43);
                                        for i in 0..len43 {
                                            let base = base43.add(i * 40);
                                            let e43 = {
                                                let l28 = *base.add(0).cast::<*mut u8>();
                                                let l29 = *base.add(4).cast::<usize>();
                                                let len30 = l29;
                                                let bytes30 = _rt::Vec::from_raw_parts(
                                                    l28.cast(),
                                                    len30,
                                                    len30,
                                                );
                                                let l31 = *base.add(8).cast::<*mut u8>();
                                                let l32 = *base.add(12).cast::<usize>();
                                                let len33 = l32;
                                                let bytes33 = _rt::Vec::from_raw_parts(
                                                    l31.cast(),
                                                    len33,
                                                    len33,
                                                );
                                                let l34 = *base.add(16).cast::<*mut u8>();
                                                let l35 = *base.add(20).cast::<usize>();
                                                let len36 = l35;
                                                let bytes36 = _rt::Vec::from_raw_parts(
                                                    l34.cast(),
                                                    len36,
                                                    len36,
                                                );
                                                let l37 = *base.add(24).cast::<*mut u8>();
                                                let l38 = *base.add(28).cast::<usize>();
                                                let len39 = l38;
                                                let bytes39 = _rt::Vec::from_raw_parts(
                                                    l37.cast(),
                                                    len39,
                                                    len39,
                                                );
                                                let l40 = *base.add(32).cast::<*mut u8>();
                                                let l41 = *base.add(36).cast::<usize>();
                                                let len42 = l41;
                                                let bytes42 = _rt::Vec::from_raw_parts(
                                                    l40.cast(),
                                                    len42,
                                                    len42,
                                                );
                                                Capability {
                                                    issuer: Address {
                                                        node: _rt::string_lift(bytes30),
                                                        process: ProcessId {
                                                            process_name: _rt::string_lift(bytes33),
                                                            package_name: _rt::string_lift(bytes36),
                                                            publisher_node: _rt::string_lift(bytes39),
                                                        },
                                                    },
                                                    params: _rt::string_lift(bytes42),
                                                }
                                            };
                                            result43.push(e43);
                                        }
                                        _rt::cabi_dealloc(base43, len43 * 40, 4);
                                        let l44 = i32::from(*base.add(88).cast::<u8>());
                                        (
                                            Address {
                                                node: _rt::string_lift(bytes6),
                                                process: ProcessId {
                                                    process_name: _rt::string_lift(bytes9),
                                                    package_name: _rt::string_lift(bytes12),
                                                    publisher_node: _rt::string_lift(bytes15),
                                                },
                                            },
                                            Request {
                                                inherit: _rt::bool_lift(l16 as u8),
                                                expects_response: match l17 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l18 = *base.add(48).cast::<i64>();
                                                            l18 as u64
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                                body: _rt::Vec::from_raw_parts(l19.cast(), len21, len21),
                                                metadata: match l22 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l23 = *base.add(68).cast::<*mut u8>();
                                                            let l24 = *base.add(72).cast::<usize>();
                                                            let len25 = l24;
                                                            let bytes25 = _rt::Vec::from_raw_parts(
                                                                l23.cast(),
                                                                len25,
                                                                len25,
                                                            );
                                                            _rt::string_lift(bytes25)
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                                capabilities: result43,
                                            },
                                            match l44 {
                                                0 => None,
                                                1 => {
                                                    let e = {
                                                        let l45 = i32::from(*base.add(92).cast::<u8>());
                                                        let l49 = *base.add(104).cast::<*mut u8>();
                                                        let l50 = *base.add(108).cast::<usize>();
                                                        let len51 = l50;
                                                        LazyLoadBlob {
                                                            mime: match l45 {
                                                                0 => None,
                                                                1 => {
                                                                    let e = {
                                                                        let l46 = *base.add(96).cast::<*mut u8>();
                                                                        let l47 = *base.add(100).cast::<usize>();
                                                                        let len48 = l47;
                                                                        let bytes48 = _rt::Vec::from_raw_parts(
                                                                            l46.cast(),
                                                                            len48,
                                                                            len48,
                                                                        );
                                                                        _rt::string_lift(bytes48)
                                                                    };
                                                                    Some(e)
                                                                }
                                                                _ => _rt::invalid_enum_discriminant(),
                                                            },
                                                            bytes: _rt::Vec::from_raw_parts(l49.cast(), len51, len51),
                                                        }
                                                    };
                                                    Some(e)
                                                }
                                                _ => _rt::invalid_enum_discriminant(),
                                            },
                                        )
                                    };
                                    result52.push(e52);
                                }
                                _rt::cabi_dealloc(base52, len52 * 112, 8);
                                result52
                            };
                            OnExit::Requests(e53)
                        }
                    };
                    v53
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn set_on_exit(on_exit: &OnExit) {
                unsafe {
                    let mut cleanup_list = _rt::Vec::new();
                    let (result23_0, result23_1, result23_2) = match on_exit {
                        OnExit::None => (0i32, ::core::ptr::null_mut(), 0usize),
                        OnExit::Restart => (1i32, ::core::ptr::null_mut(), 0usize),
                        OnExit::Requests(e) => {
                            let vec22 = e;
                            let len22 = vec22.len();
                            let layout22 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec22.len() * 112,
                                8,
                            );
                            let result22 = if layout22.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout22).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout22);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec22.into_iter().enumerate() {
                                let base = result22.add(i * 112);
                                {
                                    let (t0_0, t0_1, t0_2) = e;
                                    let Address { node: node1, process: process1 } = t0_0;
                                    let vec2 = node1;
                                    let ptr2 = vec2.as_ptr().cast::<u8>();
                                    let len2 = vec2.len();
                                    *base.add(4).cast::<usize>() = len2;
                                    *base.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                                    let ProcessId {
                                        process_name: process_name3,
                                        package_name: package_name3,
                                        publisher_node: publisher_node3,
                                    } = process1;
                                    let vec4 = process_name3;
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();
                                    *base.add(12).cast::<usize>() = len4;
                                    *base.add(8).cast::<*mut u8>() = ptr4.cast_mut();
                                    let vec5 = package_name3;
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    *base.add(20).cast::<usize>() = len5;
                                    *base.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                                    let vec6 = publisher_node3;
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    *base.add(28).cast::<usize>() = len6;
                                    *base.add(24).cast::<*mut u8>() = ptr6.cast_mut();
                                    let Request {
                                        inherit: inherit7,
                                        expects_response: expects_response7,
                                        body: body7,
                                        metadata: metadata7,
                                        capabilities: capabilities7,
                                    } = t0_1;
                                    *base.add(32).cast::<u8>() = (match inherit7 {
                                        true => 1,
                                        false => 0,
                                    }) as u8;
                                    match expects_response7 {
                                        Some(e) => {
                                            *base.add(40).cast::<u8>() = (1i32) as u8;
                                            *base.add(48).cast::<i64>() = _rt::as_i64(e);
                                        }
                                        None => {
                                            *base.add(40).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    let vec8 = body7;
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    *base.add(60).cast::<usize>() = len8;
                                    *base.add(56).cast::<*mut u8>() = ptr8.cast_mut();
                                    match metadata7 {
                                        Some(e) => {
                                            *base.add(64).cast::<u8>() = (1i32) as u8;
                                            let vec9 = e;
                                            let ptr9 = vec9.as_ptr().cast::<u8>();
                                            let len9 = vec9.len();
                                            *base.add(72).cast::<usize>() = len9;
                                            *base.add(68).cast::<*mut u8>() = ptr9.cast_mut();
                                        }
                                        None => {
                                            *base.add(64).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    let vec18 = capabilities7;
                                    let len18 = vec18.len();
                                    let layout18 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec18.len() * 40,
                                        4,
                                    );
                                    let result18 = if layout18.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout18).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout18);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec18.into_iter().enumerate() {
                                        let base = result18.add(i * 40);
                                        {
                                            let Capability { issuer: issuer10, params: params10 } = e;
                                            let Address { node: node11, process: process11 } = issuer10;
                                            let vec12 = node11;
                                            let ptr12 = vec12.as_ptr().cast::<u8>();
                                            let len12 = vec12.len();
                                            *base.add(4).cast::<usize>() = len12;
                                            *base.add(0).cast::<*mut u8>() = ptr12.cast_mut();
                                            let ProcessId {
                                                process_name: process_name13,
                                                package_name: package_name13,
                                                publisher_node: publisher_node13,
                                            } = process11;
                                            let vec14 = process_name13;
                                            let ptr14 = vec14.as_ptr().cast::<u8>();
                                            let len14 = vec14.len();
                                            *base.add(12).cast::<usize>() = len14;
                                            *base.add(8).cast::<*mut u8>() = ptr14.cast_mut();
                                            let vec15 = package_name13;
                                            let ptr15 = vec15.as_ptr().cast::<u8>();
                                            let len15 = vec15.len();
                                            *base.add(20).cast::<usize>() = len15;
                                            *base.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                            let vec16 = publisher_node13;
                                            let ptr16 = vec16.as_ptr().cast::<u8>();
                                            let len16 = vec16.len();
                                            *base.add(28).cast::<usize>() = len16;
                                            *base.add(24).cast::<*mut u8>() = ptr16.cast_mut();
                                            let vec17 = params10;
                                            let ptr17 = vec17.as_ptr().cast::<u8>();
                                            let len17 = vec17.len();
                                            *base.add(36).cast::<usize>() = len17;
                                            *base.add(32).cast::<*mut u8>() = ptr17.cast_mut();
                                        }
                                    }
                                    *base.add(80).cast::<usize>() = len18;
                                    *base.add(76).cast::<*mut u8>() = result18;
                                    match t0_2 {
                                        Some(e) => {
                                            *base.add(88).cast::<u8>() = (1i32) as u8;
                                            let LazyLoadBlob { mime: mime19, bytes: bytes19 } = e;
                                            match mime19 {
                                                Some(e) => {
                                                    *base.add(92).cast::<u8>() = (1i32) as u8;
                                                    let vec20 = e;
                                                    let ptr20 = vec20.as_ptr().cast::<u8>();
                                                    let len20 = vec20.len();
                                                    *base.add(100).cast::<usize>() = len20;
                                                    *base.add(96).cast::<*mut u8>() = ptr20.cast_mut();
                                                }
                                                None => {
                                                    *base.add(92).cast::<u8>() = (0i32) as u8;
                                                }
                                            };
                                            let vec21 = bytes19;
                                            let ptr21 = vec21.as_ptr().cast::<u8>();
                                            let len21 = vec21.len();
                                            *base.add(108).cast::<usize>() = len21;
                                            *base.add(104).cast::<*mut u8>() = ptr21.cast_mut();
                                        }
                                        None => {
                                            *base.add(88).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    cleanup_list.extend_from_slice(&[(result18, layout18)]);
                                }
                            }
                            cleanup_list.extend_from_slice(&[(result22, layout22)]);
                            (2i32, result22, len22)
                        }
                    };
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: i32, _: *mut u8, _: usize) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(result23_0, result23_1, result23_2);
                    for (ptr, layout) in cleanup_list {
                        if layout.size() != 0 {
                            _rt::alloc::dealloc(ptr.cast(), layout);
                        }
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn get_state() -> Option<_rt::Vec<u8>> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 12]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(ptr0);
                    let l1 = i32::from(*ptr0.add(0).cast::<u8>());
                    match l1 {
                        0 => None,
                        1 => {
                            let e = {
                                let l2 = *ptr0.add(4).cast::<*mut u8>();
                                let l3 = *ptr0.add(8).cast::<usize>();
                                let len4 = l3;
                                _rt::Vec::from_raw_parts(l2.cast(), len4, len4)
                            };
                            Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn set_state(bytes: &[u8]) {
                unsafe {
                    let vec0 = bytes;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(ptr0.cast_mut(), len0);
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn clear_state() {
                unsafe {
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import() {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import();
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn spawn(
                name: Option<&str>,
                wasm_path: &str,
                on_exit: &OnExit,
                request_capabilities: &[Capability],
                grant_capabilities: &[(ProcessId, Json)],
                public: bool,
            ) -> Result<ProcessId, SpawnError> {
                unsafe {
                    let mut cleanup_list = _rt::Vec::new();
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 28]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 28]);
                    let (result1_0, result1_1, result1_2) = match name {
                        Some(e) => {
                            let vec0 = e;
                            let ptr0 = vec0.as_ptr().cast::<u8>();
                            let len0 = vec0.len();
                            (1i32, ptr0.cast_mut(), len0)
                        }
                        None => (0i32, ::core::ptr::null_mut(), 0usize),
                    };
                    let vec2 = wasm_path;
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    let (result26_0, result26_1, result26_2) = match on_exit {
                        OnExit::None => (0i32, ::core::ptr::null_mut(), 0usize),
                        OnExit::Restart => (1i32, ::core::ptr::null_mut(), 0usize),
                        OnExit::Requests(e) => {
                            let vec25 = e;
                            let len25 = vec25.len();
                            let layout25 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec25.len() * 112,
                                8,
                            );
                            let result25 = if layout25.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout25).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout25);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec25.into_iter().enumerate() {
                                let base = result25.add(i * 112);
                                {
                                    let (t3_0, t3_1, t3_2) = e;
                                    let Address { node: node4, process: process4 } = t3_0;
                                    let vec5 = node4;
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    *base.add(4).cast::<usize>() = len5;
                                    *base.add(0).cast::<*mut u8>() = ptr5.cast_mut();
                                    let ProcessId {
                                        process_name: process_name6,
                                        package_name: package_name6,
                                        publisher_node: publisher_node6,
                                    } = process4;
                                    let vec7 = process_name6;
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    *base.add(12).cast::<usize>() = len7;
                                    *base.add(8).cast::<*mut u8>() = ptr7.cast_mut();
                                    let vec8 = package_name6;
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    *base.add(20).cast::<usize>() = len8;
                                    *base.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                                    let vec9 = publisher_node6;
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    *base.add(28).cast::<usize>() = len9;
                                    *base.add(24).cast::<*mut u8>() = ptr9.cast_mut();
                                    let Request {
                                        inherit: inherit10,
                                        expects_response: expects_response10,
                                        body: body10,
                                        metadata: metadata10,
                                        capabilities: capabilities10,
                                    } = t3_1;
                                    *base.add(32).cast::<u8>() = (match inherit10 {
                                        true => 1,
                                        false => 0,
                                    }) as u8;
                                    match expects_response10 {
                                        Some(e) => {
                                            *base.add(40).cast::<u8>() = (1i32) as u8;
                                            *base.add(48).cast::<i64>() = _rt::as_i64(e);
                                        }
                                        None => {
                                            *base.add(40).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    let vec11 = body10;
                                    let ptr11 = vec11.as_ptr().cast::<u8>();
                                    let len11 = vec11.len();
                                    *base.add(60).cast::<usize>() = len11;
                                    *base.add(56).cast::<*mut u8>() = ptr11.cast_mut();
                                    match metadata10 {
                                        Some(e) => {
                                            *base.add(64).cast::<u8>() = (1i32) as u8;
                                            let vec12 = e;
                                            let ptr12 = vec12.as_ptr().cast::<u8>();
                                            let len12 = vec12.len();
                                            *base.add(72).cast::<usize>() = len12;
                                            *base.add(68).cast::<*mut u8>() = ptr12.cast_mut();
                                        }
                                        None => {
                                            *base.add(64).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    let vec21 = capabilities10;
                                    let len21 = vec21.len();
                                    let layout21 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec21.len() * 40,
                                        4,
                                    );
                                    let result21 = if layout21.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout21).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout21);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec21.into_iter().enumerate() {
                                        let base = result21.add(i * 40);
                                        {
                                            let Capability { issuer: issuer13, params: params13 } = e;
                                            let Address { node: node14, process: process14 } = issuer13;
                                            let vec15 = node14;
                                            let ptr15 = vec15.as_ptr().cast::<u8>();
                                            let len15 = vec15.len();
                                            *base.add(4).cast::<usize>() = len15;
                                            *base.add(0).cast::<*mut u8>() = ptr15.cast_mut();
                                            let ProcessId {
                                                process_name: process_name16,
                                                package_name: package_name16,
                                                publisher_node: publisher_node16,
                                            } = process14;
                                            let vec17 = process_name16;
                                            let ptr17 = vec17.as_ptr().cast::<u8>();
                                            let len17 = vec17.len();
                                            *base.add(12).cast::<usize>() = len17;
                                            *base.add(8).cast::<*mut u8>() = ptr17.cast_mut();
                                            let vec18 = package_name16;
                                            let ptr18 = vec18.as_ptr().cast::<u8>();
                                            let len18 = vec18.len();
                                            *base.add(20).cast::<usize>() = len18;
                                            *base.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                            let vec19 = publisher_node16;
                                            let ptr19 = vec19.as_ptr().cast::<u8>();
                                            let len19 = vec19.len();
                                            *base.add(28).cast::<usize>() = len19;
                                            *base.add(24).cast::<*mut u8>() = ptr19.cast_mut();
                                            let vec20 = params13;
                                            let ptr20 = vec20.as_ptr().cast::<u8>();
                                            let len20 = vec20.len();
                                            *base.add(36).cast::<usize>() = len20;
                                            *base.add(32).cast::<*mut u8>() = ptr20.cast_mut();
                                        }
                                    }
                                    *base.add(80).cast::<usize>() = len21;
                                    *base.add(76).cast::<*mut u8>() = result21;
                                    match t3_2 {
                                        Some(e) => {
                                            *base.add(88).cast::<u8>() = (1i32) as u8;
                                            let LazyLoadBlob { mime: mime22, bytes: bytes22 } = e;
                                            match mime22 {
                                                Some(e) => {
                                                    *base.add(92).cast::<u8>() = (1i32) as u8;
                                                    let vec23 = e;
                                                    let ptr23 = vec23.as_ptr().cast::<u8>();
                                                    let len23 = vec23.len();
                                                    *base.add(100).cast::<usize>() = len23;
                                                    *base.add(96).cast::<*mut u8>() = ptr23.cast_mut();
                                                }
                                                None => {
                                                    *base.add(92).cast::<u8>() = (0i32) as u8;
                                                }
                                            };
                                            let vec24 = bytes22;
                                            let ptr24 = vec24.as_ptr().cast::<u8>();
                                            let len24 = vec24.len();
                                            *base.add(108).cast::<usize>() = len24;
                                            *base.add(104).cast::<*mut u8>() = ptr24.cast_mut();
                                        }
                                        None => {
                                            *base.add(88).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    cleanup_list.extend_from_slice(&[(result21, layout21)]);
                                }
                            }
                            cleanup_list.extend_from_slice(&[(result25, layout25)]);
                            (2i32, result25, len25)
                        }
                    };
                    let vec35 = request_capabilities;
                    let len35 = vec35.len();
                    let layout35 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec35.len() * 40,
                        4,
                    );
                    let result35 = if layout35.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout35).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout35);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec35.into_iter().enumerate() {
                        let base = result35.add(i * 40);
                        {
                            let Capability { issuer: issuer27, params: params27 } = e;
                            let Address { node: node28, process: process28 } = issuer27;
                            let vec29 = node28;
                            let ptr29 = vec29.as_ptr().cast::<u8>();
                            let len29 = vec29.len();
                            *base.add(4).cast::<usize>() = len29;
                            *base.add(0).cast::<*mut u8>() = ptr29.cast_mut();
                            let ProcessId {
                                process_name: process_name30,
                                package_name: package_name30,
                                publisher_node: publisher_node30,
                            } = process28;
                            let vec31 = process_name30;
                            let ptr31 = vec31.as_ptr().cast::<u8>();
                            let len31 = vec31.len();
                            *base.add(12).cast::<usize>() = len31;
                            *base.add(8).cast::<*mut u8>() = ptr31.cast_mut();
                            let vec32 = package_name30;
                            let ptr32 = vec32.as_ptr().cast::<u8>();
                            let len32 = vec32.len();
                            *base.add(20).cast::<usize>() = len32;
                            *base.add(16).cast::<*mut u8>() = ptr32.cast_mut();
                            let vec33 = publisher_node30;
                            let ptr33 = vec33.as_ptr().cast::<u8>();
                            let len33 = vec33.len();
                            *base.add(28).cast::<usize>() = len33;
                            *base.add(24).cast::<*mut u8>() = ptr33.cast_mut();
                            let vec34 = params27;
                            let ptr34 = vec34.as_ptr().cast::<u8>();
                            let len34 = vec34.len();
                            *base.add(36).cast::<usize>() = len34;
                            *base.add(32).cast::<*mut u8>() = ptr34.cast_mut();
                        }
                    }
                    let vec42 = grant_capabilities;
                    let len42 = vec42.len();
                    let layout42 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec42.len() * 32,
                        4,
                    );
                    let result42 = if layout42.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout42).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout42);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec42.into_iter().enumerate() {
                        let base = result42.add(i * 32);
                        {
                            let (t36_0, t36_1) = e;
                            let ProcessId {
                                process_name: process_name37,
                                package_name: package_name37,
                                publisher_node: publisher_node37,
                            } = t36_0;
                            let vec38 = process_name37;
                            let ptr38 = vec38.as_ptr().cast::<u8>();
                            let len38 = vec38.len();
                            *base.add(4).cast::<usize>() = len38;
                            *base.add(0).cast::<*mut u8>() = ptr38.cast_mut();
                            let vec39 = package_name37;
                            let ptr39 = vec39.as_ptr().cast::<u8>();
                            let len39 = vec39.len();
                            *base.add(12).cast::<usize>() = len39;
                            *base.add(8).cast::<*mut u8>() = ptr39.cast_mut();
                            let vec40 = publisher_node37;
                            let ptr40 = vec40.as_ptr().cast::<u8>();
                            let len40 = vec40.len();
                            *base.add(20).cast::<usize>() = len40;
                            *base.add(16).cast::<*mut u8>() = ptr40.cast_mut();
                            let vec41 = t36_1;
                            let ptr41 = vec41.as_ptr().cast::<u8>();
                            let len41 = vec41.len();
                            *base.add(28).cast::<usize>() = len41;
                            *base.add(24).cast::<*mut u8>() = ptr41.cast_mut();
                        }
                    }
                    let ptr43 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(
                        _: i32,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: i32,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: i32,
                        _: *mut u8,
                    ) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(
                        result1_0,
                        result1_1,
                        result1_2,
                        ptr2.cast_mut(),
                        len2,
                        result26_0,
                        result26_1,
                        result26_2,
                        result35,
                        len35,
                        result42,
                        len42,
                        match &public {
                            true => 1,
                            false => 0,
                        },
                        ptr43,
                    );
                    let l44 = i32::from(*ptr43.add(0).cast::<u8>());
                    if layout35.size() != 0 {
                        _rt::alloc::dealloc(result35.cast(), layout35);
                    }
                    if layout42.size() != 0 {
                        _rt::alloc::dealloc(result42.cast(), layout42);
                    }
                    for (ptr, layout) in cleanup_list {
                        if layout.size() != 0 {
                            _rt::alloc::dealloc(ptr.cast(), layout);
                        }
                    }
                    match l44 {
                        0 => {
                            let e = {
                                let l45 = *ptr43.add(4).cast::<*mut u8>();
                                let l46 = *ptr43.add(8).cast::<usize>();
                                let len47 = l46;
                                let bytes47 = _rt::Vec::from_raw_parts(
                                    l45.cast(),
                                    len47,
                                    len47,
                                );
                                let l48 = *ptr43.add(12).cast::<*mut u8>();
                                let l49 = *ptr43.add(16).cast::<usize>();
                                let len50 = l49;
                                let bytes50 = _rt::Vec::from_raw_parts(
                                    l48.cast(),
                                    len50,
                                    len50,
                                );
                                let l51 = *ptr43.add(20).cast::<*mut u8>();
                                let l52 = *ptr43.add(24).cast::<usize>();
                                let len53 = l52;
                                let bytes53 = _rt::Vec::from_raw_parts(
                                    l51.cast(),
                                    len53,
                                    len53,
                                );
                                ProcessId {
                                    process_name: _rt::string_lift(bytes47),
                                    package_name: _rt::string_lift(bytes50),
                                    publisher_node: _rt::string_lift(bytes53),
                                }
                            };
                            Ok(e)
                        }
                        1 => {
                            let e = {
                                let l54 = i32::from(*ptr43.add(4).cast::<u8>());
                                SpawnError::_lift(l54 as u8)
                            };
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            ///   
            /// Capabilities Management
            ///   
            /// Saves the capabilities to persisted process state.
            pub fn save_capabilities(caps: &[Capability]) {
                unsafe {
                    let vec8 = caps;
                    let len8 = vec8.len();
                    let layout8 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec8.len() * 40,
                        4,
                    );
                    let result8 = if layout8.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout8).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout8);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec8.into_iter().enumerate() {
                        let base = result8.add(i * 40);
                        {
                            let Capability { issuer: issuer0, params: params0 } = e;
                            let Address { node: node1, process: process1 } = issuer0;
                            let vec2 = node1;
                            let ptr2 = vec2.as_ptr().cast::<u8>();
                            let len2 = vec2.len();
                            *base.add(4).cast::<usize>() = len2;
                            *base.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                            let ProcessId {
                                process_name: process_name3,
                                package_name: package_name3,
                                publisher_node: publisher_node3,
                            } = process1;
                            let vec4 = process_name3;
                            let ptr4 = vec4.as_ptr().cast::<u8>();
                            let len4 = vec4.len();
                            *base.add(12).cast::<usize>() = len4;
                            *base.add(8).cast::<*mut u8>() = ptr4.cast_mut();
                            let vec5 = package_name3;
                            let ptr5 = vec5.as_ptr().cast::<u8>();
                            let len5 = vec5.len();
                            *base.add(20).cast::<usize>() = len5;
                            *base.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                            let vec6 = publisher_node3;
                            let ptr6 = vec6.as_ptr().cast::<u8>();
                            let len6 = vec6.len();
                            *base.add(28).cast::<usize>() = len6;
                            *base.add(24).cast::<*mut u8>() = ptr6.cast_mut();
                            let vec7 = params0;
                            let ptr7 = vec7.as_ptr().cast::<u8>();
                            let len7 = vec7.len();
                            *base.add(36).cast::<usize>() = len7;
                            *base.add(32).cast::<*mut u8>() = ptr7.cast_mut();
                        }
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(result8, len8);
                    if layout8.size() != 0 {
                        _rt::alloc::dealloc(result8.cast(), layout8);
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Deletes the capabilities from persisted process state.
            pub fn drop_capabilities(caps: &[Capability]) {
                unsafe {
                    let vec8 = caps;
                    let len8 = vec8.len();
                    let layout8 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec8.len() * 40,
                        4,
                    );
                    let result8 = if layout8.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout8).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout8);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec8.into_iter().enumerate() {
                        let base = result8.add(i * 40);
                        {
                            let Capability { issuer: issuer0, params: params0 } = e;
                            let Address { node: node1, process: process1 } = issuer0;
                            let vec2 = node1;
                            let ptr2 = vec2.as_ptr().cast::<u8>();
                            let len2 = vec2.len();
                            *base.add(4).cast::<usize>() = len2;
                            *base.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                            let ProcessId {
                                process_name: process_name3,
                                package_name: package_name3,
                                publisher_node: publisher_node3,
                            } = process1;
                            let vec4 = process_name3;
                            let ptr4 = vec4.as_ptr().cast::<u8>();
                            let len4 = vec4.len();
                            *base.add(12).cast::<usize>() = len4;
                            *base.add(8).cast::<*mut u8>() = ptr4.cast_mut();
                            let vec5 = package_name3;
                            let ptr5 = vec5.as_ptr().cast::<u8>();
                            let len5 = vec5.len();
                            *base.add(20).cast::<usize>() = len5;
                            *base.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                            let vec6 = publisher_node3;
                            let ptr6 = vec6.as_ptr().cast::<u8>();
                            let len6 = vec6.len();
                            *base.add(28).cast::<usize>() = len6;
                            *base.add(24).cast::<*mut u8>() = ptr6.cast_mut();
                            let vec7 = params0;
                            let ptr7 = vec7.as_ptr().cast::<u8>();
                            let len7 = vec7.len();
                            *base.add(36).cast::<usize>() = len7;
                            *base.add(32).cast::<*mut u8>() = ptr7.cast_mut();
                        }
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(result8, len8);
                    if layout8.size() != 0 {
                        _rt::alloc::dealloc(result8.cast(), layout8);
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Gets all capabilities from persisted process state.
            pub fn our_capabilities() -> _rt::Vec<Capability> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(ptr0);
                    let l1 = *ptr0.add(0).cast::<*mut u8>();
                    let l2 = *ptr0.add(4).cast::<usize>();
                    let base18 = l1;
                    let len18 = l2;
                    let mut result18 = _rt::Vec::with_capacity(len18);
                    for i in 0..len18 {
                        let base = base18.add(i * 40);
                        let e18 = {
                            let l3 = *base.add(0).cast::<*mut u8>();
                            let l4 = *base.add(4).cast::<usize>();
                            let len5 = l4;
                            let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);
                            let l6 = *base.add(8).cast::<*mut u8>();
                            let l7 = *base.add(12).cast::<usize>();
                            let len8 = l7;
                            let bytes8 = _rt::Vec::from_raw_parts(l6.cast(), len8, len8);
                            let l9 = *base.add(16).cast::<*mut u8>();
                            let l10 = *base.add(20).cast::<usize>();
                            let len11 = l10;
                            let bytes11 = _rt::Vec::from_raw_parts(
                                l9.cast(),
                                len11,
                                len11,
                            );
                            let l12 = *base.add(24).cast::<*mut u8>();
                            let l13 = *base.add(28).cast::<usize>();
                            let len14 = l13;
                            let bytes14 = _rt::Vec::from_raw_parts(
                                l12.cast(),
                                len14,
                                len14,
                            );
                            let l15 = *base.add(32).cast::<*mut u8>();
                            let l16 = *base.add(36).cast::<usize>();
                            let len17 = l16;
                            let bytes17 = _rt::Vec::from_raw_parts(
                                l15.cast(),
                                len17,
                                len17,
                            );
                            Capability {
                                issuer: Address {
                                    node: _rt::string_lift(bytes5),
                                    process: ProcessId {
                                        process_name: _rt::string_lift(bytes8),
                                        package_name: _rt::string_lift(bytes11),
                                        publisher_node: _rt::string_lift(bytes14),
                                    },
                                },
                                params: _rt::string_lift(bytes17),
                            }
                        };
                        result18.push(e18);
                    }
                    _rt::cabi_dealloc(base18, len18 * 40, 4);
                    result18
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            ///   
            /// Message I/O
            ///   
            /// Ingest next message when it arrives along with its source.
            /// Almost all long-running processes will call this in a loop.
            pub fn receive() -> Result<
                (Address, Message),
                (SendError, Option<Context>),
            > {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 152]);
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 152],
                    );
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(ptr0);
                    let l1 = i32::from(*ptr0.add(0).cast::<u8>());
                    match l1 {
                        0 => {
                            let e = {
                                let l2 = *ptr0.add(8).cast::<*mut u8>();
                                let l3 = *ptr0.add(12).cast::<usize>();
                                let len4 = l3;
                                let bytes4 = _rt::Vec::from_raw_parts(
                                    l2.cast(),
                                    len4,
                                    len4,
                                );
                                let l5 = *ptr0.add(16).cast::<*mut u8>();
                                let l6 = *ptr0.add(20).cast::<usize>();
                                let len7 = l6;
                                let bytes7 = _rt::Vec::from_raw_parts(
                                    l5.cast(),
                                    len7,
                                    len7,
                                );
                                let l8 = *ptr0.add(24).cast::<*mut u8>();
                                let l9 = *ptr0.add(28).cast::<usize>();
                                let len10 = l9;
                                let bytes10 = _rt::Vec::from_raw_parts(
                                    l8.cast(),
                                    len10,
                                    len10,
                                );
                                let l11 = *ptr0.add(32).cast::<*mut u8>();
                                let l12 = *ptr0.add(36).cast::<usize>();
                                let len13 = l12;
                                let bytes13 = _rt::Vec::from_raw_parts(
                                    l11.cast(),
                                    len13,
                                    len13,
                                );
                                let l14 = i32::from(*ptr0.add(40).cast::<u8>());
                                let v73 = match l14 {
                                    0 => {
                                        let e73 = {
                                            let l15 = i32::from(*ptr0.add(48).cast::<u8>());
                                            let l16 = i32::from(*ptr0.add(56).cast::<u8>());
                                            let l18 = *ptr0.add(72).cast::<*mut u8>();
                                            let l19 = *ptr0.add(76).cast::<usize>();
                                            let len20 = l19;
                                            let l21 = i32::from(*ptr0.add(80).cast::<u8>());
                                            let l25 = *ptr0.add(92).cast::<*mut u8>();
                                            let l26 = *ptr0.add(96).cast::<usize>();
                                            let base42 = l25;
                                            let len42 = l26;
                                            let mut result42 = _rt::Vec::with_capacity(len42);
                                            for i in 0..len42 {
                                                let base = base42.add(i * 40);
                                                let e42 = {
                                                    let l27 = *base.add(0).cast::<*mut u8>();
                                                    let l28 = *base.add(4).cast::<usize>();
                                                    let len29 = l28;
                                                    let bytes29 = _rt::Vec::from_raw_parts(
                                                        l27.cast(),
                                                        len29,
                                                        len29,
                                                    );
                                                    let l30 = *base.add(8).cast::<*mut u8>();
                                                    let l31 = *base.add(12).cast::<usize>();
                                                    let len32 = l31;
                                                    let bytes32 = _rt::Vec::from_raw_parts(
                                                        l30.cast(),
                                                        len32,
                                                        len32,
                                                    );
                                                    let l33 = *base.add(16).cast::<*mut u8>();
                                                    let l34 = *base.add(20).cast::<usize>();
                                                    let len35 = l34;
                                                    let bytes35 = _rt::Vec::from_raw_parts(
                                                        l33.cast(),
                                                        len35,
                                                        len35,
                                                    );
                                                    let l36 = *base.add(24).cast::<*mut u8>();
                                                    let l37 = *base.add(28).cast::<usize>();
                                                    let len38 = l37;
                                                    let bytes38 = _rt::Vec::from_raw_parts(
                                                        l36.cast(),
                                                        len38,
                                                        len38,
                                                    );
                                                    let l39 = *base.add(32).cast::<*mut u8>();
                                                    let l40 = *base.add(36).cast::<usize>();
                                                    let len41 = l40;
                                                    let bytes41 = _rt::Vec::from_raw_parts(
                                                        l39.cast(),
                                                        len41,
                                                        len41,
                                                    );
                                                    Capability {
                                                        issuer: Address {
                                                            node: _rt::string_lift(bytes29),
                                                            process: ProcessId {
                                                                process_name: _rt::string_lift(bytes32),
                                                                package_name: _rt::string_lift(bytes35),
                                                                publisher_node: _rt::string_lift(bytes38),
                                                            },
                                                        },
                                                        params: _rt::string_lift(bytes41),
                                                    }
                                                };
                                                result42.push(e42);
                                            }
                                            _rt::cabi_dealloc(base42, len42 * 40, 4);
                                            Request {
                                                inherit: _rt::bool_lift(l15 as u8),
                                                expects_response: match l16 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l17 = *ptr0.add(64).cast::<i64>();
                                                            l17 as u64
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                                body: _rt::Vec::from_raw_parts(l18.cast(), len20, len20),
                                                metadata: match l21 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l22 = *ptr0.add(84).cast::<*mut u8>();
                                                            let l23 = *ptr0.add(88).cast::<usize>();
                                                            let len24 = l23;
                                                            let bytes24 = _rt::Vec::from_raw_parts(
                                                                l22.cast(),
                                                                len24,
                                                                len24,
                                                            );
                                                            _rt::string_lift(bytes24)
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                                capabilities: result42,
                                            }
                                        };
                                        Message::Request(e73)
                                    }
                                    n => {
                                        if true {
                                            match (&n, &1) {
                                                (left_val, right_val) => {
                                                    if !(*left_val == *right_val) {
                                                        let kind = ::core::panicking::AssertKind::Eq;
                                                        ::core::panicking::assert_failed(
                                                            kind,
                                                            &*left_val,
                                                            &*right_val,
                                                            ::core::option::Option::Some(
                                                                format_args!("invalid enum discriminant"),
                                                            ),
                                                        );
                                                    }
                                                }
                                            };
                                        }
                                        let e73 = {
                                            let l43 = i32::from(*ptr0.add(48).cast::<u8>());
                                            let l44 = *ptr0.add(52).cast::<*mut u8>();
                                            let l45 = *ptr0.add(56).cast::<usize>();
                                            let len46 = l45;
                                            let l47 = i32::from(*ptr0.add(60).cast::<u8>());
                                            let l51 = *ptr0.add(72).cast::<*mut u8>();
                                            let l52 = *ptr0.add(76).cast::<usize>();
                                            let base68 = l51;
                                            let len68 = l52;
                                            let mut result68 = _rt::Vec::with_capacity(len68);
                                            for i in 0..len68 {
                                                let base = base68.add(i * 40);
                                                let e68 = {
                                                    let l53 = *base.add(0).cast::<*mut u8>();
                                                    let l54 = *base.add(4).cast::<usize>();
                                                    let len55 = l54;
                                                    let bytes55 = _rt::Vec::from_raw_parts(
                                                        l53.cast(),
                                                        len55,
                                                        len55,
                                                    );
                                                    let l56 = *base.add(8).cast::<*mut u8>();
                                                    let l57 = *base.add(12).cast::<usize>();
                                                    let len58 = l57;
                                                    let bytes58 = _rt::Vec::from_raw_parts(
                                                        l56.cast(),
                                                        len58,
                                                        len58,
                                                    );
                                                    let l59 = *base.add(16).cast::<*mut u8>();
                                                    let l60 = *base.add(20).cast::<usize>();
                                                    let len61 = l60;
                                                    let bytes61 = _rt::Vec::from_raw_parts(
                                                        l59.cast(),
                                                        len61,
                                                        len61,
                                                    );
                                                    let l62 = *base.add(24).cast::<*mut u8>();
                                                    let l63 = *base.add(28).cast::<usize>();
                                                    let len64 = l63;
                                                    let bytes64 = _rt::Vec::from_raw_parts(
                                                        l62.cast(),
                                                        len64,
                                                        len64,
                                                    );
                                                    let l65 = *base.add(32).cast::<*mut u8>();
                                                    let l66 = *base.add(36).cast::<usize>();
                                                    let len67 = l66;
                                                    let bytes67 = _rt::Vec::from_raw_parts(
                                                        l65.cast(),
                                                        len67,
                                                        len67,
                                                    );
                                                    Capability {
                                                        issuer: Address {
                                                            node: _rt::string_lift(bytes55),
                                                            process: ProcessId {
                                                                process_name: _rt::string_lift(bytes58),
                                                                package_name: _rt::string_lift(bytes61),
                                                                publisher_node: _rt::string_lift(bytes64),
                                                            },
                                                        },
                                                        params: _rt::string_lift(bytes67),
                                                    }
                                                };
                                                result68.push(e68);
                                            }
                                            _rt::cabi_dealloc(base68, len68 * 40, 4);
                                            let l69 = i32::from(*ptr0.add(80).cast::<u8>());
                                            (
                                                Response {
                                                    inherit: _rt::bool_lift(l43 as u8),
                                                    body: _rt::Vec::from_raw_parts(l44.cast(), len46, len46),
                                                    metadata: match l47 {
                                                        0 => None,
                                                        1 => {
                                                            let e = {
                                                                let l48 = *ptr0.add(64).cast::<*mut u8>();
                                                                let l49 = *ptr0.add(68).cast::<usize>();
                                                                let len50 = l49;
                                                                let bytes50 = _rt::Vec::from_raw_parts(
                                                                    l48.cast(),
                                                                    len50,
                                                                    len50,
                                                                );
                                                                _rt::string_lift(bytes50)
                                                            };
                                                            Some(e)
                                                        }
                                                        _ => _rt::invalid_enum_discriminant(),
                                                    },
                                                    capabilities: result68,
                                                },
                                                match l69 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l70 = *ptr0.add(84).cast::<*mut u8>();
                                                            let l71 = *ptr0.add(88).cast::<usize>();
                                                            let len72 = l71;
                                                            _rt::Vec::from_raw_parts(l70.cast(), len72, len72)
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                            )
                                        };
                                        Message::Response(e73)
                                    }
                                };
                                (
                                    Address {
                                        node: _rt::string_lift(bytes4),
                                        process: ProcessId {
                                            process_name: _rt::string_lift(bytes7),
                                            package_name: _rt::string_lift(bytes10),
                                            publisher_node: _rt::string_lift(bytes13),
                                        },
                                    },
                                    v73,
                                )
                            };
                            Ok(e)
                        }
                        1 => {
                            let e = {
                                let l74 = i32::from(*ptr0.add(8).cast::<u8>());
                                let l75 = *ptr0.add(12).cast::<*mut u8>();
                                let l76 = *ptr0.add(16).cast::<usize>();
                                let len77 = l76;
                                let bytes77 = _rt::Vec::from_raw_parts(
                                    l75.cast(),
                                    len77,
                                    len77,
                                );
                                let l78 = *ptr0.add(20).cast::<*mut u8>();
                                let l79 = *ptr0.add(24).cast::<usize>();
                                let len80 = l79;
                                let bytes80 = _rt::Vec::from_raw_parts(
                                    l78.cast(),
                                    len80,
                                    len80,
                                );
                                let l81 = *ptr0.add(28).cast::<*mut u8>();
                                let l82 = *ptr0.add(32).cast::<usize>();
                                let len83 = l82;
                                let bytes83 = _rt::Vec::from_raw_parts(
                                    l81.cast(),
                                    len83,
                                    len83,
                                );
                                let l84 = *ptr0.add(36).cast::<*mut u8>();
                                let l85 = *ptr0.add(40).cast::<usize>();
                                let len86 = l85;
                                let bytes86 = _rt::Vec::from_raw_parts(
                                    l84.cast(),
                                    len86,
                                    len86,
                                );
                                let l87 = i32::from(*ptr0.add(48).cast::<u8>());
                                let v146 = match l87 {
                                    0 => {
                                        let e146 = {
                                            let l88 = i32::from(*ptr0.add(56).cast::<u8>());
                                            let l89 = i32::from(*ptr0.add(64).cast::<u8>());
                                            let l91 = *ptr0.add(80).cast::<*mut u8>();
                                            let l92 = *ptr0.add(84).cast::<usize>();
                                            let len93 = l92;
                                            let l94 = i32::from(*ptr0.add(88).cast::<u8>());
                                            let l98 = *ptr0.add(100).cast::<*mut u8>();
                                            let l99 = *ptr0.add(104).cast::<usize>();
                                            let base115 = l98;
                                            let len115 = l99;
                                            let mut result115 = _rt::Vec::with_capacity(len115);
                                            for i in 0..len115 {
                                                let base = base115.add(i * 40);
                                                let e115 = {
                                                    let l100 = *base.add(0).cast::<*mut u8>();
                                                    let l101 = *base.add(4).cast::<usize>();
                                                    let len102 = l101;
                                                    let bytes102 = _rt::Vec::from_raw_parts(
                                                        l100.cast(),
                                                        len102,
                                                        len102,
                                                    );
                                                    let l103 = *base.add(8).cast::<*mut u8>();
                                                    let l104 = *base.add(12).cast::<usize>();
                                                    let len105 = l104;
                                                    let bytes105 = _rt::Vec::from_raw_parts(
                                                        l103.cast(),
                                                        len105,
                                                        len105,
                                                    );
                                                    let l106 = *base.add(16).cast::<*mut u8>();
                                                    let l107 = *base.add(20).cast::<usize>();
                                                    let len108 = l107;
                                                    let bytes108 = _rt::Vec::from_raw_parts(
                                                        l106.cast(),
                                                        len108,
                                                        len108,
                                                    );
                                                    let l109 = *base.add(24).cast::<*mut u8>();
                                                    let l110 = *base.add(28).cast::<usize>();
                                                    let len111 = l110;
                                                    let bytes111 = _rt::Vec::from_raw_parts(
                                                        l109.cast(),
                                                        len111,
                                                        len111,
                                                    );
                                                    let l112 = *base.add(32).cast::<*mut u8>();
                                                    let l113 = *base.add(36).cast::<usize>();
                                                    let len114 = l113;
                                                    let bytes114 = _rt::Vec::from_raw_parts(
                                                        l112.cast(),
                                                        len114,
                                                        len114,
                                                    );
                                                    Capability {
                                                        issuer: Address {
                                                            node: _rt::string_lift(bytes102),
                                                            process: ProcessId {
                                                                process_name: _rt::string_lift(bytes105),
                                                                package_name: _rt::string_lift(bytes108),
                                                                publisher_node: _rt::string_lift(bytes111),
                                                            },
                                                        },
                                                        params: _rt::string_lift(bytes114),
                                                    }
                                                };
                                                result115.push(e115);
                                            }
                                            _rt::cabi_dealloc(base115, len115 * 40, 4);
                                            Request {
                                                inherit: _rt::bool_lift(l88 as u8),
                                                expects_response: match l89 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l90 = *ptr0.add(72).cast::<i64>();
                                                            l90 as u64
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                                body: _rt::Vec::from_raw_parts(l91.cast(), len93, len93),
                                                metadata: match l94 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l95 = *ptr0.add(92).cast::<*mut u8>();
                                                            let l96 = *ptr0.add(96).cast::<usize>();
                                                            let len97 = l96;
                                                            let bytes97 = _rt::Vec::from_raw_parts(
                                                                l95.cast(),
                                                                len97,
                                                                len97,
                                                            );
                                                            _rt::string_lift(bytes97)
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                                capabilities: result115,
                                            }
                                        };
                                        Message::Request(e146)
                                    }
                                    n => {
                                        if true {
                                            match (&n, &1) {
                                                (left_val, right_val) => {
                                                    if !(*left_val == *right_val) {
                                                        let kind = ::core::panicking::AssertKind::Eq;
                                                        ::core::panicking::assert_failed(
                                                            kind,
                                                            &*left_val,
                                                            &*right_val,
                                                            ::core::option::Option::Some(
                                                                format_args!("invalid enum discriminant"),
                                                            ),
                                                        );
                                                    }
                                                }
                                            };
                                        }
                                        let e146 = {
                                            let l116 = i32::from(*ptr0.add(56).cast::<u8>());
                                            let l117 = *ptr0.add(60).cast::<*mut u8>();
                                            let l118 = *ptr0.add(64).cast::<usize>();
                                            let len119 = l118;
                                            let l120 = i32::from(*ptr0.add(68).cast::<u8>());
                                            let l124 = *ptr0.add(80).cast::<*mut u8>();
                                            let l125 = *ptr0.add(84).cast::<usize>();
                                            let base141 = l124;
                                            let len141 = l125;
                                            let mut result141 = _rt::Vec::with_capacity(len141);
                                            for i in 0..len141 {
                                                let base = base141.add(i * 40);
                                                let e141 = {
                                                    let l126 = *base.add(0).cast::<*mut u8>();
                                                    let l127 = *base.add(4).cast::<usize>();
                                                    let len128 = l127;
                                                    let bytes128 = _rt::Vec::from_raw_parts(
                                                        l126.cast(),
                                                        len128,
                                                        len128,
                                                    );
                                                    let l129 = *base.add(8).cast::<*mut u8>();
                                                    let l130 = *base.add(12).cast::<usize>();
                                                    let len131 = l130;
                                                    let bytes131 = _rt::Vec::from_raw_parts(
                                                        l129.cast(),
                                                        len131,
                                                        len131,
                                                    );
                                                    let l132 = *base.add(16).cast::<*mut u8>();
                                                    let l133 = *base.add(20).cast::<usize>();
                                                    let len134 = l133;
                                                    let bytes134 = _rt::Vec::from_raw_parts(
                                                        l132.cast(),
                                                        len134,
                                                        len134,
                                                    );
                                                    let l135 = *base.add(24).cast::<*mut u8>();
                                                    let l136 = *base.add(28).cast::<usize>();
                                                    let len137 = l136;
                                                    let bytes137 = _rt::Vec::from_raw_parts(
                                                        l135.cast(),
                                                        len137,
                                                        len137,
                                                    );
                                                    let l138 = *base.add(32).cast::<*mut u8>();
                                                    let l139 = *base.add(36).cast::<usize>();
                                                    let len140 = l139;
                                                    let bytes140 = _rt::Vec::from_raw_parts(
                                                        l138.cast(),
                                                        len140,
                                                        len140,
                                                    );
                                                    Capability {
                                                        issuer: Address {
                                                            node: _rt::string_lift(bytes128),
                                                            process: ProcessId {
                                                                process_name: _rt::string_lift(bytes131),
                                                                package_name: _rt::string_lift(bytes134),
                                                                publisher_node: _rt::string_lift(bytes137),
                                                            },
                                                        },
                                                        params: _rt::string_lift(bytes140),
                                                    }
                                                };
                                                result141.push(e141);
                                            }
                                            _rt::cabi_dealloc(base141, len141 * 40, 4);
                                            let l142 = i32::from(*ptr0.add(88).cast::<u8>());
                                            (
                                                Response {
                                                    inherit: _rt::bool_lift(l116 as u8),
                                                    body: _rt::Vec::from_raw_parts(l117.cast(), len119, len119),
                                                    metadata: match l120 {
                                                        0 => None,
                                                        1 => {
                                                            let e = {
                                                                let l121 = *ptr0.add(72).cast::<*mut u8>();
                                                                let l122 = *ptr0.add(76).cast::<usize>();
                                                                let len123 = l122;
                                                                let bytes123 = _rt::Vec::from_raw_parts(
                                                                    l121.cast(),
                                                                    len123,
                                                                    len123,
                                                                );
                                                                _rt::string_lift(bytes123)
                                                            };
                                                            Some(e)
                                                        }
                                                        _ => _rt::invalid_enum_discriminant(),
                                                    },
                                                    capabilities: result141,
                                                },
                                                match l142 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l143 = *ptr0.add(92).cast::<*mut u8>();
                                                            let l144 = *ptr0.add(96).cast::<usize>();
                                                            let len145 = l144;
                                                            _rt::Vec::from_raw_parts(l143.cast(), len145, len145)
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                            )
                                        };
                                        Message::Response(e146)
                                    }
                                };
                                let l147 = i32::from(*ptr0.add(112).cast::<u8>());
                                let l155 = i32::from(*ptr0.add(136).cast::<u8>());
                                (
                                    SendError {
                                        kind: SendErrorKind::_lift(l74 as u8),
                                        target: Address {
                                            node: _rt::string_lift(bytes77),
                                            process: ProcessId {
                                                process_name: _rt::string_lift(bytes80),
                                                package_name: _rt::string_lift(bytes83),
                                                publisher_node: _rt::string_lift(bytes86),
                                            },
                                        },
                                        message: v146,
                                        lazy_load_blob: match l147 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l148 = i32::from(*ptr0.add(116).cast::<u8>());
                                                    let l152 = *ptr0.add(128).cast::<*mut u8>();
                                                    let l153 = *ptr0.add(132).cast::<usize>();
                                                    let len154 = l153;
                                                    LazyLoadBlob {
                                                        mime: match l148 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l149 = *ptr0.add(120).cast::<*mut u8>();
                                                                    let l150 = *ptr0.add(124).cast::<usize>();
                                                                    let len151 = l150;
                                                                    let bytes151 = _rt::Vec::from_raw_parts(
                                                                        l149.cast(),
                                                                        len151,
                                                                        len151,
                                                                    );
                                                                    _rt::string_lift(bytes151)
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        bytes: _rt::Vec::from_raw_parts(l152.cast(), len154, len154),
                                                    }
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                    },
                                    match l155 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l156 = *ptr0.add(140).cast::<*mut u8>();
                                                let l157 = *ptr0.add(144).cast::<usize>();
                                                let len158 = l157;
                                                _rt::Vec::from_raw_parts(l156.cast(), len158, len158)
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                )
                            };
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Returns whether or not the current message has a blob.
            pub fn has_blob() -> bool {
                unsafe {
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import() -> i32 {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    let ret = wit_import();
                    _rt::bool_lift(ret as u8)
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Returns the blob of the current message, if any.
            pub fn get_blob() -> Option<LazyLoadBlob> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 24]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 24]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(ptr0);
                    let l1 = i32::from(*ptr0.add(0).cast::<u8>());
                    match l1 {
                        0 => None,
                        1 => {
                            let e = {
                                let l2 = i32::from(*ptr0.add(4).cast::<u8>());
                                let l6 = *ptr0.add(16).cast::<*mut u8>();
                                let l7 = *ptr0.add(20).cast::<usize>();
                                let len8 = l7;
                                LazyLoadBlob {
                                    mime: match l2 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l3 = *ptr0.add(8).cast::<*mut u8>();
                                                let l4 = *ptr0.add(12).cast::<usize>();
                                                let len5 = l4;
                                                let bytes5 = _rt::Vec::from_raw_parts(
                                                    l3.cast(),
                                                    len5,
                                                    len5,
                                                );
                                                _rt::string_lift(bytes5)
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                    bytes: _rt::Vec::from_raw_parts(l6.cast(), len8, len8),
                                }
                            };
                            Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Returns the last blob this process received.
            pub fn last_blob() -> Option<LazyLoadBlob> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 24]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 24]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(ptr0);
                    let l1 = i32::from(*ptr0.add(0).cast::<u8>());
                    match l1 {
                        0 => None,
                        1 => {
                            let e = {
                                let l2 = i32::from(*ptr0.add(4).cast::<u8>());
                                let l6 = *ptr0.add(16).cast::<*mut u8>();
                                let l7 = *ptr0.add(20).cast::<usize>();
                                let len8 = l7;
                                LazyLoadBlob {
                                    mime: match l2 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l3 = *ptr0.add(8).cast::<*mut u8>();
                                                let l4 = *ptr0.add(12).cast::<usize>();
                                                let len5 = l4;
                                                let bytes5 = _rt::Vec::from_raw_parts(
                                                    l3.cast(),
                                                    len5,
                                                    len5,
                                                );
                                                _rt::string_lift(bytes5)
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                    bytes: _rt::Vec::from_raw_parts(l6.cast(), len8, len8),
                                }
                            };
                            Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Send request to target.
            pub fn send_request(
                target: &Address,
                request: &Request,
                context: Option<&Context>,
                lazy_load_blob: Option<&LazyLoadBlob>,
            ) {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 128]);
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 128],
                    );
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    let Address { node: node1, process: process1 } = target;
                    let vec2 = node1;
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    *ptr0.add(4).cast::<usize>() = len2;
                    *ptr0.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                    let ProcessId {
                        process_name: process_name3,
                        package_name: package_name3,
                        publisher_node: publisher_node3,
                    } = process1;
                    let vec4 = process_name3;
                    let ptr4 = vec4.as_ptr().cast::<u8>();
                    let len4 = vec4.len();
                    *ptr0.add(12).cast::<usize>() = len4;
                    *ptr0.add(8).cast::<*mut u8>() = ptr4.cast_mut();
                    let vec5 = package_name3;
                    let ptr5 = vec5.as_ptr().cast::<u8>();
                    let len5 = vec5.len();
                    *ptr0.add(20).cast::<usize>() = len5;
                    *ptr0.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                    let vec6 = publisher_node3;
                    let ptr6 = vec6.as_ptr().cast::<u8>();
                    let len6 = vec6.len();
                    *ptr0.add(28).cast::<usize>() = len6;
                    *ptr0.add(24).cast::<*mut u8>() = ptr6.cast_mut();
                    let Request {
                        inherit: inherit7,
                        expects_response: expects_response7,
                        body: body7,
                        metadata: metadata7,
                        capabilities: capabilities7,
                    } = request;
                    *ptr0.add(32).cast::<u8>() = (match inherit7 {
                        true => 1,
                        false => 0,
                    }) as u8;
                    match expects_response7 {
                        Some(e) => {
                            *ptr0.add(40).cast::<u8>() = (1i32) as u8;
                            *ptr0.add(48).cast::<i64>() = _rt::as_i64(e);
                        }
                        None => {
                            *ptr0.add(40).cast::<u8>() = (0i32) as u8;
                        }
                    };
                    let vec8 = body7;
                    let ptr8 = vec8.as_ptr().cast::<u8>();
                    let len8 = vec8.len();
                    *ptr0.add(60).cast::<usize>() = len8;
                    *ptr0.add(56).cast::<*mut u8>() = ptr8.cast_mut();
                    match metadata7 {
                        Some(e) => {
                            *ptr0.add(64).cast::<u8>() = (1i32) as u8;
                            let vec9 = e;
                            let ptr9 = vec9.as_ptr().cast::<u8>();
                            let len9 = vec9.len();
                            *ptr0.add(72).cast::<usize>() = len9;
                            *ptr0.add(68).cast::<*mut u8>() = ptr9.cast_mut();
                        }
                        None => {
                            *ptr0.add(64).cast::<u8>() = (0i32) as u8;
                        }
                    };
                    let vec18 = capabilities7;
                    let len18 = vec18.len();
                    let layout18 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec18.len() * 40,
                        4,
                    );
                    let result18 = if layout18.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout18).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout18);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec18.into_iter().enumerate() {
                        let base = result18.add(i * 40);
                        {
                            let Capability { issuer: issuer10, params: params10 } = e;
                            let Address { node: node11, process: process11 } = issuer10;
                            let vec12 = node11;
                            let ptr12 = vec12.as_ptr().cast::<u8>();
                            let len12 = vec12.len();
                            *base.add(4).cast::<usize>() = len12;
                            *base.add(0).cast::<*mut u8>() = ptr12.cast_mut();
                            let ProcessId {
                                process_name: process_name13,
                                package_name: package_name13,
                                publisher_node: publisher_node13,
                            } = process11;
                            let vec14 = process_name13;
                            let ptr14 = vec14.as_ptr().cast::<u8>();
                            let len14 = vec14.len();
                            *base.add(12).cast::<usize>() = len14;
                            *base.add(8).cast::<*mut u8>() = ptr14.cast_mut();
                            let vec15 = package_name13;
                            let ptr15 = vec15.as_ptr().cast::<u8>();
                            let len15 = vec15.len();
                            *base.add(20).cast::<usize>() = len15;
                            *base.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                            let vec16 = publisher_node13;
                            let ptr16 = vec16.as_ptr().cast::<u8>();
                            let len16 = vec16.len();
                            *base.add(28).cast::<usize>() = len16;
                            *base.add(24).cast::<*mut u8>() = ptr16.cast_mut();
                            let vec17 = params10;
                            let ptr17 = vec17.as_ptr().cast::<u8>();
                            let len17 = vec17.len();
                            *base.add(36).cast::<usize>() = len17;
                            *base.add(32).cast::<*mut u8>() = ptr17.cast_mut();
                        }
                    }
                    *ptr0.add(80).cast::<usize>() = len18;
                    *ptr0.add(76).cast::<*mut u8>() = result18;
                    match context {
                        Some(e) => {
                            *ptr0.add(88).cast::<u8>() = (1i32) as u8;
                            let vec19 = e;
                            let ptr19 = vec19.as_ptr().cast::<u8>();
                            let len19 = vec19.len();
                            *ptr0.add(96).cast::<usize>() = len19;
                            *ptr0.add(92).cast::<*mut u8>() = ptr19.cast_mut();
                        }
                        None => {
                            *ptr0.add(88).cast::<u8>() = (0i32) as u8;
                        }
                    };
                    match lazy_load_blob {
                        Some(e) => {
                            *ptr0.add(100).cast::<u8>() = (1i32) as u8;
                            let LazyLoadBlob { mime: mime20, bytes: bytes20 } = e;
                            match mime20 {
                                Some(e) => {
                                    *ptr0.add(104).cast::<u8>() = (1i32) as u8;
                                    let vec21 = e;
                                    let ptr21 = vec21.as_ptr().cast::<u8>();
                                    let len21 = vec21.len();
                                    *ptr0.add(112).cast::<usize>() = len21;
                                    *ptr0.add(108).cast::<*mut u8>() = ptr21.cast_mut();
                                }
                                None => {
                                    *ptr0.add(104).cast::<u8>() = (0i32) as u8;
                                }
                            };
                            let vec22 = bytes20;
                            let ptr22 = vec22.as_ptr().cast::<u8>();
                            let len22 = vec22.len();
                            *ptr0.add(120).cast::<usize>() = len22;
                            *ptr0.add(116).cast::<*mut u8>() = ptr22.cast_mut();
                        }
                        None => {
                            *ptr0.add(100).cast::<u8>() = (0i32) as u8;
                        }
                    };
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(ptr0);
                    if layout18.size() != 0 {
                        _rt::alloc::dealloc(result18.cast(), layout18);
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Send requests to targets.
            pub fn send_requests(
                requests: &[(Address, Request, Option<Context>, Option<LazyLoadBlob>)],
            ) {
                unsafe {
                    let mut cleanup_list = _rt::Vec::new();
                    let vec23 = requests;
                    let len23 = vec23.len();
                    let layout23 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec23.len() * 128,
                        8,
                    );
                    let result23 = if layout23.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout23).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout23);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec23.into_iter().enumerate() {
                        let base = result23.add(i * 128);
                        {
                            let (t0_0, t0_1, t0_2, t0_3) = e;
                            let Address { node: node1, process: process1 } = t0_0;
                            let vec2 = node1;
                            let ptr2 = vec2.as_ptr().cast::<u8>();
                            let len2 = vec2.len();
                            *base.add(4).cast::<usize>() = len2;
                            *base.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                            let ProcessId {
                                process_name: process_name3,
                                package_name: package_name3,
                                publisher_node: publisher_node3,
                            } = process1;
                            let vec4 = process_name3;
                            let ptr4 = vec4.as_ptr().cast::<u8>();
                            let len4 = vec4.len();
                            *base.add(12).cast::<usize>() = len4;
                            *base.add(8).cast::<*mut u8>() = ptr4.cast_mut();
                            let vec5 = package_name3;
                            let ptr5 = vec5.as_ptr().cast::<u8>();
                            let len5 = vec5.len();
                            *base.add(20).cast::<usize>() = len5;
                            *base.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                            let vec6 = publisher_node3;
                            let ptr6 = vec6.as_ptr().cast::<u8>();
                            let len6 = vec6.len();
                            *base.add(28).cast::<usize>() = len6;
                            *base.add(24).cast::<*mut u8>() = ptr6.cast_mut();
                            let Request {
                                inherit: inherit7,
                                expects_response: expects_response7,
                                body: body7,
                                metadata: metadata7,
                                capabilities: capabilities7,
                            } = t0_1;
                            *base.add(32).cast::<u8>() = (match inherit7 {
                                true => 1,
                                false => 0,
                            }) as u8;
                            match expects_response7 {
                                Some(e) => {
                                    *base.add(40).cast::<u8>() = (1i32) as u8;
                                    *base.add(48).cast::<i64>() = _rt::as_i64(e);
                                }
                                None => {
                                    *base.add(40).cast::<u8>() = (0i32) as u8;
                                }
                            };
                            let vec8 = body7;
                            let ptr8 = vec8.as_ptr().cast::<u8>();
                            let len8 = vec8.len();
                            *base.add(60).cast::<usize>() = len8;
                            *base.add(56).cast::<*mut u8>() = ptr8.cast_mut();
                            match metadata7 {
                                Some(e) => {
                                    *base.add(64).cast::<u8>() = (1i32) as u8;
                                    let vec9 = e;
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    *base.add(72).cast::<usize>() = len9;
                                    *base.add(68).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                None => {
                                    *base.add(64).cast::<u8>() = (0i32) as u8;
                                }
                            };
                            let vec18 = capabilities7;
                            let len18 = vec18.len();
                            let layout18 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec18.len() * 40,
                                4,
                            );
                            let result18 = if layout18.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout18).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout18);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec18.into_iter().enumerate() {
                                let base = result18.add(i * 40);
                                {
                                    let Capability { issuer: issuer10, params: params10 } = e;
                                    let Address { node: node11, process: process11 } = issuer10;
                                    let vec12 = node11;
                                    let ptr12 = vec12.as_ptr().cast::<u8>();
                                    let len12 = vec12.len();
                                    *base.add(4).cast::<usize>() = len12;
                                    *base.add(0).cast::<*mut u8>() = ptr12.cast_mut();
                                    let ProcessId {
                                        process_name: process_name13,
                                        package_name: package_name13,
                                        publisher_node: publisher_node13,
                                    } = process11;
                                    let vec14 = process_name13;
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    *base.add(12).cast::<usize>() = len14;
                                    *base.add(8).cast::<*mut u8>() = ptr14.cast_mut();
                                    let vec15 = package_name13;
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    *base.add(20).cast::<usize>() = len15;
                                    *base.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                    let vec16 = publisher_node13;
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    *base.add(28).cast::<usize>() = len16;
                                    *base.add(24).cast::<*mut u8>() = ptr16.cast_mut();
                                    let vec17 = params10;
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    *base.add(36).cast::<usize>() = len17;
                                    *base.add(32).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                            }
                            *base.add(80).cast::<usize>() = len18;
                            *base.add(76).cast::<*mut u8>() = result18;
                            match t0_2 {
                                Some(e) => {
                                    *base.add(88).cast::<u8>() = (1i32) as u8;
                                    let vec19 = e;
                                    let ptr19 = vec19.as_ptr().cast::<u8>();
                                    let len19 = vec19.len();
                                    *base.add(96).cast::<usize>() = len19;
                                    *base.add(92).cast::<*mut u8>() = ptr19.cast_mut();
                                }
                                None => {
                                    *base.add(88).cast::<u8>() = (0i32) as u8;
                                }
                            };
                            match t0_3 {
                                Some(e) => {
                                    *base.add(100).cast::<u8>() = (1i32) as u8;
                                    let LazyLoadBlob { mime: mime20, bytes: bytes20 } = e;
                                    match mime20 {
                                        Some(e) => {
                                            *base.add(104).cast::<u8>() = (1i32) as u8;
                                            let vec21 = e;
                                            let ptr21 = vec21.as_ptr().cast::<u8>();
                                            let len21 = vec21.len();
                                            *base.add(112).cast::<usize>() = len21;
                                            *base.add(108).cast::<*mut u8>() = ptr21.cast_mut();
                                        }
                                        None => {
                                            *base.add(104).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    let vec22 = bytes20;
                                    let ptr22 = vec22.as_ptr().cast::<u8>();
                                    let len22 = vec22.len();
                                    *base.add(120).cast::<usize>() = len22;
                                    *base.add(116).cast::<*mut u8>() = ptr22.cast_mut();
                                }
                                None => {
                                    *base.add(100).cast::<u8>() = (0i32) as u8;
                                }
                            };
                            cleanup_list.extend_from_slice(&[(result18, layout18)]);
                        }
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(result23, len23);
                    if layout23.size() != 0 {
                        _rt::alloc::dealloc(result23.cast(), layout23);
                    }
                    for (ptr, layout) in cleanup_list {
                        if layout.size() != 0 {
                            _rt::alloc::dealloc(ptr.cast(), layout);
                        }
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Send response to the request currently being handled.
            pub fn send_response(
                response: &Response,
                lazy_load_blob: Option<&LazyLoadBlob>,
            ) {
                unsafe {
                    let Response {
                        inherit: inherit0,
                        body: body0,
                        metadata: metadata0,
                        capabilities: capabilities0,
                    } = response;
                    let vec1 = body0;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    let (result3_0, result3_1, result3_2) = match metadata0 {
                        Some(e) => {
                            let vec2 = e;
                            let ptr2 = vec2.as_ptr().cast::<u8>();
                            let len2 = vec2.len();
                            (1i32, ptr2.cast_mut(), len2)
                        }
                        None => (0i32, ::core::ptr::null_mut(), 0usize),
                    };
                    let vec12 = capabilities0;
                    let len12 = vec12.len();
                    let layout12 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec12.len() * 40,
                        4,
                    );
                    let result12 = if layout12.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout12).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout12);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec12.into_iter().enumerate() {
                        let base = result12.add(i * 40);
                        {
                            let Capability { issuer: issuer4, params: params4 } = e;
                            let Address { node: node5, process: process5 } = issuer4;
                            let vec6 = node5;
                            let ptr6 = vec6.as_ptr().cast::<u8>();
                            let len6 = vec6.len();
                            *base.add(4).cast::<usize>() = len6;
                            *base.add(0).cast::<*mut u8>() = ptr6.cast_mut();
                            let ProcessId {
                                process_name: process_name7,
                                package_name: package_name7,
                                publisher_node: publisher_node7,
                            } = process5;
                            let vec8 = process_name7;
                            let ptr8 = vec8.as_ptr().cast::<u8>();
                            let len8 = vec8.len();
                            *base.add(12).cast::<usize>() = len8;
                            *base.add(8).cast::<*mut u8>() = ptr8.cast_mut();
                            let vec9 = package_name7;
                            let ptr9 = vec9.as_ptr().cast::<u8>();
                            let len9 = vec9.len();
                            *base.add(20).cast::<usize>() = len9;
                            *base.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                            let vec10 = publisher_node7;
                            let ptr10 = vec10.as_ptr().cast::<u8>();
                            let len10 = vec10.len();
                            *base.add(28).cast::<usize>() = len10;
                            *base.add(24).cast::<*mut u8>() = ptr10.cast_mut();
                            let vec11 = params4;
                            let ptr11 = vec11.as_ptr().cast::<u8>();
                            let len11 = vec11.len();
                            *base.add(36).cast::<usize>() = len11;
                            *base.add(32).cast::<*mut u8>() = ptr11.cast_mut();
                        }
                    }
                    let (
                        result17_0,
                        result17_1,
                        result17_2,
                        result17_3,
                        result17_4,
                        result17_5,
                    ) = match lazy_load_blob {
                        Some(e) => {
                            let LazyLoadBlob { mime: mime13, bytes: bytes13 } = e;
                            let (result15_0, result15_1, result15_2) = match mime13 {
                                Some(e) => {
                                    let vec14 = e;
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    (1i32, ptr14.cast_mut(), len14)
                                }
                                None => (0i32, ::core::ptr::null_mut(), 0usize),
                            };
                            let vec16 = bytes13;
                            let ptr16 = vec16.as_ptr().cast::<u8>();
                            let len16 = vec16.len();
                            (
                                1i32,
                                result15_0,
                                result15_1,
                                result15_2,
                                ptr16.cast_mut(),
                                len16,
                            )
                        }
                        None => {
                            (
                                0i32,
                                0i32,
                                ::core::ptr::null_mut(),
                                0usize,
                                ::core::ptr::null_mut(),
                                0usize,
                            )
                        }
                    };
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(
                        _: i32,
                        _: *mut u8,
                        _: usize,
                        _: i32,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: i32,
                        _: i32,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                    ) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(
                        match inherit0 {
                            true => 1,
                            false => 0,
                        },
                        ptr1.cast_mut(),
                        len1,
                        result3_0,
                        result3_1,
                        result3_2,
                        result12,
                        len12,
                        result17_0,
                        result17_1,
                        result17_2,
                        result17_3,
                        result17_4,
                        result17_5,
                    );
                    if layout12.size() != 0 {
                        _rt::alloc::dealloc(result12.cast(), layout12);
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Send a single request, then block (internally) until its response. The
            /// type returned is Message but will always contain Response.
            pub fn send_and_await_response(
                target: &Address,
                request: &Request,
                lazy_load_blob: Option<&LazyLoadBlob>,
            ) -> Result<(Address, Message), SendError> {
                unsafe {
                    #[repr(align(8))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 136]);
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 136],
                    );
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    let Address { node: node1, process: process1 } = target;
                    let vec2 = node1;
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    *ptr0.add(4).cast::<usize>() = len2;
                    *ptr0.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                    let ProcessId {
                        process_name: process_name3,
                        package_name: package_name3,
                        publisher_node: publisher_node3,
                    } = process1;
                    let vec4 = process_name3;
                    let ptr4 = vec4.as_ptr().cast::<u8>();
                    let len4 = vec4.len();
                    *ptr0.add(12).cast::<usize>() = len4;
                    *ptr0.add(8).cast::<*mut u8>() = ptr4.cast_mut();
                    let vec5 = package_name3;
                    let ptr5 = vec5.as_ptr().cast::<u8>();
                    let len5 = vec5.len();
                    *ptr0.add(20).cast::<usize>() = len5;
                    *ptr0.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                    let vec6 = publisher_node3;
                    let ptr6 = vec6.as_ptr().cast::<u8>();
                    let len6 = vec6.len();
                    *ptr0.add(28).cast::<usize>() = len6;
                    *ptr0.add(24).cast::<*mut u8>() = ptr6.cast_mut();
                    let Request {
                        inherit: inherit7,
                        expects_response: expects_response7,
                        body: body7,
                        metadata: metadata7,
                        capabilities: capabilities7,
                    } = request;
                    *ptr0.add(32).cast::<u8>() = (match inherit7 {
                        true => 1,
                        false => 0,
                    }) as u8;
                    match expects_response7 {
                        Some(e) => {
                            *ptr0.add(40).cast::<u8>() = (1i32) as u8;
                            *ptr0.add(48).cast::<i64>() = _rt::as_i64(e);
                        }
                        None => {
                            *ptr0.add(40).cast::<u8>() = (0i32) as u8;
                        }
                    };
                    let vec8 = body7;
                    let ptr8 = vec8.as_ptr().cast::<u8>();
                    let len8 = vec8.len();
                    *ptr0.add(60).cast::<usize>() = len8;
                    *ptr0.add(56).cast::<*mut u8>() = ptr8.cast_mut();
                    match metadata7 {
                        Some(e) => {
                            *ptr0.add(64).cast::<u8>() = (1i32) as u8;
                            let vec9 = e;
                            let ptr9 = vec9.as_ptr().cast::<u8>();
                            let len9 = vec9.len();
                            *ptr0.add(72).cast::<usize>() = len9;
                            *ptr0.add(68).cast::<*mut u8>() = ptr9.cast_mut();
                        }
                        None => {
                            *ptr0.add(64).cast::<u8>() = (0i32) as u8;
                        }
                    };
                    let vec18 = capabilities7;
                    let len18 = vec18.len();
                    let layout18 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec18.len() * 40,
                        4,
                    );
                    let result18 = if layout18.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout18).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout18);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec18.into_iter().enumerate() {
                        let base = result18.add(i * 40);
                        {
                            let Capability { issuer: issuer10, params: params10 } = e;
                            let Address { node: node11, process: process11 } = issuer10;
                            let vec12 = node11;
                            let ptr12 = vec12.as_ptr().cast::<u8>();
                            let len12 = vec12.len();
                            *base.add(4).cast::<usize>() = len12;
                            *base.add(0).cast::<*mut u8>() = ptr12.cast_mut();
                            let ProcessId {
                                process_name: process_name13,
                                package_name: package_name13,
                                publisher_node: publisher_node13,
                            } = process11;
                            let vec14 = process_name13;
                            let ptr14 = vec14.as_ptr().cast::<u8>();
                            let len14 = vec14.len();
                            *base.add(12).cast::<usize>() = len14;
                            *base.add(8).cast::<*mut u8>() = ptr14.cast_mut();
                            let vec15 = package_name13;
                            let ptr15 = vec15.as_ptr().cast::<u8>();
                            let len15 = vec15.len();
                            *base.add(20).cast::<usize>() = len15;
                            *base.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                            let vec16 = publisher_node13;
                            let ptr16 = vec16.as_ptr().cast::<u8>();
                            let len16 = vec16.len();
                            *base.add(28).cast::<usize>() = len16;
                            *base.add(24).cast::<*mut u8>() = ptr16.cast_mut();
                            let vec17 = params10;
                            let ptr17 = vec17.as_ptr().cast::<u8>();
                            let len17 = vec17.len();
                            *base.add(36).cast::<usize>() = len17;
                            *base.add(32).cast::<*mut u8>() = ptr17.cast_mut();
                        }
                    }
                    *ptr0.add(80).cast::<usize>() = len18;
                    *ptr0.add(76).cast::<*mut u8>() = result18;
                    match lazy_load_blob {
                        Some(e) => {
                            *ptr0.add(88).cast::<u8>() = (1i32) as u8;
                            let LazyLoadBlob { mime: mime19, bytes: bytes19 } = e;
                            match mime19 {
                                Some(e) => {
                                    *ptr0.add(92).cast::<u8>() = (1i32) as u8;
                                    let vec20 = e;
                                    let ptr20 = vec20.as_ptr().cast::<u8>();
                                    let len20 = vec20.len();
                                    *ptr0.add(100).cast::<usize>() = len20;
                                    *ptr0.add(96).cast::<*mut u8>() = ptr20.cast_mut();
                                }
                                None => {
                                    *ptr0.add(92).cast::<u8>() = (0i32) as u8;
                                }
                            };
                            let vec21 = bytes19;
                            let ptr21 = vec21.as_ptr().cast::<u8>();
                            let len21 = vec21.len();
                            *ptr0.add(108).cast::<usize>() = len21;
                            *ptr0.add(104).cast::<*mut u8>() = ptr21.cast_mut();
                        }
                        None => {
                            *ptr0.add(88).cast::<u8>() = (0i32) as u8;
                        }
                    };
                    let ptr22 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: *mut u8) {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                    wit_import(ptr0, ptr22);
                    let l23 = i32::from(*ptr22.add(0).cast::<u8>());
                    if layout18.size() != 0 {
                        _rt::alloc::dealloc(result18.cast(), layout18);
                    }
                    match l23 {
                        0 => {
                            let e = {
                                let l24 = *ptr22.add(8).cast::<*mut u8>();
                                let l25 = *ptr22.add(12).cast::<usize>();
                                let len26 = l25;
                                let bytes26 = _rt::Vec::from_raw_parts(
                                    l24.cast(),
                                    len26,
                                    len26,
                                );
                                let l27 = *ptr22.add(16).cast::<*mut u8>();
                                let l28 = *ptr22.add(20).cast::<usize>();
                                let len29 = l28;
                                let bytes29 = _rt::Vec::from_raw_parts(
                                    l27.cast(),
                                    len29,
                                    len29,
                                );
                                let l30 = *ptr22.add(24).cast::<*mut u8>();
                                let l31 = *ptr22.add(28).cast::<usize>();
                                let len32 = l31;
                                let bytes32 = _rt::Vec::from_raw_parts(
                                    l30.cast(),
                                    len32,
                                    len32,
                                );
                                let l33 = *ptr22.add(32).cast::<*mut u8>();
                                let l34 = *ptr22.add(36).cast::<usize>();
                                let len35 = l34;
                                let bytes35 = _rt::Vec::from_raw_parts(
                                    l33.cast(),
                                    len35,
                                    len35,
                                );
                                let l36 = i32::from(*ptr22.add(40).cast::<u8>());
                                let v95 = match l36 {
                                    0 => {
                                        let e95 = {
                                            let l37 = i32::from(*ptr22.add(48).cast::<u8>());
                                            let l38 = i32::from(*ptr22.add(56).cast::<u8>());
                                            let l40 = *ptr22.add(72).cast::<*mut u8>();
                                            let l41 = *ptr22.add(76).cast::<usize>();
                                            let len42 = l41;
                                            let l43 = i32::from(*ptr22.add(80).cast::<u8>());
                                            let l47 = *ptr22.add(92).cast::<*mut u8>();
                                            let l48 = *ptr22.add(96).cast::<usize>();
                                            let base64 = l47;
                                            let len64 = l48;
                                            let mut result64 = _rt::Vec::with_capacity(len64);
                                            for i in 0..len64 {
                                                let base = base64.add(i * 40);
                                                let e64 = {
                                                    let l49 = *base.add(0).cast::<*mut u8>();
                                                    let l50 = *base.add(4).cast::<usize>();
                                                    let len51 = l50;
                                                    let bytes51 = _rt::Vec::from_raw_parts(
                                                        l49.cast(),
                                                        len51,
                                                        len51,
                                                    );
                                                    let l52 = *base.add(8).cast::<*mut u8>();
                                                    let l53 = *base.add(12).cast::<usize>();
                                                    let len54 = l53;
                                                    let bytes54 = _rt::Vec::from_raw_parts(
                                                        l52.cast(),
                                                        len54,
                                                        len54,
                                                    );
                                                    let l55 = *base.add(16).cast::<*mut u8>();
                                                    let l56 = *base.add(20).cast::<usize>();
                                                    let len57 = l56;
                                                    let bytes57 = _rt::Vec::from_raw_parts(
                                                        l55.cast(),
                                                        len57,
                                                        len57,
                                                    );
                                                    let l58 = *base.add(24).cast::<*mut u8>();
                                                    let l59 = *base.add(28).cast::<usize>();
                                                    let len60 = l59;
                                                    let bytes60 = _rt::Vec::from_raw_parts(
                                                        l58.cast(),
                                                        len60,
                                                        len60,
                                                    );
                                                    let l61 = *base.add(32).cast::<*mut u8>();
                                                    let l62 = *base.add(36).cast::<usize>();
                                                    let len63 = l62;
                                                    let bytes63 = _rt::Vec::from_raw_parts(
                                                        l61.cast(),
                                                        len63,
                                                        len63,
                                                    );
                                                    Capability {
                                                        issuer: Address {
                                                            node: _rt::string_lift(bytes51),
                                                            process: ProcessId {
                                                                process_name: _rt::string_lift(bytes54),
                                                                package_name: _rt::string_lift(bytes57),
                                                                publisher_node: _rt::string_lift(bytes60),
                                                            },
                                                        },
                                                        params: _rt::string_lift(bytes63),
                                                    }
                                                };
                                                result64.push(e64);
                                            }
                                            _rt::cabi_dealloc(base64, len64 * 40, 4);
                                            Request {
                                                inherit: _rt::bool_lift(l37 as u8),
                                                expects_response: match l38 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l39 = *ptr22.add(64).cast::<i64>();
                                                            l39 as u64
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                                body: _rt::Vec::from_raw_parts(l40.cast(), len42, len42),
                                                metadata: match l43 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l44 = *ptr22.add(84).cast::<*mut u8>();
                                                            let l45 = *ptr22.add(88).cast::<usize>();
                                                            let len46 = l45;
                                                            let bytes46 = _rt::Vec::from_raw_parts(
                                                                l44.cast(),
                                                                len46,
                                                                len46,
                                                            );
                                                            _rt::string_lift(bytes46)
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                                capabilities: result64,
                                            }
                                        };
                                        Message::Request(e95)
                                    }
                                    n => {
                                        if true {
                                            match (&n, &1) {
                                                (left_val, right_val) => {
                                                    if !(*left_val == *right_val) {
                                                        let kind = ::core::panicking::AssertKind::Eq;
                                                        ::core::panicking::assert_failed(
                                                            kind,
                                                            &*left_val,
                                                            &*right_val,
                                                            ::core::option::Option::Some(
                                                                format_args!("invalid enum discriminant"),
                                                            ),
                                                        );
                                                    }
                                                }
                                            };
                                        }
                                        let e95 = {
                                            let l65 = i32::from(*ptr22.add(48).cast::<u8>());
                                            let l66 = *ptr22.add(52).cast::<*mut u8>();
                                            let l67 = *ptr22.add(56).cast::<usize>();
                                            let len68 = l67;
                                            let l69 = i32::from(*ptr22.add(60).cast::<u8>());
                                            let l73 = *ptr22.add(72).cast::<*mut u8>();
                                            let l74 = *ptr22.add(76).cast::<usize>();
                                            let base90 = l73;
                                            let len90 = l74;
                                            let mut result90 = _rt::Vec::with_capacity(len90);
                                            for i in 0..len90 {
                                                let base = base90.add(i * 40);
                                                let e90 = {
                                                    let l75 = *base.add(0).cast::<*mut u8>();
                                                    let l76 = *base.add(4).cast::<usize>();
                                                    let len77 = l76;
                                                    let bytes77 = _rt::Vec::from_raw_parts(
                                                        l75.cast(),
                                                        len77,
                                                        len77,
                                                    );
                                                    let l78 = *base.add(8).cast::<*mut u8>();
                                                    let l79 = *base.add(12).cast::<usize>();
                                                    let len80 = l79;
                                                    let bytes80 = _rt::Vec::from_raw_parts(
                                                        l78.cast(),
                                                        len80,
                                                        len80,
                                                    );
                                                    let l81 = *base.add(16).cast::<*mut u8>();
                                                    let l82 = *base.add(20).cast::<usize>();
                                                    let len83 = l82;
                                                    let bytes83 = _rt::Vec::from_raw_parts(
                                                        l81.cast(),
                                                        len83,
                                                        len83,
                                                    );
                                                    let l84 = *base.add(24).cast::<*mut u8>();
                                                    let l85 = *base.add(28).cast::<usize>();
                                                    let len86 = l85;
                                                    let bytes86 = _rt::Vec::from_raw_parts(
                                                        l84.cast(),
                                                        len86,
                                                        len86,
                                                    );
                                                    let l87 = *base.add(32).cast::<*mut u8>();
                                                    let l88 = *base.add(36).cast::<usize>();
                                                    let len89 = l88;
                                                    let bytes89 = _rt::Vec::from_raw_parts(
                                                        l87.cast(),
                                                        len89,
                                                        len89,
                                                    );
                                                    Capability {
                                                        issuer: Address {
                                                            node: _rt::string_lift(bytes77),
                                                            process: ProcessId {
                                                                process_name: _rt::string_lift(bytes80),
                                                                package_name: _rt::string_lift(bytes83),
                                                                publisher_node: _rt::string_lift(bytes86),
                                                            },
                                                        },
                                                        params: _rt::string_lift(bytes89),
                                                    }
                                                };
                                                result90.push(e90);
                                            }
                                            _rt::cabi_dealloc(base90, len90 * 40, 4);
                                            let l91 = i32::from(*ptr22.add(80).cast::<u8>());
                                            (
                                                Response {
                                                    inherit: _rt::bool_lift(l65 as u8),
                                                    body: _rt::Vec::from_raw_parts(l66.cast(), len68, len68),
                                                    metadata: match l69 {
                                                        0 => None,
                                                        1 => {
                                                            let e = {
                                                                let l70 = *ptr22.add(64).cast::<*mut u8>();
                                                                let l71 = *ptr22.add(68).cast::<usize>();
                                                                let len72 = l71;
                                                                let bytes72 = _rt::Vec::from_raw_parts(
                                                                    l70.cast(),
                                                                    len72,
                                                                    len72,
                                                                );
                                                                _rt::string_lift(bytes72)
                                                            };
                                                            Some(e)
                                                        }
                                                        _ => _rt::invalid_enum_discriminant(),
                                                    },
                                                    capabilities: result90,
                                                },
                                                match l91 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l92 = *ptr22.add(84).cast::<*mut u8>();
                                                            let l93 = *ptr22.add(88).cast::<usize>();
                                                            let len94 = l93;
                                                            _rt::Vec::from_raw_parts(l92.cast(), len94, len94)
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                            )
                                        };
                                        Message::Response(e95)
                                    }
                                };
                                (
                                    Address {
                                        node: _rt::string_lift(bytes26),
                                        process: ProcessId {
                                            process_name: _rt::string_lift(bytes29),
                                            package_name: _rt::string_lift(bytes32),
                                            publisher_node: _rt::string_lift(bytes35),
                                        },
                                    },
                                    v95,
                                )
                            };
                            Ok(e)
                        }
                        1 => {
                            let e = {
                                let l96 = i32::from(*ptr22.add(8).cast::<u8>());
                                let l97 = *ptr22.add(12).cast::<*mut u8>();
                                let l98 = *ptr22.add(16).cast::<usize>();
                                let len99 = l98;
                                let bytes99 = _rt::Vec::from_raw_parts(
                                    l97.cast(),
                                    len99,
                                    len99,
                                );
                                let l100 = *ptr22.add(20).cast::<*mut u8>();
                                let l101 = *ptr22.add(24).cast::<usize>();
                                let len102 = l101;
                                let bytes102 = _rt::Vec::from_raw_parts(
                                    l100.cast(),
                                    len102,
                                    len102,
                                );
                                let l103 = *ptr22.add(28).cast::<*mut u8>();
                                let l104 = *ptr22.add(32).cast::<usize>();
                                let len105 = l104;
                                let bytes105 = _rt::Vec::from_raw_parts(
                                    l103.cast(),
                                    len105,
                                    len105,
                                );
                                let l106 = *ptr22.add(36).cast::<*mut u8>();
                                let l107 = *ptr22.add(40).cast::<usize>();
                                let len108 = l107;
                                let bytes108 = _rt::Vec::from_raw_parts(
                                    l106.cast(),
                                    len108,
                                    len108,
                                );
                                let l109 = i32::from(*ptr22.add(48).cast::<u8>());
                                let v168 = match l109 {
                                    0 => {
                                        let e168 = {
                                            let l110 = i32::from(*ptr22.add(56).cast::<u8>());
                                            let l111 = i32::from(*ptr22.add(64).cast::<u8>());
                                            let l113 = *ptr22.add(80).cast::<*mut u8>();
                                            let l114 = *ptr22.add(84).cast::<usize>();
                                            let len115 = l114;
                                            let l116 = i32::from(*ptr22.add(88).cast::<u8>());
                                            let l120 = *ptr22.add(100).cast::<*mut u8>();
                                            let l121 = *ptr22.add(104).cast::<usize>();
                                            let base137 = l120;
                                            let len137 = l121;
                                            let mut result137 = _rt::Vec::with_capacity(len137);
                                            for i in 0..len137 {
                                                let base = base137.add(i * 40);
                                                let e137 = {
                                                    let l122 = *base.add(0).cast::<*mut u8>();
                                                    let l123 = *base.add(4).cast::<usize>();
                                                    let len124 = l123;
                                                    let bytes124 = _rt::Vec::from_raw_parts(
                                                        l122.cast(),
                                                        len124,
                                                        len124,
                                                    );
                                                    let l125 = *base.add(8).cast::<*mut u8>();
                                                    let l126 = *base.add(12).cast::<usize>();
                                                    let len127 = l126;
                                                    let bytes127 = _rt::Vec::from_raw_parts(
                                                        l125.cast(),
                                                        len127,
                                                        len127,
                                                    );
                                                    let l128 = *base.add(16).cast::<*mut u8>();
                                                    let l129 = *base.add(20).cast::<usize>();
                                                    let len130 = l129;
                                                    let bytes130 = _rt::Vec::from_raw_parts(
                                                        l128.cast(),
                                                        len130,
                                                        len130,
                                                    );
                                                    let l131 = *base.add(24).cast::<*mut u8>();
                                                    let l132 = *base.add(28).cast::<usize>();
                                                    let len133 = l132;
                                                    let bytes133 = _rt::Vec::from_raw_parts(
                                                        l131.cast(),
                                                        len133,
                                                        len133,
                                                    );
                                                    let l134 = *base.add(32).cast::<*mut u8>();
                                                    let l135 = *base.add(36).cast::<usize>();
                                                    let len136 = l135;
                                                    let bytes136 = _rt::Vec::from_raw_parts(
                                                        l134.cast(),
                                                        len136,
                                                        len136,
                                                    );
                                                    Capability {
                                                        issuer: Address {
                                                            node: _rt::string_lift(bytes124),
                                                            process: ProcessId {
                                                                process_name: _rt::string_lift(bytes127),
                                                                package_name: _rt::string_lift(bytes130),
                                                                publisher_node: _rt::string_lift(bytes133),
                                                            },
                                                        },
                                                        params: _rt::string_lift(bytes136),
                                                    }
                                                };
                                                result137.push(e137);
                                            }
                                            _rt::cabi_dealloc(base137, len137 * 40, 4);
                                            Request {
                                                inherit: _rt::bool_lift(l110 as u8),
                                                expects_response: match l111 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l112 = *ptr22.add(72).cast::<i64>();
                                                            l112 as u64
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                                body: _rt::Vec::from_raw_parts(l113.cast(), len115, len115),
                                                metadata: match l116 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l117 = *ptr22.add(92).cast::<*mut u8>();
                                                            let l118 = *ptr22.add(96).cast::<usize>();
                                                            let len119 = l118;
                                                            let bytes119 = _rt::Vec::from_raw_parts(
                                                                l117.cast(),
                                                                len119,
                                                                len119,
                                                            );
                                                            _rt::string_lift(bytes119)
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                                capabilities: result137,
                                            }
                                        };
                                        Message::Request(e168)
                                    }
                                    n => {
                                        if true {
                                            match (&n, &1) {
                                                (left_val, right_val) => {
                                                    if !(*left_val == *right_val) {
                                                        let kind = ::core::panicking::AssertKind::Eq;
                                                        ::core::panicking::assert_failed(
                                                            kind,
                                                            &*left_val,
                                                            &*right_val,
                                                            ::core::option::Option::Some(
                                                                format_args!("invalid enum discriminant"),
                                                            ),
                                                        );
                                                    }
                                                }
                                            };
                                        }
                                        let e168 = {
                                            let l138 = i32::from(*ptr22.add(56).cast::<u8>());
                                            let l139 = *ptr22.add(60).cast::<*mut u8>();
                                            let l140 = *ptr22.add(64).cast::<usize>();
                                            let len141 = l140;
                                            let l142 = i32::from(*ptr22.add(68).cast::<u8>());
                                            let l146 = *ptr22.add(80).cast::<*mut u8>();
                                            let l147 = *ptr22.add(84).cast::<usize>();
                                            let base163 = l146;
                                            let len163 = l147;
                                            let mut result163 = _rt::Vec::with_capacity(len163);
                                            for i in 0..len163 {
                                                let base = base163.add(i * 40);
                                                let e163 = {
                                                    let l148 = *base.add(0).cast::<*mut u8>();
                                                    let l149 = *base.add(4).cast::<usize>();
                                                    let len150 = l149;
                                                    let bytes150 = _rt::Vec::from_raw_parts(
                                                        l148.cast(),
                                                        len150,
                                                        len150,
                                                    );
                                                    let l151 = *base.add(8).cast::<*mut u8>();
                                                    let l152 = *base.add(12).cast::<usize>();
                                                    let len153 = l152;
                                                    let bytes153 = _rt::Vec::from_raw_parts(
                                                        l151.cast(),
                                                        len153,
                                                        len153,
                                                    );
                                                    let l154 = *base.add(16).cast::<*mut u8>();
                                                    let l155 = *base.add(20).cast::<usize>();
                                                    let len156 = l155;
                                                    let bytes156 = _rt::Vec::from_raw_parts(
                                                        l154.cast(),
                                                        len156,
                                                        len156,
                                                    );
                                                    let l157 = *base.add(24).cast::<*mut u8>();
                                                    let l158 = *base.add(28).cast::<usize>();
                                                    let len159 = l158;
                                                    let bytes159 = _rt::Vec::from_raw_parts(
                                                        l157.cast(),
                                                        len159,
                                                        len159,
                                                    );
                                                    let l160 = *base.add(32).cast::<*mut u8>();
                                                    let l161 = *base.add(36).cast::<usize>();
                                                    let len162 = l161;
                                                    let bytes162 = _rt::Vec::from_raw_parts(
                                                        l160.cast(),
                                                        len162,
                                                        len162,
                                                    );
                                                    Capability {
                                                        issuer: Address {
                                                            node: _rt::string_lift(bytes150),
                                                            process: ProcessId {
                                                                process_name: _rt::string_lift(bytes153),
                                                                package_name: _rt::string_lift(bytes156),
                                                                publisher_node: _rt::string_lift(bytes159),
                                                            },
                                                        },
                                                        params: _rt::string_lift(bytes162),
                                                    }
                                                };
                                                result163.push(e163);
                                            }
                                            _rt::cabi_dealloc(base163, len163 * 40, 4);
                                            let l164 = i32::from(*ptr22.add(88).cast::<u8>());
                                            (
                                                Response {
                                                    inherit: _rt::bool_lift(l138 as u8),
                                                    body: _rt::Vec::from_raw_parts(l139.cast(), len141, len141),
                                                    metadata: match l142 {
                                                        0 => None,
                                                        1 => {
                                                            let e = {
                                                                let l143 = *ptr22.add(72).cast::<*mut u8>();
                                                                let l144 = *ptr22.add(76).cast::<usize>();
                                                                let len145 = l144;
                                                                let bytes145 = _rt::Vec::from_raw_parts(
                                                                    l143.cast(),
                                                                    len145,
                                                                    len145,
                                                                );
                                                                _rt::string_lift(bytes145)
                                                            };
                                                            Some(e)
                                                        }
                                                        _ => _rt::invalid_enum_discriminant(),
                                                    },
                                                    capabilities: result163,
                                                },
                                                match l164 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l165 = *ptr22.add(92).cast::<*mut u8>();
                                                            let l166 = *ptr22.add(96).cast::<usize>();
                                                            let len167 = l166;
                                                            _rt::Vec::from_raw_parts(l165.cast(), len167, len167)
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                            )
                                        };
                                        Message::Response(e168)
                                    }
                                };
                                let l169 = i32::from(*ptr22.add(112).cast::<u8>());
                                SendError {
                                    kind: SendErrorKind::_lift(l96 as u8),
                                    target: Address {
                                        node: _rt::string_lift(bytes99),
                                        process: ProcessId {
                                            process_name: _rt::string_lift(bytes102),
                                            package_name: _rt::string_lift(bytes105),
                                            publisher_node: _rt::string_lift(bytes108),
                                        },
                                    },
                                    message: v168,
                                    lazy_load_blob: match l169 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l170 = i32::from(*ptr22.add(116).cast::<u8>());
                                                let l174 = *ptr22.add(128).cast::<*mut u8>();
                                                let l175 = *ptr22.add(132).cast::<usize>();
                                                let len176 = l175;
                                                LazyLoadBlob {
                                                    mime: match l170 {
                                                        0 => None,
                                                        1 => {
                                                            let e = {
                                                                let l171 = *ptr22.add(120).cast::<*mut u8>();
                                                                let l172 = *ptr22.add(124).cast::<usize>();
                                                                let len173 = l172;
                                                                let bytes173 = _rt::Vec::from_raw_parts(
                                                                    l171.cast(),
                                                                    len173,
                                                                    len173,
                                                                );
                                                                _rt::string_lift(bytes173)
                                                            };
                                                            Some(e)
                                                        }
                                                        _ => _rt::invalid_enum_discriminant(),
                                                    },
                                                    bytes: _rt::Vec::from_raw_parts(l174.cast(), len176, len176),
                                                }
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                }
                            };
                            Err(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    }
                }
            }
        }
        #[allow(dead_code, clippy::all)]
        pub mod app {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type Address = super::super::super::hyperware::process::standard::Address;
            /// Function signature for: add-line-item (http)
            /// HTTP: POST /api/add-line-item
            pub struct AddLineItemSignatureHttp {
                pub target: _rt::String,
                pub returning: Result<_rt::String, _rt::String>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for AddLineItemSignatureHttp {
                #[inline]
                fn clone(&self) -> AddLineItemSignatureHttp {
                    AddLineItemSignatureHttp {
                        target: ::core::clone::Clone::clone(&self.target),
                        returning: ::core::clone::Clone::clone(&self.returning),
                    }
                }
            }
            impl From<AddLineItemSignatureHttp> for Vec<u8> {
                fn from(value: AddLineItemSignatureHttp) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a AddLineItemSignatureHttp> for Vec<u8> {
                fn from(value: &'a AddLineItemSignatureHttp) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for AddLineItemSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for AddLineItemSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for AddLineItemSignatureHttp {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "target" => _serde::__private::Ok(__Field::__field0),
                                    "returning" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"target" => _serde::__private::Ok(__Field::__field0),
                                    b"returning" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<
                                AddLineItemSignatureHttp,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = AddLineItemSignatureHttp;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct AddLineItemSignatureHttp",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct AddLineItemSignatureHttp with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Result<_rt::String, _rt::String>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct AddLineItemSignatureHttp with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(AddLineItemSignatureHttp {
                                    target: __field0,
                                    returning: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    Result<_rt::String, _rt::String>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("target"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "returning",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Result<_rt::String, _rt::String>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("target")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("returning")?
                                    }
                                };
                                _serde::__private::Ok(AddLineItemSignatureHttp {
                                    target: __field0,
                                    returning: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["target", "returning"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "AddLineItemSignatureHttp",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    AddLineItemSignatureHttp,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for AddLineItemSignatureHttp {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "AddLineItemSignatureHttp",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "target",
                            &self.target,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "returning",
                            &self.returning,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for AddLineItemSignatureHttp {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("AddLineItemSignatureHttp")
                        .field("target", &self.target)
                        .field("returning", &self.returning)
                        .finish()
                }
            }
            /// Function signature for: can-redo (http)
            /// HTTP: POST /api/can-redo
            pub struct CanRedoSignatureHttp {
                pub target: _rt::String,
                pub returning: Result<bool, _rt::String>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for CanRedoSignatureHttp {
                #[inline]
                fn clone(&self) -> CanRedoSignatureHttp {
                    CanRedoSignatureHttp {
                        target: ::core::clone::Clone::clone(&self.target),
                        returning: ::core::clone::Clone::clone(&self.returning),
                    }
                }
            }
            impl From<CanRedoSignatureHttp> for Vec<u8> {
                fn from(value: CanRedoSignatureHttp) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a CanRedoSignatureHttp> for Vec<u8> {
                fn from(value: &'a CanRedoSignatureHttp) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for CanRedoSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for CanRedoSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for CanRedoSignatureHttp {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "target" => _serde::__private::Ok(__Field::__field0),
                                    "returning" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"target" => _serde::__private::Ok(__Field::__field0),
                                    b"returning" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<CanRedoSignatureHttp>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = CanRedoSignatureHttp;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct CanRedoSignatureHttp",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct CanRedoSignatureHttp with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Result<bool, _rt::String>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct CanRedoSignatureHttp with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(CanRedoSignatureHttp {
                                    target: __field0,
                                    returning: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    Result<bool, _rt::String>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("target"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "returning",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Result<bool, _rt::String>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("target")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("returning")?
                                    }
                                };
                                _serde::__private::Ok(CanRedoSignatureHttp {
                                    target: __field0,
                                    returning: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["target", "returning"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "CanRedoSignatureHttp",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    CanRedoSignatureHttp,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for CanRedoSignatureHttp {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "CanRedoSignatureHttp",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "target",
                            &self.target,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "returning",
                            &self.returning,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for CanRedoSignatureHttp {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("CanRedoSignatureHttp")
                        .field("target", &self.target)
                        .field("returning", &self.returning)
                        .finish()
                }
            }
            /// Function signature for: can-undo (http)
            /// HTTP: POST /api/can-undo
            pub struct CanUndoSignatureHttp {
                pub target: _rt::String,
                pub returning: Result<bool, _rt::String>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for CanUndoSignatureHttp {
                #[inline]
                fn clone(&self) -> CanUndoSignatureHttp {
                    CanUndoSignatureHttp {
                        target: ::core::clone::Clone::clone(&self.target),
                        returning: ::core::clone::Clone::clone(&self.returning),
                    }
                }
            }
            impl From<CanUndoSignatureHttp> for Vec<u8> {
                fn from(value: CanUndoSignatureHttp) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a CanUndoSignatureHttp> for Vec<u8> {
                fn from(value: &'a CanUndoSignatureHttp) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for CanUndoSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for CanUndoSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for CanUndoSignatureHttp {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "target" => _serde::__private::Ok(__Field::__field0),
                                    "returning" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"target" => _serde::__private::Ok(__Field::__field0),
                                    b"returning" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<CanUndoSignatureHttp>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = CanUndoSignatureHttp;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct CanUndoSignatureHttp",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct CanUndoSignatureHttp with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Result<bool, _rt::String>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct CanUndoSignatureHttp with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(CanUndoSignatureHttp {
                                    target: __field0,
                                    returning: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    Result<bool, _rt::String>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("target"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "returning",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Result<bool, _rt::String>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("target")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("returning")?
                                    }
                                };
                                _serde::__private::Ok(CanUndoSignatureHttp {
                                    target: __field0,
                                    returning: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["target", "returning"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "CanUndoSignatureHttp",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    CanUndoSignatureHttp,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for CanUndoSignatureHttp {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "CanUndoSignatureHttp",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "target",
                            &self.target,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "returning",
                            &self.returning,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for CanUndoSignatureHttp {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("CanUndoSignatureHttp")
                        .field("target", &self.target)
                        .field("returning", &self.returning)
                        .finish()
                }
            }
            /// Function signature for: check-autosave (http)
            /// HTTP: POST /api/check-autosave
            pub struct CheckAutosaveSignatureHttp {
                pub target: _rt::String,
                pub returning: Result<_rt::String, _rt::String>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for CheckAutosaveSignatureHttp {
                #[inline]
                fn clone(&self) -> CheckAutosaveSignatureHttp {
                    CheckAutosaveSignatureHttp {
                        target: ::core::clone::Clone::clone(&self.target),
                        returning: ::core::clone::Clone::clone(&self.returning),
                    }
                }
            }
            impl From<CheckAutosaveSignatureHttp> for Vec<u8> {
                fn from(value: CheckAutosaveSignatureHttp) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a CheckAutosaveSignatureHttp> for Vec<u8> {
                fn from(value: &'a CheckAutosaveSignatureHttp) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for CheckAutosaveSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for CheckAutosaveSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for CheckAutosaveSignatureHttp {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "target" => _serde::__private::Ok(__Field::__field0),
                                    "returning" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"target" => _serde::__private::Ok(__Field::__field0),
                                    b"returning" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<
                                CheckAutosaveSignatureHttp,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = CheckAutosaveSignatureHttp;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct CheckAutosaveSignatureHttp",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct CheckAutosaveSignatureHttp with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Result<_rt::String, _rt::String>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct CheckAutosaveSignatureHttp with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(CheckAutosaveSignatureHttp {
                                    target: __field0,
                                    returning: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    Result<_rt::String, _rt::String>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("target"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "returning",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Result<_rt::String, _rt::String>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("target")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("returning")?
                                    }
                                };
                                _serde::__private::Ok(CheckAutosaveSignatureHttp {
                                    target: __field0,
                                    returning: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["target", "returning"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "CheckAutosaveSignatureHttp",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    CheckAutosaveSignatureHttp,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for CheckAutosaveSignatureHttp {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "CheckAutosaveSignatureHttp",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "target",
                            &self.target,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "returning",
                            &self.returning,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for CheckAutosaveSignatureHttp {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("CheckAutosaveSignatureHttp")
                        .field("target", &self.target)
                        .field("returning", &self.returning)
                        .finish()
                }
            }
            /// Function signature for: create-invoice (http)
            /// HTTP: POST /api/create-invoice
            pub struct CreateInvoiceSignatureHttp {
                pub target: _rt::String,
                pub returning: Result<_rt::String, _rt::String>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for CreateInvoiceSignatureHttp {
                #[inline]
                fn clone(&self) -> CreateInvoiceSignatureHttp {
                    CreateInvoiceSignatureHttp {
                        target: ::core::clone::Clone::clone(&self.target),
                        returning: ::core::clone::Clone::clone(&self.returning),
                    }
                }
            }
            impl From<CreateInvoiceSignatureHttp> for Vec<u8> {
                fn from(value: CreateInvoiceSignatureHttp) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a CreateInvoiceSignatureHttp> for Vec<u8> {
                fn from(value: &'a CreateInvoiceSignatureHttp) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for CreateInvoiceSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for CreateInvoiceSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for CreateInvoiceSignatureHttp {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "target" => _serde::__private::Ok(__Field::__field0),
                                    "returning" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"target" => _serde::__private::Ok(__Field::__field0),
                                    b"returning" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<
                                CreateInvoiceSignatureHttp,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = CreateInvoiceSignatureHttp;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct CreateInvoiceSignatureHttp",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct CreateInvoiceSignatureHttp with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Result<_rt::String, _rt::String>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct CreateInvoiceSignatureHttp with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(CreateInvoiceSignatureHttp {
                                    target: __field0,
                                    returning: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    Result<_rt::String, _rt::String>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("target"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "returning",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Result<_rt::String, _rt::String>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("target")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("returning")?
                                    }
                                };
                                _serde::__private::Ok(CreateInvoiceSignatureHttp {
                                    target: __field0,
                                    returning: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["target", "returning"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "CreateInvoiceSignatureHttp",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    CreateInvoiceSignatureHttp,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for CreateInvoiceSignatureHttp {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "CreateInvoiceSignatureHttp",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "target",
                            &self.target,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "returning",
                            &self.returning,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for CreateInvoiceSignatureHttp {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("CreateInvoiceSignatureHttp")
                        .field("target", &self.target)
                        .field("returning", &self.returning)
                        .finish()
                }
            }
            /// Function signature for: delete-invoice (http)
            /// HTTP: POST /api/delete-invoice
            pub struct DeleteInvoiceSignatureHttp {
                pub target: _rt::String,
                pub request_body: _rt::String,
                pub returning: Result<_rt::String, _rt::String>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for DeleteInvoiceSignatureHttp {
                #[inline]
                fn clone(&self) -> DeleteInvoiceSignatureHttp {
                    DeleteInvoiceSignatureHttp {
                        target: ::core::clone::Clone::clone(&self.target),
                        request_body: ::core::clone::Clone::clone(&self.request_body),
                        returning: ::core::clone::Clone::clone(&self.returning),
                    }
                }
            }
            impl From<DeleteInvoiceSignatureHttp> for Vec<u8> {
                fn from(value: DeleteInvoiceSignatureHttp) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a DeleteInvoiceSignatureHttp> for Vec<u8> {
                fn from(value: &'a DeleteInvoiceSignatureHttp) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for DeleteInvoiceSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for DeleteInvoiceSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for DeleteInvoiceSignatureHttp {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "target" => _serde::__private::Ok(__Field::__field0),
                                    "request_body" => _serde::__private::Ok(__Field::__field1),
                                    "returning" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"target" => _serde::__private::Ok(__Field::__field0),
                                    b"request_body" => _serde::__private::Ok(__Field::__field1),
                                    b"returning" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<
                                DeleteInvoiceSignatureHttp,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = DeleteInvoiceSignatureHttp;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct DeleteInvoiceSignatureHttp",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct DeleteInvoiceSignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct DeleteInvoiceSignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    Result<_rt::String, _rt::String>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct DeleteInvoiceSignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(DeleteInvoiceSignatureHttp {
                                    target: __field0,
                                    request_body: __field1,
                                    returning: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<
                                    Result<_rt::String, _rt::String>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("target"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "request_body",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "returning",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Result<_rt::String, _rt::String>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("target")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("request_body")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("returning")?
                                    }
                                };
                                _serde::__private::Ok(DeleteInvoiceSignatureHttp {
                                    target: __field0,
                                    request_body: __field1,
                                    returning: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "target",
                            "request_body",
                            "returning",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "DeleteInvoiceSignatureHttp",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    DeleteInvoiceSignatureHttp,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for DeleteInvoiceSignatureHttp {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "DeleteInvoiceSignatureHttp",
                            false as usize + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "target",
                            &self.target,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "request_body",
                            &self.request_body,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "returning",
                            &self.returning,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for DeleteInvoiceSignatureHttp {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("DeleteInvoiceSignatureHttp")
                        .field("target", &self.target)
                        .field("request-body", &self.request_body)
                        .field("returning", &self.returning)
                        .finish()
                }
            }
            /// Function signature for: delete-line-item (http)
            /// HTTP: POST /api/delete-line-item
            pub struct DeleteLineItemSignatureHttp {
                pub target: _rt::String,
                pub request_body: _rt::String,
                pub returning: Result<_rt::String, _rt::String>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for DeleteLineItemSignatureHttp {
                #[inline]
                fn clone(&self) -> DeleteLineItemSignatureHttp {
                    DeleteLineItemSignatureHttp {
                        target: ::core::clone::Clone::clone(&self.target),
                        request_body: ::core::clone::Clone::clone(&self.request_body),
                        returning: ::core::clone::Clone::clone(&self.returning),
                    }
                }
            }
            impl From<DeleteLineItemSignatureHttp> for Vec<u8> {
                fn from(value: DeleteLineItemSignatureHttp) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a DeleteLineItemSignatureHttp> for Vec<u8> {
                fn from(value: &'a DeleteLineItemSignatureHttp) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for DeleteLineItemSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for DeleteLineItemSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for DeleteLineItemSignatureHttp {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "target" => _serde::__private::Ok(__Field::__field0),
                                    "request_body" => _serde::__private::Ok(__Field::__field1),
                                    "returning" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"target" => _serde::__private::Ok(__Field::__field0),
                                    b"request_body" => _serde::__private::Ok(__Field::__field1),
                                    b"returning" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<
                                DeleteLineItemSignatureHttp,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = DeleteLineItemSignatureHttp;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct DeleteLineItemSignatureHttp",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct DeleteLineItemSignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct DeleteLineItemSignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    Result<_rt::String, _rt::String>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct DeleteLineItemSignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(DeleteLineItemSignatureHttp {
                                    target: __field0,
                                    request_body: __field1,
                                    returning: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<
                                    Result<_rt::String, _rt::String>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("target"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "request_body",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "returning",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Result<_rt::String, _rt::String>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("target")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("request_body")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("returning")?
                                    }
                                };
                                _serde::__private::Ok(DeleteLineItemSignatureHttp {
                                    target: __field0,
                                    request_body: __field1,
                                    returning: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "target",
                            "request_body",
                            "returning",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "DeleteLineItemSignatureHttp",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    DeleteLineItemSignatureHttp,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for DeleteLineItemSignatureHttp {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "DeleteLineItemSignatureHttp",
                            false as usize + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "target",
                            &self.target,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "request_body",
                            &self.request_body,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "returning",
                            &self.returning,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for DeleteLineItemSignatureHttp {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("DeleteLineItemSignatureHttp")
                        .field("target", &self.target)
                        .field("request-body", &self.request_body)
                        .field("returning", &self.returning)
                        .finish()
                }
            }
            /// Function signature for: generate-pdf (http)
            /// HTTP: POST /api/generate-pdf
            pub struct GeneratePdfSignatureHttp {
                pub target: _rt::String,
                pub returning: Result<_rt::String, _rt::String>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for GeneratePdfSignatureHttp {
                #[inline]
                fn clone(&self) -> GeneratePdfSignatureHttp {
                    GeneratePdfSignatureHttp {
                        target: ::core::clone::Clone::clone(&self.target),
                        returning: ::core::clone::Clone::clone(&self.returning),
                    }
                }
            }
            impl From<GeneratePdfSignatureHttp> for Vec<u8> {
                fn from(value: GeneratePdfSignatureHttp) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a GeneratePdfSignatureHttp> for Vec<u8> {
                fn from(value: &'a GeneratePdfSignatureHttp) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for GeneratePdfSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for GeneratePdfSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for GeneratePdfSignatureHttp {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "target" => _serde::__private::Ok(__Field::__field0),
                                    "returning" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"target" => _serde::__private::Ok(__Field::__field0),
                                    b"returning" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<
                                GeneratePdfSignatureHttp,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = GeneratePdfSignatureHttp;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct GeneratePdfSignatureHttp",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct GeneratePdfSignatureHttp with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Result<_rt::String, _rt::String>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct GeneratePdfSignatureHttp with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(GeneratePdfSignatureHttp {
                                    target: __field0,
                                    returning: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    Result<_rt::String, _rt::String>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("target"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "returning",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Result<_rt::String, _rt::String>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("target")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("returning")?
                                    }
                                };
                                _serde::__private::Ok(GeneratePdfSignatureHttp {
                                    target: __field0,
                                    returning: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["target", "returning"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "GeneratePdfSignatureHttp",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    GeneratePdfSignatureHttp,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for GeneratePdfSignatureHttp {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "GeneratePdfSignatureHttp",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "target",
                            &self.target,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "returning",
                            &self.returning,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for GeneratePdfSignatureHttp {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("GeneratePdfSignatureHttp")
                        .field("target", &self.target)
                        .field("returning", &self.returning)
                        .finish()
                }
            }
            /// Function signature for: get-invoice (http)
            /// HTTP: POST /api/get-invoice
            pub struct GetInvoiceSignatureHttp {
                pub target: _rt::String,
                pub request_body: _rt::String,
                pub returning: Result<_rt::String, _rt::String>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for GetInvoiceSignatureHttp {
                #[inline]
                fn clone(&self) -> GetInvoiceSignatureHttp {
                    GetInvoiceSignatureHttp {
                        target: ::core::clone::Clone::clone(&self.target),
                        request_body: ::core::clone::Clone::clone(&self.request_body),
                        returning: ::core::clone::Clone::clone(&self.returning),
                    }
                }
            }
            impl From<GetInvoiceSignatureHttp> for Vec<u8> {
                fn from(value: GetInvoiceSignatureHttp) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a GetInvoiceSignatureHttp> for Vec<u8> {
                fn from(value: &'a GetInvoiceSignatureHttp) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for GetInvoiceSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for GetInvoiceSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for GetInvoiceSignatureHttp {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "target" => _serde::__private::Ok(__Field::__field0),
                                    "request_body" => _serde::__private::Ok(__Field::__field1),
                                    "returning" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"target" => _serde::__private::Ok(__Field::__field0),
                                    b"request_body" => _serde::__private::Ok(__Field::__field1),
                                    b"returning" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<
                                GetInvoiceSignatureHttp,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = GetInvoiceSignatureHttp;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct GetInvoiceSignatureHttp",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct GetInvoiceSignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct GetInvoiceSignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    Result<_rt::String, _rt::String>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct GetInvoiceSignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(GetInvoiceSignatureHttp {
                                    target: __field0,
                                    request_body: __field1,
                                    returning: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<
                                    Result<_rt::String, _rt::String>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("target"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "request_body",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "returning",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Result<_rt::String, _rt::String>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("target")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("request_body")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("returning")?
                                    }
                                };
                                _serde::__private::Ok(GetInvoiceSignatureHttp {
                                    target: __field0,
                                    request_body: __field1,
                                    returning: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "target",
                            "request_body",
                            "returning",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "GetInvoiceSignatureHttp",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    GetInvoiceSignatureHttp,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for GetInvoiceSignatureHttp {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "GetInvoiceSignatureHttp",
                            false as usize + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "target",
                            &self.target,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "request_body",
                            &self.request_body,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "returning",
                            &self.returning,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for GetInvoiceSignatureHttp {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("GetInvoiceSignatureHttp")
                        .field("target", &self.target)
                        .field("request-body", &self.request_body)
                        .field("returning", &self.returning)
                        .finish()
                }
            }
            /// Function signature for: get-settings (http)
            /// HTTP: POST /api/get-settings
            pub struct GetSettingsSignatureHttp {
                pub target: _rt::String,
                pub returning: Result<_rt::String, _rt::String>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for GetSettingsSignatureHttp {
                #[inline]
                fn clone(&self) -> GetSettingsSignatureHttp {
                    GetSettingsSignatureHttp {
                        target: ::core::clone::Clone::clone(&self.target),
                        returning: ::core::clone::Clone::clone(&self.returning),
                    }
                }
            }
            impl From<GetSettingsSignatureHttp> for Vec<u8> {
                fn from(value: GetSettingsSignatureHttp) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a GetSettingsSignatureHttp> for Vec<u8> {
                fn from(value: &'a GetSettingsSignatureHttp) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for GetSettingsSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for GetSettingsSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for GetSettingsSignatureHttp {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "target" => _serde::__private::Ok(__Field::__field0),
                                    "returning" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"target" => _serde::__private::Ok(__Field::__field0),
                                    b"returning" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<
                                GetSettingsSignatureHttp,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = GetSettingsSignatureHttp;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct GetSettingsSignatureHttp",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct GetSettingsSignatureHttp with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Result<_rt::String, _rt::String>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct GetSettingsSignatureHttp with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(GetSettingsSignatureHttp {
                                    target: __field0,
                                    returning: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    Result<_rt::String, _rt::String>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("target"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "returning",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Result<_rt::String, _rt::String>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("target")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("returning")?
                                    }
                                };
                                _serde::__private::Ok(GetSettingsSignatureHttp {
                                    target: __field0,
                                    returning: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["target", "returning"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "GetSettingsSignatureHttp",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    GetSettingsSignatureHttp,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for GetSettingsSignatureHttp {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "GetSettingsSignatureHttp",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "target",
                            &self.target,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "returning",
                            &self.returning,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for GetSettingsSignatureHttp {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("GetSettingsSignatureHttp")
                        .field("target", &self.target)
                        .field("returning", &self.returning)
                        .finish()
                }
            }
            /// Function signature for: list-invoices (http)
            /// HTTP: POST /api/list-invoices
            pub struct ListInvoicesSignatureHttp {
                pub target: _rt::String,
                pub returning: Result<_rt::String, _rt::String>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ListInvoicesSignatureHttp {
                #[inline]
                fn clone(&self) -> ListInvoicesSignatureHttp {
                    ListInvoicesSignatureHttp {
                        target: ::core::clone::Clone::clone(&self.target),
                        returning: ::core::clone::Clone::clone(&self.returning),
                    }
                }
            }
            impl From<ListInvoicesSignatureHttp> for Vec<u8> {
                fn from(value: ListInvoicesSignatureHttp) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a ListInvoicesSignatureHttp> for Vec<u8> {
                fn from(value: &'a ListInvoicesSignatureHttp) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for ListInvoicesSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for ListInvoicesSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for ListInvoicesSignatureHttp {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "target" => _serde::__private::Ok(__Field::__field0),
                                    "returning" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"target" => _serde::__private::Ok(__Field::__field0),
                                    b"returning" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<
                                ListInvoicesSignatureHttp,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = ListInvoicesSignatureHttp;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct ListInvoicesSignatureHttp",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct ListInvoicesSignatureHttp with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Result<_rt::String, _rt::String>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct ListInvoicesSignatureHttp with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(ListInvoicesSignatureHttp {
                                    target: __field0,
                                    returning: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    Result<_rt::String, _rt::String>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("target"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "returning",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Result<_rt::String, _rt::String>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("target")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("returning")?
                                    }
                                };
                                _serde::__private::Ok(ListInvoicesSignatureHttp {
                                    target: __field0,
                                    returning: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["target", "returning"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "ListInvoicesSignatureHttp",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    ListInvoicesSignatureHttp,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for ListInvoicesSignatureHttp {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "ListInvoicesSignatureHttp",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "target",
                            &self.target,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "returning",
                            &self.returning,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for ListInvoicesSignatureHttp {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("ListInvoicesSignatureHttp")
                        .field("target", &self.target)
                        .field("returning", &self.returning)
                        .finish()
                }
            }
            /// Function signature for: redo (http)
            /// HTTP: POST /api/redo
            pub struct RedoSignatureHttp {
                pub target: _rt::String,
                pub returning: Result<_rt::String, _rt::String>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for RedoSignatureHttp {
                #[inline]
                fn clone(&self) -> RedoSignatureHttp {
                    RedoSignatureHttp {
                        target: ::core::clone::Clone::clone(&self.target),
                        returning: ::core::clone::Clone::clone(&self.returning),
                    }
                }
            }
            impl From<RedoSignatureHttp> for Vec<u8> {
                fn from(value: RedoSignatureHttp) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a RedoSignatureHttp> for Vec<u8> {
                fn from(value: &'a RedoSignatureHttp) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for RedoSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for RedoSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for RedoSignatureHttp {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "target" => _serde::__private::Ok(__Field::__field0),
                                    "returning" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"target" => _serde::__private::Ok(__Field::__field0),
                                    b"returning" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<RedoSignatureHttp>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = RedoSignatureHttp;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct RedoSignatureHttp",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct RedoSignatureHttp with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Result<_rt::String, _rt::String>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct RedoSignatureHttp with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(RedoSignatureHttp {
                                    target: __field0,
                                    returning: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    Result<_rt::String, _rt::String>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("target"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "returning",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Result<_rt::String, _rt::String>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("target")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("returning")?
                                    }
                                };
                                _serde::__private::Ok(RedoSignatureHttp {
                                    target: __field0,
                                    returning: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["target", "returning"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "RedoSignatureHttp",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<RedoSignatureHttp>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for RedoSignatureHttp {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "RedoSignatureHttp",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "target",
                            &self.target,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "returning",
                            &self.returning,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for RedoSignatureHttp {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("RedoSignatureHttp")
                        .field("target", &self.target)
                        .field("returning", &self.returning)
                        .finish()
                }
            }
            /// Function signature for: reorder-line-items (http)
            /// HTTP: POST /api/reorder-line-items
            pub struct ReorderLineItemsSignatureHttp {
                pub target: _rt::String,
                pub request_body: _rt::String,
                pub returning: Result<_rt::String, _rt::String>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for ReorderLineItemsSignatureHttp {
                #[inline]
                fn clone(&self) -> ReorderLineItemsSignatureHttp {
                    ReorderLineItemsSignatureHttp {
                        target: ::core::clone::Clone::clone(&self.target),
                        request_body: ::core::clone::Clone::clone(&self.request_body),
                        returning: ::core::clone::Clone::clone(&self.returning),
                    }
                }
            }
            impl From<ReorderLineItemsSignatureHttp> for Vec<u8> {
                fn from(value: ReorderLineItemsSignatureHttp) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a ReorderLineItemsSignatureHttp> for Vec<u8> {
                fn from(value: &'a ReorderLineItemsSignatureHttp) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for ReorderLineItemsSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for ReorderLineItemsSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for ReorderLineItemsSignatureHttp {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "target" => _serde::__private::Ok(__Field::__field0),
                                    "request_body" => _serde::__private::Ok(__Field::__field1),
                                    "returning" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"target" => _serde::__private::Ok(__Field::__field0),
                                    b"request_body" => _serde::__private::Ok(__Field::__field1),
                                    b"returning" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<
                                ReorderLineItemsSignatureHttp,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = ReorderLineItemsSignatureHttp;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct ReorderLineItemsSignatureHttp",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct ReorderLineItemsSignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct ReorderLineItemsSignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    Result<_rt::String, _rt::String>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct ReorderLineItemsSignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(ReorderLineItemsSignatureHttp {
                                    target: __field0,
                                    request_body: __field1,
                                    returning: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<
                                    Result<_rt::String, _rt::String>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("target"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "request_body",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "returning",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Result<_rt::String, _rt::String>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("target")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("request_body")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("returning")?
                                    }
                                };
                                _serde::__private::Ok(ReorderLineItemsSignatureHttp {
                                    target: __field0,
                                    request_body: __field1,
                                    returning: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "target",
                            "request_body",
                            "returning",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "ReorderLineItemsSignatureHttp",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    ReorderLineItemsSignatureHttp,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for ReorderLineItemsSignatureHttp {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "ReorderLineItemsSignatureHttp",
                            false as usize + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "target",
                            &self.target,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "request_body",
                            &self.request_body,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "returning",
                            &self.returning,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for ReorderLineItemsSignatureHttp {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("ReorderLineItemsSignatureHttp")
                        .field("target", &self.target)
                        .field("request-body", &self.request_body)
                        .field("returning", &self.returning)
                        .finish()
                }
            }
            /// Function signature for: undo (http)
            /// HTTP: POST /api/undo
            pub struct UndoSignatureHttp {
                pub target: _rt::String,
                pub returning: Result<_rt::String, _rt::String>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for UndoSignatureHttp {
                #[inline]
                fn clone(&self) -> UndoSignatureHttp {
                    UndoSignatureHttp {
                        target: ::core::clone::Clone::clone(&self.target),
                        returning: ::core::clone::Clone::clone(&self.returning),
                    }
                }
            }
            impl From<UndoSignatureHttp> for Vec<u8> {
                fn from(value: UndoSignatureHttp) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a UndoSignatureHttp> for Vec<u8> {
                fn from(value: &'a UndoSignatureHttp) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for UndoSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for UndoSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for UndoSignatureHttp {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "target" => _serde::__private::Ok(__Field::__field0),
                                    "returning" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"target" => _serde::__private::Ok(__Field::__field0),
                                    b"returning" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<UndoSignatureHttp>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = UndoSignatureHttp;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct UndoSignatureHttp",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct UndoSignatureHttp with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    Result<_rt::String, _rt::String>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct UndoSignatureHttp with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(UndoSignatureHttp {
                                    target: __field0,
                                    returning: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<
                                    Result<_rt::String, _rt::String>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("target"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "returning",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Result<_rt::String, _rt::String>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("target")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("returning")?
                                    }
                                };
                                _serde::__private::Ok(UndoSignatureHttp {
                                    target: __field0,
                                    returning: __field1,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &["target", "returning"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "UndoSignatureHttp",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<UndoSignatureHttp>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for UndoSignatureHttp {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "UndoSignatureHttp",
                            false as usize + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "target",
                            &self.target,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "returning",
                            &self.returning,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for UndoSignatureHttp {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("UndoSignatureHttp")
                        .field("target", &self.target)
                        .field("returning", &self.returning)
                        .finish()
                }
            }
            /// Function signature for: update-invoice (http)
            /// HTTP: POST /api/update-invoice
            pub struct UpdateInvoiceSignatureHttp {
                pub target: _rt::String,
                pub request_body: _rt::String,
                pub returning: Result<_rt::String, _rt::String>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for UpdateInvoiceSignatureHttp {
                #[inline]
                fn clone(&self) -> UpdateInvoiceSignatureHttp {
                    UpdateInvoiceSignatureHttp {
                        target: ::core::clone::Clone::clone(&self.target),
                        request_body: ::core::clone::Clone::clone(&self.request_body),
                        returning: ::core::clone::Clone::clone(&self.returning),
                    }
                }
            }
            impl From<UpdateInvoiceSignatureHttp> for Vec<u8> {
                fn from(value: UpdateInvoiceSignatureHttp) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a UpdateInvoiceSignatureHttp> for Vec<u8> {
                fn from(value: &'a UpdateInvoiceSignatureHttp) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for UpdateInvoiceSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for UpdateInvoiceSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for UpdateInvoiceSignatureHttp {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "target" => _serde::__private::Ok(__Field::__field0),
                                    "request_body" => _serde::__private::Ok(__Field::__field1),
                                    "returning" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"target" => _serde::__private::Ok(__Field::__field0),
                                    b"request_body" => _serde::__private::Ok(__Field::__field1),
                                    b"returning" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<
                                UpdateInvoiceSignatureHttp,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = UpdateInvoiceSignatureHttp;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct UpdateInvoiceSignatureHttp",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct UpdateInvoiceSignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct UpdateInvoiceSignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    Result<_rt::String, _rt::String>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct UpdateInvoiceSignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(UpdateInvoiceSignatureHttp {
                                    target: __field0,
                                    request_body: __field1,
                                    returning: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<
                                    Result<_rt::String, _rt::String>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("target"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "request_body",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "returning",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Result<_rt::String, _rt::String>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("target")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("request_body")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("returning")?
                                    }
                                };
                                _serde::__private::Ok(UpdateInvoiceSignatureHttp {
                                    target: __field0,
                                    request_body: __field1,
                                    returning: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "target",
                            "request_body",
                            "returning",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "UpdateInvoiceSignatureHttp",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    UpdateInvoiceSignatureHttp,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for UpdateInvoiceSignatureHttp {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "UpdateInvoiceSignatureHttp",
                            false as usize + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "target",
                            &self.target,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "request_body",
                            &self.request_body,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "returning",
                            &self.returning,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for UpdateInvoiceSignatureHttp {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("UpdateInvoiceSignatureHttp")
                        .field("target", &self.target)
                        .field("request-body", &self.request_body)
                        .field("returning", &self.returning)
                        .finish()
                }
            }
            /// Function signature for: update-line-item (http)
            /// HTTP: POST /api/update-line-item
            pub struct UpdateLineItemSignatureHttp {
                pub target: _rt::String,
                pub request_body: _rt::String,
                pub returning: Result<_rt::String, _rt::String>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for UpdateLineItemSignatureHttp {
                #[inline]
                fn clone(&self) -> UpdateLineItemSignatureHttp {
                    UpdateLineItemSignatureHttp {
                        target: ::core::clone::Clone::clone(&self.target),
                        request_body: ::core::clone::Clone::clone(&self.request_body),
                        returning: ::core::clone::Clone::clone(&self.returning),
                    }
                }
            }
            impl From<UpdateLineItemSignatureHttp> for Vec<u8> {
                fn from(value: UpdateLineItemSignatureHttp) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a UpdateLineItemSignatureHttp> for Vec<u8> {
                fn from(value: &'a UpdateLineItemSignatureHttp) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for UpdateLineItemSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for UpdateLineItemSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for UpdateLineItemSignatureHttp {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "target" => _serde::__private::Ok(__Field::__field0),
                                    "request_body" => _serde::__private::Ok(__Field::__field1),
                                    "returning" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"target" => _serde::__private::Ok(__Field::__field0),
                                    b"request_body" => _serde::__private::Ok(__Field::__field1),
                                    b"returning" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<
                                UpdateLineItemSignatureHttp,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = UpdateLineItemSignatureHttp;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct UpdateLineItemSignatureHttp",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct UpdateLineItemSignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct UpdateLineItemSignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    Result<_rt::String, _rt::String>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct UpdateLineItemSignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(UpdateLineItemSignatureHttp {
                                    target: __field0,
                                    request_body: __field1,
                                    returning: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<
                                    Result<_rt::String, _rt::String>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("target"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "request_body",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "returning",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Result<_rt::String, _rt::String>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("target")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("request_body")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("returning")?
                                    }
                                };
                                _serde::__private::Ok(UpdateLineItemSignatureHttp {
                                    target: __field0,
                                    request_body: __field1,
                                    returning: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "target",
                            "request_body",
                            "returning",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "UpdateLineItemSignatureHttp",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    UpdateLineItemSignatureHttp,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for UpdateLineItemSignatureHttp {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "UpdateLineItemSignatureHttp",
                            false as usize + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "target",
                            &self.target,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "request_body",
                            &self.request_body,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "returning",
                            &self.returning,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for UpdateLineItemSignatureHttp {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("UpdateLineItemSignatureHttp")
                        .field("target", &self.target)
                        .field("request-body", &self.request_body)
                        .field("returning", &self.returning)
                        .finish()
                }
            }
            /// Function signature for: update-settings (http)
            /// HTTP: POST /api/update-settings
            pub struct UpdateSettingsSignatureHttp {
                pub target: _rt::String,
                pub request_body: _rt::String,
                pub returning: Result<_rt::String, _rt::String>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for UpdateSettingsSignatureHttp {
                #[inline]
                fn clone(&self) -> UpdateSettingsSignatureHttp {
                    UpdateSettingsSignatureHttp {
                        target: ::core::clone::Clone::clone(&self.target),
                        request_body: ::core::clone::Clone::clone(&self.request_body),
                        returning: ::core::clone::Clone::clone(&self.returning),
                    }
                }
            }
            impl From<UpdateSettingsSignatureHttp> for Vec<u8> {
                fn from(value: UpdateSettingsSignatureHttp) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a UpdateSettingsSignatureHttp> for Vec<u8> {
                fn from(value: &'a UpdateSettingsSignatureHttp) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for UpdateSettingsSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for UpdateSettingsSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for UpdateSettingsSignatureHttp {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "target" => _serde::__private::Ok(__Field::__field0),
                                    "request_body" => _serde::__private::Ok(__Field::__field1),
                                    "returning" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"target" => _serde::__private::Ok(__Field::__field0),
                                    b"request_body" => _serde::__private::Ok(__Field::__field1),
                                    b"returning" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<
                                UpdateSettingsSignatureHttp,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = UpdateSettingsSignatureHttp;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct UpdateSettingsSignatureHttp",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct UpdateSettingsSignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct UpdateSettingsSignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    Result<_rt::String, _rt::String>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct UpdateSettingsSignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(UpdateSettingsSignatureHttp {
                                    target: __field0,
                                    request_body: __field1,
                                    returning: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<
                                    Result<_rt::String, _rt::String>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("target"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "request_body",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "returning",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Result<_rt::String, _rt::String>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("target")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("request_body")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("returning")?
                                    }
                                };
                                _serde::__private::Ok(UpdateSettingsSignatureHttp {
                                    target: __field0,
                                    request_body: __field1,
                                    returning: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "target",
                            "request_body",
                            "returning",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "UpdateSettingsSignatureHttp",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    UpdateSettingsSignatureHttp,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for UpdateSettingsSignatureHttp {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "UpdateSettingsSignatureHttp",
                            false as usize + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "target",
                            &self.target,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "request_body",
                            &self.request_body,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "returning",
                            &self.returning,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for UpdateSettingsSignatureHttp {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("UpdateSettingsSignatureHttp")
                        .field("target", &self.target)
                        .field("request-body", &self.request_body)
                        .field("returning", &self.returning)
                        .finish()
                }
            }
            /// Function signature for: upload-logo (http)
            /// HTTP: POST /api/upload-logo
            pub struct UploadLogoSignatureHttp {
                pub target: _rt::String,
                pub request_body: _rt::Vec<u8>,
                pub returning: Result<_rt::String, _rt::String>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for UploadLogoSignatureHttp {
                #[inline]
                fn clone(&self) -> UploadLogoSignatureHttp {
                    UploadLogoSignatureHttp {
                        target: ::core::clone::Clone::clone(&self.target),
                        request_body: ::core::clone::Clone::clone(&self.request_body),
                        returning: ::core::clone::Clone::clone(&self.returning),
                    }
                }
            }
            impl From<UploadLogoSignatureHttp> for Vec<u8> {
                fn from(value: UploadLogoSignatureHttp) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a UploadLogoSignatureHttp> for Vec<u8> {
                fn from(value: &'a UploadLogoSignatureHttp) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for UploadLogoSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for UploadLogoSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for UploadLogoSignatureHttp {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "target" => _serde::__private::Ok(__Field::__field0),
                                    "request_body" => _serde::__private::Ok(__Field::__field1),
                                    "returning" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"target" => _serde::__private::Ok(__Field::__field0),
                                    b"request_body" => _serde::__private::Ok(__Field::__field1),
                                    b"returning" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<
                                UploadLogoSignatureHttp,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = UploadLogoSignatureHttp;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct UploadLogoSignatureHttp",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct UploadLogoSignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    _rt::Vec<u8>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct UploadLogoSignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    Result<_rt::String, _rt::String>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct UploadLogoSignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(UploadLogoSignatureHttp {
                                    target: __field0,
                                    request_body: __field1,
                                    returning: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<_rt::Vec<u8>> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<
                                    Result<_rt::String, _rt::String>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("target"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "request_body",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::Vec<u8>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "returning",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Result<_rt::String, _rt::String>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("target")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("request_body")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("returning")?
                                    }
                                };
                                _serde::__private::Ok(UploadLogoSignatureHttp {
                                    target: __field0,
                                    request_body: __field1,
                                    returning: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "target",
                            "request_body",
                            "returning",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "UploadLogoSignatureHttp",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    UploadLogoSignatureHttp,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for UploadLogoSignatureHttp {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "UploadLogoSignatureHttp",
                            false as usize + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "target",
                            &self.target,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "request_body",
                            &self.request_body,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "returning",
                            &self.returning,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for UploadLogoSignatureHttp {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("UploadLogoSignatureHttp")
                        .field("target", &self.target)
                        .field("request-body", &self.request_body)
                        .field("returning", &self.returning)
                        .finish()
                }
            }
            /// Function signature for: upload-payment-image (http)
            /// HTTP: POST /api/upload-payment-image
            pub struct UploadPaymentImageSignatureHttp {
                pub target: _rt::String,
                pub request_body: _rt::Vec<u8>,
                pub returning: Result<_rt::String, _rt::String>,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for UploadPaymentImageSignatureHttp {
                #[inline]
                fn clone(&self) -> UploadPaymentImageSignatureHttp {
                    UploadPaymentImageSignatureHttp {
                        target: ::core::clone::Clone::clone(&self.target),
                        request_body: ::core::clone::Clone::clone(&self.request_body),
                        returning: ::core::clone::Clone::clone(&self.returning),
                    }
                }
            }
            impl From<UploadPaymentImageSignatureHttp> for Vec<u8> {
                fn from(value: UploadPaymentImageSignatureHttp) -> Self {
                    serde_json::to_vec(&value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl<'a> From<&'a UploadPaymentImageSignatureHttp> for Vec<u8> {
                fn from(value: &'a UploadPaymentImageSignatureHttp) -> Self {
                    serde_json::to_vec(value).expect("Failed to serialize to Vec<u8>")
                }
            }
            impl TryFrom<Vec<u8>> for UploadPaymentImageSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: Vec<u8>) -> Result<Self, Self::Error> {
                    serde_json::from_slice(&value)
                }
            }
            impl TryFrom<&[u8]> for UploadPaymentImageSignatureHttp {
                type Error = serde_json::Error;
                fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
                    serde_json::from_slice(value)
                }
            }
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for UploadPaymentImageSignatureHttp {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        #[doc(hidden)]
                        struct __FieldVisitor;
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "target" => _serde::__private::Ok(__Field::__field0),
                                    "request_body" => _serde::__private::Ok(__Field::__field1),
                                    "returning" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"target" => _serde::__private::Ok(__Field::__field0),
                                    b"request_body" => _serde::__private::Ok(__Field::__field1),
                                    b"returning" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        #[doc(hidden)]
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<
                                UploadPaymentImageSignatureHttp,
                            >,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        #[automatically_derived]
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = UploadPaymentImageSignatureHttp;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct UploadPaymentImageSignatureHttp",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match _serde::de::SeqAccess::next_element::<
                                    _rt::String,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct UploadPaymentImageSignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match _serde::de::SeqAccess::next_element::<
                                    _rt::Vec<u8>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct UploadPaymentImageSignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field2 = match _serde::de::SeqAccess::next_element::<
                                    Result<_rt::String, _rt::String>,
                                >(&mut __seq)? {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                2usize,
                                                &"struct UploadPaymentImageSignatureHttp with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(UploadPaymentImageSignatureHttp {
                                    target: __field0,
                                    request_body: __field1,
                                    returning: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<_rt::String> = _serde::__private::None;
                                let mut __field1: _serde::__private::Option<_rt::Vec<u8>> = _serde::__private::None;
                                let mut __field2: _serde::__private::Option<
                                    Result<_rt::String, _rt::String>,
                                > = _serde::__private::None;
                                while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                    __Field,
                                >(&mut __map)? {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field("target"),
                                                );
                                            }
                                            __field0 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::String,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "request_body",
                                                    ),
                                                );
                                            }
                                            __field1 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    _rt::Vec<u8>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde::__private::Err(
                                                    <__A::Error as _serde::de::Error>::duplicate_field(
                                                        "returning",
                                                    ),
                                                );
                                            }
                                            __field2 = _serde::__private::Some(
                                                _serde::de::MapAccess::next_value::<
                                                    Result<_rt::String, _rt::String>,
                                                >(&mut __map)?,
                                            );
                                        }
                                        _ => {
                                            let _ = _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(&mut __map)?;
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("target")?
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("request_body")?
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        _serde::__private::de::missing_field("returning")?
                                    }
                                };
                                _serde::__private::Ok(UploadPaymentImageSignatureHttp {
                                    target: __field0,
                                    request_body: __field1,
                                    returning: __field2,
                                })
                            }
                        }
                        #[doc(hidden)]
                        const FIELDS: &'static [&'static str] = &[
                            "target",
                            "request_body",
                            "returning",
                        ];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "UploadPaymentImageSignatureHttp",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<
                                    UploadPaymentImageSignatureHttp,
                                >,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[doc(hidden)]
            #[allow(
                non_upper_case_globals,
                unused_attributes,
                unused_qualifications,
                clippy::absolute_paths,
            )]
            const _: () = {
                #[allow(unused_extern_crates, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for UploadPaymentImageSignatureHttp {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = _serde::Serializer::serialize_struct(
                            __serializer,
                            "UploadPaymentImageSignatureHttp",
                            false as usize + 1 + 1 + 1,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "target",
                            &self.target,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "request_body",
                            &self.request_body,
                        )?;
                        _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "returning",
                            &self.returning,
                        )?;
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            impl ::core::fmt::Debug for UploadPaymentImageSignatureHttp {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("UploadPaymentImageSignatureHttp")
                        .field("target", &self.target)
                        .field("request-body", &self.request_body)
                        .field("returning", &self.returning)
                        .finish()
                }
            }
        }
    }
}
mod _rt {
    pub use alloc_crate::string::String;
    pub use alloc_crate::vec::Vec;
    pub fn as_i32<T: AsI32>(t: T) -> i32 {
        t.as_i32()
    }
    pub trait AsI32 {
        fn as_i32(self) -> i32;
    }
    impl<'a, T: Copy + AsI32> AsI32 for &'a T {
        fn as_i32(self) -> i32 {
            (*self).as_i32()
        }
    }
    impl AsI32 for i32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for char {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for usize {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if true {
            String::from_utf8(bytes).unwrap()
        } else {
            String::from_utf8_unchecked(bytes)
        }
    }
    pub unsafe fn bool_lift(val: u8) -> bool {
        if true {
            match val {
                0 => false,
                1 => true,
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!("invalid bool discriminant"),
                    );
                }
            }
        } else {
            val != 0
        }
    }
    pub unsafe fn invalid_enum_discriminant<T>() -> T {
        if true {
            {
                ::core::panicking::panic_fmt(format_args!("invalid enum discriminant"));
            }
        } else {
            core::hint::unreachable_unchecked()
        }
    }
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        let layout = alloc::Layout::from_size_align_unchecked(size, align);
        alloc::dealloc(ptr, layout);
    }
    pub fn as_i64<T: AsI64>(t: T) -> i64 {
        t.as_i64()
    }
    pub trait AsI64 {
        fn as_i64(self) -> i64;
    }
    impl<'a, T: Copy + AsI64> AsI64 for &'a T {
        fn as_i64(self) -> i64 {
            (*self).as_i64()
        }
    }
    impl AsI64 for i64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    impl AsI64 for u64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    pub use alloc_crate::alloc;
    extern crate alloc as alloc_crate;
}
#[doc(inline)]
pub(crate) use __export_invoice_os_v0_impl as export;
#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen::rt::maybe_link_cabi_realloc();
}
const _: &[u8] = b"world invoice-os-v0 {\n    import app;\n    include process-v1;\n}";
const _: &[u8] = b"world types-invoice-os-v0 {\n    import app;\n    include lib;\n}";
const _: &[u8] = b"package hyperware:process@1.0.0;\n\ninterface standard {\n\n    //     \xcb\x97\xcb\x8f\xcb\x8b \xe2\x99\xa1 \xcb\x8e\xcb\x8a\xcb\x97\n    //    System Types\n    //     \xcb\x97\xcb\x8f\xcb\x8b \xe2\x99\xa1 \xcb\x8e\xcb\x8a\xcb\x97\n\n    /// JSON is passed over Wasm boundary as a string.\n    type json = string;\n\n    /// In types passed from kernel, node-id will be a valid Kimap entry.\n    type node-id = string;\n\n    /// Context, like a message body, is a protocol-defined serialized byte\n    /// array. It is used when building a Request to save information that\n    /// will not be part of a Response, in order to more easily handle\n    /// (\"contextualize\") that Response.\n    type context = list<u8>;\n\n    record process-id {\n        process-name: string,\n        package-name: string,\n        publisher-node: node-id,\n    }\n\n    record package-id {\n        package-name: string,\n        publisher-node: node-id,\n    }\n\n    record address {\n        node: node-id,\n        process: process-id,\n    }\n\n    record lazy-load-blob {\n        mime: option<string>,\n        bytes: list<u8>,\n    }\n\n    record request {\n        // set in order to inherit lazy-load-blob from parent message, and if\n        // expects-response is none, direct response to source of parent.\n        // also carries forward certain aspects of parent message in kernel,\n        // see documentation for formal spec and examples:\n        // https://docs.rs/hyperware_process_lib/latest/hyperware_process_lib/struct.Request.html\n        inherit: bool,\n        // if some, request expects a response in the given number of seconds\n        expects-response: option<u64>,\n        body: list<u8>,\n        metadata: option<json>,\n        capabilities: list<capability>,\n        // to grab lazy-load-blob, use get_blob()\n    }\n\n    record response {\n        inherit: bool,\n        body: list<u8>,\n        metadata: option<json>,\n        capabilities: list<capability>,\n        // to grab lazy-load-blob, use get_blob()\n    }\n\n    /// A message can be a request or a response. Within a response, there is\n    /// a result which surfaces any error that happened because of a request.\n    /// A successful response will contain the context of the request it\n    /// matches, if any was set.\n    variant message {\n        request(request),\n        response(tuple<response, option<context>>),\n    }\n\n    record capability {\n        issuer: address,\n        params: json,\n    }\n\n    /// On-exit is a setting that determines what happens when a process\n    /// panics, completes, or otherwise \"ends\".\n    /// NOTE: requests will always have expects-response set to false by kernel.\n    variant on-exit {\n        none,\n        restart,\n        requests(list<tuple<address, request, option<lazy-load-blob>>>),\n    }\n\n    /// Send errors come from trying to send a message to another process,\n    /// either locally or on another node.\n    /// A message can fail by timing out, or by the node being entirely\n    /// unreachable (offline or can\'t be found in PKI). In either case,\n    /// the message is not delivered and the process that sent it receives\n    /// that message back along with any assigned context and/or lazy-load-blob,\n    /// and is free to handle it as it sees fit.\n    /// In the local case, only timeout errors are possible and also cover the case\n    /// in which a process is not running or does not exist.\n    record send-error {\n        kind: send-error-kind,\n        target: address,\n        message: message,\n        lazy-load-blob: option<lazy-load-blob>,\n    }\n\n    enum send-error-kind {\n        offline,\n        timeout,\n    }\n\n    enum spawn-error {\n        name-taken,\n        no-file-at-path,\n    }\n\n    //     \xcb\x97\xcb\x8f\xcb\x8b \xe2\x99\xa1 \xcb\x8e\xcb\x8a\xcb\x97\n    //    System Utils\n    //     \xcb\x97\xcb\x8f\xcb\x8b \xe2\x99\xa1 \xcb\x8e\xcb\x8a\xcb\x97\n\n    /// Prints to the terminal at a given verbosity level.\n    /// Higher verbosity levels print more information.\n    /// Level 0 is always printed -- use sparingly.\n    print-to-terminal: func(verbosity: u8, message: string);\n\n    /// Returns the address of the process.\n    our: func() -> address;\n\n    //        \xcb\x97\xcb\x8f\xcb\x8b \xe2\x99\xa1 \xcb\x8e\xcb\x8a\xcb\x97\n    //    Process Management\n    //        \xcb\x97\xcb\x8f\xcb\x8b \xe2\x99\xa1 \xcb\x8e\xcb\x8a\xcb\x97\n\n    get-on-exit: func() -> on-exit;\n\n    set-on-exit: func(on-exit: on-exit);\n\n    get-state: func() -> option<list<u8>>;\n\n    set-state: func(bytes: list<u8>);\n\n    clear-state: func();\n\n    spawn: func(\n        // name is optional. if not provided, name will be a random u64.\n        name: option<string>,\n        // wasm-path must be located within package\'s drive\n        wasm-path: string,\n        on-exit: on-exit,\n        // requested capabilities must be owned by the caller\n        request-capabilities: list<capability>,\n        // granted capabilities will be generated by the child process\n        // and handed out to the indicated process-id.\n        grant-capabilities: list<tuple<process-id, json>>,\n        public: bool\n    ) -> result<process-id, spawn-error>;\n\n    //           \xcb\x97\xcb\x8f\xcb\x8b \xe2\x99\xa1 \xcb\x8e\xcb\x8a\xcb\x97\n    //    Capabilities Management\n    //           \xcb\x97\xcb\x8f\xcb\x8b \xe2\x99\xa1 \xcb\x8e\xcb\x8a\xcb\x97\n\n    /// Saves the capabilities to persisted process state.\n    save-capabilities: func(caps: list<capability>);\n\n    /// Deletes the capabilities from persisted process state.\n    drop-capabilities: func(caps: list<capability>);\n\n    /// Gets all capabilities from persisted process state.\n    our-capabilities: func() -> list<capability>;\n\n    //     \xcb\x97\xcb\x8f\xcb\x8b \xe2\x99\xa1 \xcb\x8e\xcb\x8a\xcb\x97\n    //    Message I/O\n    //     \xcb\x97\xcb\x8f\xcb\x8b \xe2\x99\xa1 \xcb\x8e\xcb\x8a\xcb\x97\n\n    /// Ingest next message when it arrives along with its source.\n    /// Almost all long-running processes will call this in a loop.\n    receive: func() ->\n        result<tuple<address, message>, tuple<send-error, option<context>>>;\n\n    /// Returns whether or not the current message has a blob.\n    has-blob: func() -> bool;\n\n    /// Returns the blob of the current message, if any.\n    get-blob: func() -> option<lazy-load-blob>;\n\n    /// Returns the last blob this process received.\n    last-blob: func() -> option<lazy-load-blob>;\n\n    /// Send request to target.\n    send-request: func(\n        target: address,\n        request: request,\n        context: option<context>,\n        lazy-load-blob: option<lazy-load-blob>\n    );\n\n    /// Send requests to targets.\n    send-requests: func(\n        requests: list<tuple<address,\n                             request,\n                             option<context>,\n                             option<lazy-load-blob>>>\n    );\n\n    /// Send response to the request currently being handled.\n    send-response: func(\n        response: response,\n        lazy-load-blob: option<lazy-load-blob>\n    );\n\n    /// Send a single request, then block (internally) until its response. The\n    /// type returned is Message but will always contain Response.\n    send-and-await-response: func(\n        target: address,\n        request: request,\n        lazy-load-blob: option<lazy-load-blob>\n    ) -> result<tuple<address, message>, send-error>;\n}\n\nworld lib {\n    import standard;\n}\n\nworld process-v1 {\n    include lib;\n\n    export init: func(our: string);\n}\n";
const _: &[u8] = b"interface app {\nuse standard.{address};\n\n    // Function signature for: add-line-item (http)\n    // HTTP: POST /api/add-line-item\n    record add-line-item-signature-http {\n        target: string,\n        returning: result<string, string>\n    }\n\n    // Function signature for: can-redo (http)\n    // HTTP: POST /api/can-redo\n    record can-redo-signature-http {\n        target: string,\n        returning: result<bool, string>\n    }\n\n    // Function signature for: can-undo (http)\n    // HTTP: POST /api/can-undo\n    record can-undo-signature-http {\n        target: string,\n        returning: result<bool, string>\n    }\n\n    // Function signature for: check-autosave (http)\n    // HTTP: POST /api/check-autosave\n    record check-autosave-signature-http {\n        target: string,\n        returning: result<string, string>\n    }\n\n    // Function signature for: create-invoice (http)\n    // HTTP: POST /api/create-invoice\n    record create-invoice-signature-http {\n        target: string,\n        returning: result<string, string>\n    }\n\n    // Function signature for: delete-invoice (http)\n    // HTTP: POST /api/delete-invoice\n    record delete-invoice-signature-http {\n        target: string,\n        request-body: string,\n        returning: result<string, string>\n    }\n\n    // Function signature for: delete-line-item (http)\n    // HTTP: POST /api/delete-line-item\n    record delete-line-item-signature-http {\n        target: string,\n        request-body: string,\n        returning: result<string, string>\n    }\n\n    // Function signature for: generate-pdf (http)\n    // HTTP: POST /api/generate-pdf\n    record generate-pdf-signature-http {\n        target: string,\n        returning: result<string, string>\n    }\n\n    // Function signature for: get-invoice (http)\n    // HTTP: POST /api/get-invoice\n    record get-invoice-signature-http {\n        target: string,\n        request-body: string,\n        returning: result<string, string>\n    }\n\n    // Function signature for: get-settings (http)\n    // HTTP: POST /api/get-settings\n    record get-settings-signature-http {\n        target: string,\n        returning: result<string, string>\n    }\n\n    // Function signature for: list-invoices (http)\n    // HTTP: POST /api/list-invoices\n    record list-invoices-signature-http {\n        target: string,\n        returning: result<string, string>\n    }\n\n    // Function signature for: redo (http)\n    // HTTP: POST /api/redo\n    record redo-signature-http {\n        target: string,\n        returning: result<string, string>\n    }\n\n    // Function signature for: reorder-line-items (http)\n    // HTTP: POST /api/reorder-line-items\n    record reorder-line-items-signature-http {\n        target: string,\n        request-body: string,\n        returning: result<string, string>\n    }\n\n    // Function signature for: undo (http)\n    // HTTP: POST /api/undo\n    record undo-signature-http {\n        target: string,\n        returning: result<string, string>\n    }\n\n    // Function signature for: update-invoice (http)\n    // HTTP: POST /api/update-invoice\n    record update-invoice-signature-http {\n        target: string,\n        request-body: string,\n        returning: result<string, string>\n    }\n\n    // Function signature for: update-line-item (http)\n    // HTTP: POST /api/update-line-item\n    record update-line-item-signature-http {\n        target: string,\n        request-body: string,\n        returning: result<string, string>\n    }\n\n    // Function signature for: update-settings (http)\n    // HTTP: POST /api/update-settings\n    record update-settings-signature-http {\n        target: string,\n        request-body: string,\n        returning: result<string, string>\n    }\n\n    // Function signature for: upload-logo (http)\n    // HTTP: POST /api/upload-logo\n    record upload-logo-signature-http {\n        target: string,\n        request-body: list<u8>,\n        returning: result<string, string>\n    }\n\n    // Function signature for: upload-payment-image (http)\n    // HTTP: POST /api/upload-payment-image\n    record upload-payment-image-signature-http {\n        target: string,\n        request-body: list<u8>,\n        returning: result<string, string>\n    }\n}\n";
use hyperware_app_common::hyperware_process_lib as hyperware_process_lib;
use hyperware_process_lib::http::server::HttpBindingConfig;
use hyperware_process_lib::http::server::WsBindingConfig;
use hyperware_app_common::Binding;
impl AppState {
    async fn initialize(&mut self) {
        add_to_homepage("Invoice", Some(""), Some("/"), None);
        let our_node = our().node.clone();
        {
            ::std::io::_print(
                format_args!("Invoice app initialized on node: {0}\n", our_node),
            );
        };
        let package_id = our().package_id();
        match create_drive(package_id, "invoice", Some(5)) {
            Ok(drive_path) => {
                {
                    ::std::io::_print(
                        format_args!("Created invoice drive at: {0}\n", drive_path),
                    );
                };
                let settings_path = ::alloc::__export::must_use({
                    let res = ::alloc::fmt::format(
                        format_args!("{0}/settings.json", drive_path),
                    );
                    res
                });
                match open_file(&settings_path, false, Some(5)) {
                    Ok(file) => {
                        match file.read_to_string() {
                            Ok(data) => {
                                if let Ok(settings) = serde_json::from_str::<
                                    InvoiceSettings,
                                >(&data) {
                                    self.settings = Some(settings);
                                    {
                                        ::std::io::_print(
                                            format_args!("Loaded existing settings\n"),
                                        );
                                    };
                                }
                            }
                            Err(_) => {
                                ::std::io::_print(
                                    format_args!("No existing settings found\n"),
                                );
                            }
                        }
                    }
                    Err(_) => {
                        ::std::io::_print(format_args!("No settings file found\n"));
                    }
                }
                self.load_invoice_summaries(&drive_path);
            }
            Err(e) => {
                {
                    ::std::io::_print(
                        format_args!("Failed to create invoice drive: {0:?}\n", e),
                    );
                };
            }
        }
    }
    async fn get_settings(&self) -> Result<String, String> {
        match &self.settings {
            Some(settings) => {
                serde_json::to_string(settings)
                    .map_err(|e| ::alloc::__export::must_use({
                        let res = ::alloc::fmt::format(
                            format_args!("Failed to serialize settings: {0}", e),
                        );
                        res
                    }))
            }
            None => Ok("null".to_string()),
        }
    }
    async fn update_settings(&mut self, request_body: String) -> Result<String, String> {
        let settings: InvoiceSettings = serde_json::from_str(&request_body)
            .map_err(|e| ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("Invalid settings: {0}", e));
                res
            }))?;
        self.settings = Some(settings.clone());
        let package_id = our().package_id();
        let drive_path = ::alloc::__export::must_use({
            let res = ::alloc::fmt::format(format_args!("/{0}/invoice", package_id));
            res
        });
        let settings_path = ::alloc::__export::must_use({
            let res = ::alloc::fmt::format(
                format_args!("{0}/settings.json", drive_path),
            );
            res
        });
        match create_file(&settings_path, Some(5)) {
            Ok(file) => {
                let data = serde_json::to_vec(&settings)
                    .map_err(|e| ::alloc::__export::must_use({
                        let res = ::alloc::fmt::format(
                            format_args!("Failed to serialize settings: {0}", e),
                        );
                        res
                    }))?;
                file.write(&data)
                    .map_err(|e| ::alloc::__export::must_use({
                        let res = ::alloc::fmt::format(
                            format_args!("Failed to write settings: {0}", e),
                        );
                        res
                    }))?;
                Ok("Settings updated".to_string())
            }
            Err(e) => {
                Err(
                    ::alloc::__export::must_use({
                        let res = ::alloc::fmt::format(
                            format_args!("Failed to create settings file: {0}", e),
                        );
                        res
                    }),
                )
            }
        }
    }
    async fn upload_logo(&mut self, request_body: Vec<u8>) -> Result<String, String> {
        let package_id = our().package_id();
        let drive_path = ::alloc::__export::must_use({
            let res = ::alloc::fmt::format(format_args!("/{0}/invoice", package_id));
            res
        });
        let logo_path = ::alloc::__export::must_use({
            let res = ::alloc::fmt::format(format_args!("{0}/logo.png", drive_path));
            res
        });
        match create_file(&logo_path, Some(5)) {
            Ok(file) => {
                file.write(&request_body)
                    .map_err(|e| ::alloc::__export::must_use({
                        let res = ::alloc::fmt::format(
                            format_args!("Failed to write logo: {0}", e),
                        );
                        res
                    }))?;
                Ok(logo_path)
            }
            Err(e) => {
                Err(
                    ::alloc::__export::must_use({
                        let res = ::alloc::fmt::format(
                            format_args!("Failed to create logo file: {0}", e),
                        );
                        res
                    }),
                )
            }
        }
    }
    async fn upload_payment_image(
        &mut self,
        request_body: Vec<u8>,
    ) -> Result<String, String> {
        let package_id = our().package_id();
        let drive_path = ::alloc::__export::must_use({
            let res = ::alloc::fmt::format(format_args!("/{0}/invoice", package_id));
            res
        });
        let payment_path = ::alloc::__export::must_use({
            let res = ::alloc::fmt::format(format_args!("{0}/payment.png", drive_path));
            res
        });
        match create_file(&payment_path, Some(5)) {
            Ok(file) => {
                file.write(&request_body)
                    .map_err(|e| ::alloc::__export::must_use({
                        let res = ::alloc::fmt::format(
                            format_args!("Failed to write payment image: {0}", e),
                        );
                        res
                    }))?;
                Ok(payment_path)
            }
            Err(e) => {
                Err(
                    ::alloc::__export::must_use({
                        let res = ::alloc::fmt::format(
                            format_args!("Failed to create payment image file: {0}", e),
                        );
                        res
                    }),
                )
            }
        }
    }
    async fn list_invoices(&self) -> Result<String, String> {
        let summaries: Vec<InvoiceSummary> = self.invoices.values().cloned().collect();
        serde_json::to_string(&summaries)
            .map_err(|e| ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("Failed to serialize invoices: {0}", e),
                );
                res
            }))
    }
    async fn create_invoice(&mut self) -> Result<String, String> {
        let timestamp = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_secs();
        let invoice_number = if let Some(ref mut settings) = self.settings {
            let number = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!(
                        "{0}{1:04}",
                        settings.invoice_number_prefix,
                        settings.next_invoice_number,
                    ),
                );
                res
            });
            settings.next_invoice_number += 1;
            number
        } else {
            ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("INV-{0:04}", self.invoices.len() + 1),
                );
                res
            })
        };
        let id = ::alloc::__export::must_use({
            let res = ::alloc::fmt::format(
                format_args!("{0}-{1}", timestamp, invoice_number),
            );
            res
        });
        let date = {
            let now = std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_secs();
            let days_since_epoch = now / 86400;
            let year = 1970 + (days_since_epoch / 365) as u32;
            let month = ((days_since_epoch % 365) / 30) as u32 + 1;
            let day = ((days_since_epoch % 365) % 30) as u32 + 1;
            ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0:04}-{1:02}-{2:02}", year, month, day),
                );
                res
            })
        };
        let invoice = Invoice {
            id: id.clone(),
            number: invoice_number.clone(),
            name: None,
            date: date.clone(),
            due_date: None,
            invoicer: self
                .settings
                .as_ref()
                .map(|s| s.invoicer.clone())
                .unwrap_or(ContactInfo {
                    name: String::new(),
                    company: None,
                    address: String::new(),
                    email: None,
                    phone: None,
                    logo_path: None,
                }),
            invoicee: self
                .settings
                .as_ref()
                .map(|s| s.invoicee.clone())
                .unwrap_or(ContactInfo {
                    name: String::new(),
                    company: None,
                    address: String::new(),
                    email: None,
                    phone: None,
                    logo_path: None,
                }),
            line_items: ::alloc::vec::Vec::new(),
            discount_percent: 0.0,
            tax_percent: 0.0,
            notes: None,
            payment_info: self.settings.as_ref().and_then(|s| s.payment_info.clone()),
            payment_image_path: self
                .settings
                .as_ref()
                .and_then(|s| s.payment_image_path.clone()),
            status: InvoiceStatus::Draft,
            created_at: timestamp,
            updated_at: timestamp,
        };
        self.current_invoice = Some(invoice.clone());
        self.has_unsaved_changes = true;
        let summary = InvoiceSummary {
            id: invoice.id.clone(),
            number: invoice.number.clone(),
            name: invoice.name.clone(),
            date: invoice.date.clone(),
            total: 0.0,
            status: invoice.status.clone(),
        };
        self.invoices.insert(invoice.id.clone(), summary);
        self.save_current_invoice()?;
        serde_json::to_string(&invoice)
            .map_err(|e| ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("Failed to serialize invoice: {0}", e),
                );
                res
            }))
    }
    async fn get_invoice(&mut self, request_body: String) -> Result<String, String> {
        let id: String = serde_json::from_str(&request_body)
            .map_err(|e| ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("Invalid invoice ID: {0}", e),
                );
                res
            }))?;
        if let Some(ref current) = self.current_invoice {
            if current.id == id {
                return serde_json::to_string(current)
                    .map_err(|e| ::alloc::__export::must_use({
                        let res = ::alloc::fmt::format(
                            format_args!("Failed to serialize invoice: {0}", e),
                        );
                        res
                    }));
            }
        }
        let package_id = our().package_id();
        let drive_path = ::alloc::__export::must_use({
            let res = ::alloc::fmt::format(format_args!("/{0}/invoice", package_id));
            res
        });
        match self.invoices.get(&id) {
            Some(summary) => {
                let date = &summary.date;
                let invoice_dir = if let Some(name) = &summary.name {
                    name.clone()
                } else {
                    summary.number.clone()
                };
                let invoice_path = ::alloc::__export::must_use({
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "{0}/{1}/{2}/invoice.json",
                            drive_path,
                            date,
                            invoice_dir,
                        ),
                    );
                    res
                });
                match open_file(&invoice_path, false, Some(5)) {
                    Ok(file) => {
                        match file.read_to_string() {
                            Ok(data) => {
                                let invoice: Invoice = serde_json::from_str(&data)
                                    .map_err(|e| ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("Failed to parse invoice: {0}", e),
                                        );
                                        res
                                    }))?;
                                self.current_invoice = Some(invoice.clone());
                                serde_json::to_string(&invoice)
                                    .map_err(|e| ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("Failed to serialize invoice: {0}", e),
                                        );
                                        res
                                    }))
                            }
                            Err(e) => {
                                Err(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("Failed to read invoice: {0}", e),
                                        );
                                        res
                                    }),
                                )
                            }
                        }
                    }
                    Err(e) => {
                        Err(
                            ::alloc::__export::must_use({
                                let res = ::alloc::fmt::format(
                                    format_args!("Invoice not found: {0}", e),
                                );
                                res
                            }),
                        )
                    }
                }
            }
            None => Err("Invoice not found".to_string()),
        }
    }
    async fn update_invoice(&mut self, request_body: String) -> Result<String, String> {
        let updates: Invoice = serde_json::from_str(&request_body)
            .map_err(|e| ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("Invalid invoice data: {0}", e),
                );
                res
            }))?;
        let timestamp = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_secs();
        if let Some(ref current) = self.current_invoice {
            if current.id == updates.id {
                let snapshot = InvoiceSnapshot {
                    invoice: current.clone(),
                    timestamp: current.updated_at,
                };
                self.undo_stack.push(snapshot);
                if self.undo_stack.len() > 50 {
                    self.undo_stack.remove(0);
                }
                self.redo_stack.clear();
            }
        }
        let mut updated_invoice = updates;
        updated_invoice.updated_at = timestamp;
        self.current_invoice = Some(updated_invoice.clone());
        self.has_unsaved_changes = true;
        let summary = InvoiceSummary {
            id: updated_invoice.id.clone(),
            number: updated_invoice.number.clone(),
            name: updated_invoice.name.clone(),
            date: updated_invoice.date.clone(),
            total: calculate_invoice_total(&updated_invoice),
            status: updated_invoice.status.clone(),
        };
        self.invoices.insert(updated_invoice.id.clone(), summary);
        self.last_save_time = timestamp;
        serde_json::to_string(&updated_invoice)
            .map_err(|e| ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("Failed to serialize invoice: {0}", e),
                );
                res
            }))
    }
    async fn delete_invoice(&mut self, request_body: String) -> Result<String, String> {
        let id: String = serde_json::from_str(&request_body)
            .map_err(|e| ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("Invalid invoice ID: {0}", e),
                );
                res
            }))?;
        if let Some(summary) = self.invoices.remove(&id) {
            let package_id = our().package_id();
            let drive_path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("/{0}/invoice", package_id));
                res
            });
            let invoice_dir = if let Some(name) = &summary.name {
                name.clone()
            } else {
                summary.number.clone()
            };
            let invoice_path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!(
                        "{0}/{1}/{2}/invoice.json",
                        drive_path,
                        summary.date,
                        invoice_dir,
                    ),
                );
                res
            });
            let _ = remove_file(&invoice_path, Some(5));
            if let Some(ref current) = self.current_invoice {
                if current.id == id {
                    self.current_invoice = None;
                }
            }
            Ok("Invoice deleted".to_string())
        } else {
            Err("Invoice not found".to_string())
        }
    }
    async fn add_line_item(&mut self) -> Result<String, String> {
        if let Some(ref mut invoice) = self.current_invoice {
            let snapshot = InvoiceSnapshot {
                invoice: invoice.clone(),
                timestamp: invoice.updated_at,
            };
            self.undo_stack.push(snapshot);
            if self.undo_stack.len() > 50 {
                self.undo_stack.remove(0);
            }
            self.redo_stack.clear();
            let id = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!(
                        "item-{0}",
                        std::time::SystemTime::now()
                            .duration_since(std::time::UNIX_EPOCH)
                            .unwrap()
                            .as_millis(),
                    ),
                );
                res
            });
            let new_item = LineItem {
                id,
                description: String::new(),
                quantity: 1.0,
                rate: 0.0,
                discount_percent: 0.0,
            };
            invoice.line_items.push(new_item);
            invoice.updated_at = std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_secs();
            self.has_unsaved_changes = true;
            let total = calculate_invoice_total(&invoice.clone());
            let summary = InvoiceSummary {
                id: invoice.id.clone(),
                number: invoice.number.clone(),
                name: invoice.name.clone(),
                date: invoice.date.clone(),
                total,
                status: invoice.status.clone(),
            };
            self.invoices.insert(invoice.id.clone(), summary);
            serde_json::to_string(invoice)
                .map_err(|e| ::alloc::__export::must_use({
                    let res = ::alloc::fmt::format(
                        format_args!("Failed to serialize invoice: {0}", e),
                    );
                    res
                }))
        } else {
            Err("No invoice currently loaded".to_string())
        }
    }
    async fn update_line_item(
        &mut self,
        request_body: String,
    ) -> Result<String, String> {
        struct UpdateLineItemRequest {
            item_id: String,
            updates: LineItem,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for UpdateLineItemRequest {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "item_id" => _serde::__private::Ok(__Field::__field0),
                                "updates" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"item_id" => _serde::__private::Ok(__Field::__field0),
                                b"updates" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<UpdateLineItemRequest>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = UpdateLineItemRequest;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct UpdateLineItemRequest",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct UpdateLineItemRequest with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                LineItem,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct UpdateLineItemRequest with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(UpdateLineItemRequest {
                                item_id: __field0,
                                updates: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<LineItem> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "item_id",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "updates",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<LineItem>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("item_id")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("updates")?
                                }
                            };
                            _serde::__private::Ok(UpdateLineItemRequest {
                                item_id: __field0,
                                updates: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["item_id", "updates"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "UpdateLineItemRequest",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                UpdateLineItemRequest,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        let req: UpdateLineItemRequest = serde_json::from_str(&request_body)
            .map_err(|e| ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("Invalid request: {0}", e));
                res
            }))?;
        if let Some(ref mut invoice) = self.current_invoice {
            let snapshot = InvoiceSnapshot {
                invoice: invoice.clone(),
                timestamp: invoice.updated_at,
            };
            self.undo_stack.push(snapshot);
            if self.undo_stack.len() > 50 {
                self.undo_stack.remove(0);
            }
            self.redo_stack.clear();
            if let Some(item) = invoice
                .line_items
                .iter_mut()
                .find(|i| i.id == req.item_id)
            {
                *item = req.updates;
            } else {
                return Err("Line item not found".to_string());
            }
            invoice.updated_at = std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_secs();
            self.has_unsaved_changes = true;
            let total = calculate_invoice_total(&invoice.clone());
            let summary = InvoiceSummary {
                id: invoice.id.clone(),
                number: invoice.number.clone(),
                name: invoice.name.clone(),
                date: invoice.date.clone(),
                total,
                status: invoice.status.clone(),
            };
            self.invoices.insert(invoice.id.clone(), summary);
            serde_json::to_string(invoice)
                .map_err(|e| ::alloc::__export::must_use({
                    let res = ::alloc::fmt::format(
                        format_args!("Failed to serialize invoice: {0}", e),
                    );
                    res
                }))
        } else {
            Err("No invoice currently loaded".to_string())
        }
    }
    async fn delete_line_item(
        &mut self,
        request_body: String,
    ) -> Result<String, String> {
        let item_id: String = serde_json::from_str(&request_body)
            .map_err(|e| ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("Invalid item ID: {0}", e));
                res
            }))?;
        if let Some(ref mut invoice) = self.current_invoice {
            let snapshot = InvoiceSnapshot {
                invoice: invoice.clone(),
                timestamp: invoice.updated_at,
            };
            self.undo_stack.push(snapshot);
            if self.undo_stack.len() > 50 {
                self.undo_stack.remove(0);
            }
            self.redo_stack.clear();
            invoice.line_items.retain(|item| item.id != item_id);
            invoice.updated_at = std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_secs();
            self.has_unsaved_changes = true;
            let total = calculate_invoice_total(&invoice.clone());
            let summary = InvoiceSummary {
                id: invoice.id.clone(),
                number: invoice.number.clone(),
                name: invoice.name.clone(),
                date: invoice.date.clone(),
                total,
                status: invoice.status.clone(),
            };
            self.invoices.insert(invoice.id.clone(), summary);
            serde_json::to_string(invoice)
                .map_err(|e| ::alloc::__export::must_use({
                    let res = ::alloc::fmt::format(
                        format_args!("Failed to serialize invoice: {0}", e),
                    );
                    res
                }))
        } else {
            Err("No invoice currently loaded".to_string())
        }
    }
    async fn reorder_line_items(
        &mut self,
        request_body: String,
    ) -> Result<String, String> {
        let item_ids: Vec<String> = serde_json::from_str(&request_body)
            .map_err(|e| ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("Invalid item IDs: {0}", e));
                res
            }))?;
        if let Some(ref mut invoice) = self.current_invoice {
            let snapshot = InvoiceSnapshot {
                invoice: invoice.clone(),
                timestamp: invoice.updated_at,
            };
            self.undo_stack.push(snapshot);
            if self.undo_stack.len() > 50 {
                self.undo_stack.remove(0);
            }
            self.redo_stack.clear();
            let mut new_items = Vec::new();
            for id in item_ids {
                if let Some(item) = invoice.line_items.iter().find(|i| i.id == id) {
                    new_items.push(item.clone());
                }
            }
            invoice.line_items = new_items;
            invoice.updated_at = std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_secs();
            self.has_unsaved_changes = true;
            serde_json::to_string(invoice)
                .map_err(|e| ::alloc::__export::must_use({
                    let res = ::alloc::fmt::format(
                        format_args!("Failed to serialize invoice: {0}", e),
                    );
                    res
                }))
        } else {
            Err("No invoice currently loaded".to_string())
        }
    }
    async fn undo(&mut self) -> Result<String, String> {
        if let Some(snapshot) = self.undo_stack.pop() {
            if let Some(ref current) = self.current_invoice {
                let redo_snapshot = InvoiceSnapshot {
                    invoice: current.clone(),
                    timestamp: current.updated_at,
                };
                self.redo_stack.push(redo_snapshot);
            }
            self.current_invoice = Some(snapshot.invoice.clone());
            self.has_unsaved_changes = true;
            let summary = InvoiceSummary {
                id: snapshot.invoice.id.clone(),
                number: snapshot.invoice.number.clone(),
                name: snapshot.invoice.name.clone(),
                date: snapshot.invoice.date.clone(),
                total: calculate_invoice_total(&snapshot.invoice),
                status: snapshot.invoice.status.clone(),
            };
            self.invoices.insert(snapshot.invoice.id.clone(), summary);
            serde_json::to_string(&snapshot.invoice)
                .map_err(|e| ::alloc::__export::must_use({
                    let res = ::alloc::fmt::format(
                        format_args!("Failed to serialize invoice: {0}", e),
                    );
                    res
                }))
        } else {
            Err("Nothing to undo".to_string())
        }
    }
    async fn redo(&mut self) -> Result<String, String> {
        if let Some(snapshot) = self.redo_stack.pop() {
            if let Some(ref current) = self.current_invoice {
                let undo_snapshot = InvoiceSnapshot {
                    invoice: current.clone(),
                    timestamp: current.updated_at,
                };
                self.undo_stack.push(undo_snapshot);
            }
            self.current_invoice = Some(snapshot.invoice.clone());
            self.has_unsaved_changes = true;
            let summary = InvoiceSummary {
                id: snapshot.invoice.id.clone(),
                number: snapshot.invoice.number.clone(),
                name: snapshot.invoice.name.clone(),
                date: snapshot.invoice.date.clone(),
                total: calculate_invoice_total(&snapshot.invoice),
                status: snapshot.invoice.status.clone(),
            };
            self.invoices.insert(snapshot.invoice.id.clone(), summary);
            serde_json::to_string(&snapshot.invoice)
                .map_err(|e| ::alloc::__export::must_use({
                    let res = ::alloc::fmt::format(
                        format_args!("Failed to serialize invoice: {0}", e),
                    );
                    res
                }))
        } else {
            Err("Nothing to redo".to_string())
        }
    }
    async fn can_undo(&self) -> Result<bool, String> {
        Ok(!self.undo_stack.is_empty())
    }
    async fn can_redo(&self) -> Result<bool, String> {
        Ok(!self.redo_stack.is_empty())
    }
    async fn generate_pdf(&mut self) -> Result<String, String> {
        if let Some(ref invoice) = self.current_invoice {
            let html = self.generate_invoice_html(invoice);
            let package_id = our().package_id();
            let drive_path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("/{0}/invoice", package_id));
                res
            });
            let invoice_dir = if let Some(ref name) = invoice.name {
                name.clone()
            } else {
                invoice.number.clone()
            };
            let pdf_path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!(
                        "{0}/{1}/{2}/invoice.pdf",
                        drive_path,
                        invoice.date,
                        invoice_dir,
                    ),
                );
                res
            });
            match create_file(&pdf_path, Some(5)) {
                Ok(file) => {
                    file.write(html.as_bytes())
                        .map_err(|e| ::alloc::__export::must_use({
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to write PDF: {0}", e),
                            );
                            res
                        }))?;
                    Ok(pdf_path)
                }
                Err(e) => {
                    Err(
                        ::alloc::__export::must_use({
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create PDF file: {0}", e),
                            );
                            res
                        }),
                    )
                }
            }
        } else {
            Err("No invoice currently loaded".to_string())
        }
    }
    async fn check_autosave(&mut self) -> Result<String, String> {
        if self.has_unsaved_changes {
            let current_time = std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_secs();
            if current_time - self.last_save_time >= 1 {
                self.save_current_invoice()?;
                self.last_save_time = current_time;
                Ok("saved".to_string())
            } else {
                Ok("waiting".to_string())
            }
        } else {
            Ok("no_changes".to_string())
        }
    }
}
enum HPMRequest {
    GetSettings {},
    UpdateSettings(String),
    UploadLogo(Vec<u8>),
    UploadPaymentImage(Vec<u8>),
    ListInvoices {},
    CreateInvoice {},
    GetInvoice(String),
    UpdateInvoice(String),
    DeleteInvoice(String),
    AddLineItem {},
    UpdateLineItem(String),
    DeleteLineItem(String),
    ReorderLineItems(String),
    Undo {},
    Redo {},
    CanUndo {},
    CanRedo {},
    GeneratePdf {},
    CheckAutosave {},
}
#[automatically_derived]
impl ::core::fmt::Debug for HPMRequest {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            HPMRequest::GetSettings {} => {
                ::core::fmt::Formatter::write_str(f, "GetSettings")
            }
            HPMRequest::UpdateSettings(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "UpdateSettings",
                    &__self_0,
                )
            }
            HPMRequest::UploadLogo(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "UploadLogo",
                    &__self_0,
                )
            }
            HPMRequest::UploadPaymentImage(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "UploadPaymentImage",
                    &__self_0,
                )
            }
            HPMRequest::ListInvoices {} => {
                ::core::fmt::Formatter::write_str(f, "ListInvoices")
            }
            HPMRequest::CreateInvoice {} => {
                ::core::fmt::Formatter::write_str(f, "CreateInvoice")
            }
            HPMRequest::GetInvoice(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "GetInvoice",
                    &__self_0,
                )
            }
            HPMRequest::UpdateInvoice(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "UpdateInvoice",
                    &__self_0,
                )
            }
            HPMRequest::DeleteInvoice(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "DeleteInvoice",
                    &__self_0,
                )
            }
            HPMRequest::AddLineItem {} => {
                ::core::fmt::Formatter::write_str(f, "AddLineItem")
            }
            HPMRequest::UpdateLineItem(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "UpdateLineItem",
                    &__self_0,
                )
            }
            HPMRequest::DeleteLineItem(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "DeleteLineItem",
                    &__self_0,
                )
            }
            HPMRequest::ReorderLineItems(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "ReorderLineItems",
                    &__self_0,
                )
            }
            HPMRequest::Undo {} => ::core::fmt::Formatter::write_str(f, "Undo"),
            HPMRequest::Redo {} => ::core::fmt::Formatter::write_str(f, "Redo"),
            HPMRequest::CanUndo {} => ::core::fmt::Formatter::write_str(f, "CanUndo"),
            HPMRequest::CanRedo {} => ::core::fmt::Formatter::write_str(f, "CanRedo"),
            HPMRequest::GeneratePdf {} => {
                ::core::fmt::Formatter::write_str(f, "GeneratePdf")
            }
            HPMRequest::CheckAutosave {} => {
                ::core::fmt::Formatter::write_str(f, "CheckAutosave")
            }
        }
    }
}
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for HPMRequest {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            match *self {
                HPMRequest::GetSettings {} => {
                    let __serde_state = _serde::Serializer::serialize_struct_variant(
                        __serializer,
                        "HPMRequest",
                        0u32,
                        "GetSettings",
                        0,
                    )?;
                    _serde::ser::SerializeStructVariant::end(__serde_state)
                }
                HPMRequest::UpdateSettings(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "HPMRequest",
                        1u32,
                        "UpdateSettings",
                        __field0,
                    )
                }
                HPMRequest::UploadLogo(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "HPMRequest",
                        2u32,
                        "UploadLogo",
                        __field0,
                    )
                }
                HPMRequest::UploadPaymentImage(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "HPMRequest",
                        3u32,
                        "UploadPaymentImage",
                        __field0,
                    )
                }
                HPMRequest::ListInvoices {} => {
                    let __serde_state = _serde::Serializer::serialize_struct_variant(
                        __serializer,
                        "HPMRequest",
                        4u32,
                        "ListInvoices",
                        0,
                    )?;
                    _serde::ser::SerializeStructVariant::end(__serde_state)
                }
                HPMRequest::CreateInvoice {} => {
                    let __serde_state = _serde::Serializer::serialize_struct_variant(
                        __serializer,
                        "HPMRequest",
                        5u32,
                        "CreateInvoice",
                        0,
                    )?;
                    _serde::ser::SerializeStructVariant::end(__serde_state)
                }
                HPMRequest::GetInvoice(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "HPMRequest",
                        6u32,
                        "GetInvoice",
                        __field0,
                    )
                }
                HPMRequest::UpdateInvoice(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "HPMRequest",
                        7u32,
                        "UpdateInvoice",
                        __field0,
                    )
                }
                HPMRequest::DeleteInvoice(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "HPMRequest",
                        8u32,
                        "DeleteInvoice",
                        __field0,
                    )
                }
                HPMRequest::AddLineItem {} => {
                    let __serde_state = _serde::Serializer::serialize_struct_variant(
                        __serializer,
                        "HPMRequest",
                        9u32,
                        "AddLineItem",
                        0,
                    )?;
                    _serde::ser::SerializeStructVariant::end(__serde_state)
                }
                HPMRequest::UpdateLineItem(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "HPMRequest",
                        10u32,
                        "UpdateLineItem",
                        __field0,
                    )
                }
                HPMRequest::DeleteLineItem(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "HPMRequest",
                        11u32,
                        "DeleteLineItem",
                        __field0,
                    )
                }
                HPMRequest::ReorderLineItems(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "HPMRequest",
                        12u32,
                        "ReorderLineItems",
                        __field0,
                    )
                }
                HPMRequest::Undo {} => {
                    let __serde_state = _serde::Serializer::serialize_struct_variant(
                        __serializer,
                        "HPMRequest",
                        13u32,
                        "Undo",
                        0,
                    )?;
                    _serde::ser::SerializeStructVariant::end(__serde_state)
                }
                HPMRequest::Redo {} => {
                    let __serde_state = _serde::Serializer::serialize_struct_variant(
                        __serializer,
                        "HPMRequest",
                        14u32,
                        "Redo",
                        0,
                    )?;
                    _serde::ser::SerializeStructVariant::end(__serde_state)
                }
                HPMRequest::CanUndo {} => {
                    let __serde_state = _serde::Serializer::serialize_struct_variant(
                        __serializer,
                        "HPMRequest",
                        15u32,
                        "CanUndo",
                        0,
                    )?;
                    _serde::ser::SerializeStructVariant::end(__serde_state)
                }
                HPMRequest::CanRedo {} => {
                    let __serde_state = _serde::Serializer::serialize_struct_variant(
                        __serializer,
                        "HPMRequest",
                        16u32,
                        "CanRedo",
                        0,
                    )?;
                    _serde::ser::SerializeStructVariant::end(__serde_state)
                }
                HPMRequest::GeneratePdf {} => {
                    let __serde_state = _serde::Serializer::serialize_struct_variant(
                        __serializer,
                        "HPMRequest",
                        17u32,
                        "GeneratePdf",
                        0,
                    )?;
                    _serde::ser::SerializeStructVariant::end(__serde_state)
                }
                HPMRequest::CheckAutosave {} => {
                    let __serde_state = _serde::Serializer::serialize_struct_variant(
                        __serializer,
                        "HPMRequest",
                        18u32,
                        "CheckAutosave",
                        0,
                    )?;
                    _serde::ser::SerializeStructVariant::end(__serde_state)
                }
            }
        }
    }
};
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for HPMRequest {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __field3,
                __field4,
                __field5,
                __field6,
                __field7,
                __field8,
                __field9,
                __field10,
                __field11,
                __field12,
                __field13,
                __field14,
                __field15,
                __field16,
                __field17,
                __field18,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "variant identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        2u64 => _serde::__private::Ok(__Field::__field2),
                        3u64 => _serde::__private::Ok(__Field::__field3),
                        4u64 => _serde::__private::Ok(__Field::__field4),
                        5u64 => _serde::__private::Ok(__Field::__field5),
                        6u64 => _serde::__private::Ok(__Field::__field6),
                        7u64 => _serde::__private::Ok(__Field::__field7),
                        8u64 => _serde::__private::Ok(__Field::__field8),
                        9u64 => _serde::__private::Ok(__Field::__field9),
                        10u64 => _serde::__private::Ok(__Field::__field10),
                        11u64 => _serde::__private::Ok(__Field::__field11),
                        12u64 => _serde::__private::Ok(__Field::__field12),
                        13u64 => _serde::__private::Ok(__Field::__field13),
                        14u64 => _serde::__private::Ok(__Field::__field14),
                        15u64 => _serde::__private::Ok(__Field::__field15),
                        16u64 => _serde::__private::Ok(__Field::__field16),
                        17u64 => _serde::__private::Ok(__Field::__field17),
                        18u64 => _serde::__private::Ok(__Field::__field18),
                        _ => {
                            _serde::__private::Err(
                                _serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 19",
                                ),
                            )
                        }
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "GetSettings" => _serde::__private::Ok(__Field::__field0),
                        "UpdateSettings" => _serde::__private::Ok(__Field::__field1),
                        "UploadLogo" => _serde::__private::Ok(__Field::__field2),
                        "UploadPaymentImage" => _serde::__private::Ok(__Field::__field3),
                        "ListInvoices" => _serde::__private::Ok(__Field::__field4),
                        "CreateInvoice" => _serde::__private::Ok(__Field::__field5),
                        "GetInvoice" => _serde::__private::Ok(__Field::__field6),
                        "UpdateInvoice" => _serde::__private::Ok(__Field::__field7),
                        "DeleteInvoice" => _serde::__private::Ok(__Field::__field8),
                        "AddLineItem" => _serde::__private::Ok(__Field::__field9),
                        "UpdateLineItem" => _serde::__private::Ok(__Field::__field10),
                        "DeleteLineItem" => _serde::__private::Ok(__Field::__field11),
                        "ReorderLineItems" => _serde::__private::Ok(__Field::__field12),
                        "Undo" => _serde::__private::Ok(__Field::__field13),
                        "Redo" => _serde::__private::Ok(__Field::__field14),
                        "CanUndo" => _serde::__private::Ok(__Field::__field15),
                        "CanRedo" => _serde::__private::Ok(__Field::__field16),
                        "GeneratePdf" => _serde::__private::Ok(__Field::__field17),
                        "CheckAutosave" => _serde::__private::Ok(__Field::__field18),
                        _ => {
                            _serde::__private::Err(
                                _serde::de::Error::unknown_variant(__value, VARIANTS),
                            )
                        }
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"GetSettings" => _serde::__private::Ok(__Field::__field0),
                        b"UpdateSettings" => _serde::__private::Ok(__Field::__field1),
                        b"UploadLogo" => _serde::__private::Ok(__Field::__field2),
                        b"UploadPaymentImage" => _serde::__private::Ok(__Field::__field3),
                        b"ListInvoices" => _serde::__private::Ok(__Field::__field4),
                        b"CreateInvoice" => _serde::__private::Ok(__Field::__field5),
                        b"GetInvoice" => _serde::__private::Ok(__Field::__field6),
                        b"UpdateInvoice" => _serde::__private::Ok(__Field::__field7),
                        b"DeleteInvoice" => _serde::__private::Ok(__Field::__field8),
                        b"AddLineItem" => _serde::__private::Ok(__Field::__field9),
                        b"UpdateLineItem" => _serde::__private::Ok(__Field::__field10),
                        b"DeleteLineItem" => _serde::__private::Ok(__Field::__field11),
                        b"ReorderLineItems" => _serde::__private::Ok(__Field::__field12),
                        b"Undo" => _serde::__private::Ok(__Field::__field13),
                        b"Redo" => _serde::__private::Ok(__Field::__field14),
                        b"CanUndo" => _serde::__private::Ok(__Field::__field15),
                        b"CanRedo" => _serde::__private::Ok(__Field::__field16),
                        b"GeneratePdf" => _serde::__private::Ok(__Field::__field17),
                        b"CheckAutosave" => _serde::__private::Ok(__Field::__field18),
                        _ => {
                            let __value = &_serde::__private::from_utf8_lossy(__value);
                            _serde::__private::Err(
                                _serde::de::Error::unknown_variant(__value, VARIANTS),
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<HPMRequest>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = HPMRequest;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "enum HPMRequest",
                    )
                }
                fn visit_enum<__A>(
                    self,
                    __data: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::EnumAccess<'de>,
                {
                    match _serde::de::EnumAccess::variant(__data)? {
                        (__Field::__field0, __variant) => {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<HPMRequest>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = HPMRequest;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct variant HPMRequest::GetSettings",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    _: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    _serde::__private::Ok(HPMRequest::GetSettings {})
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    _serde::__private::Ok(HPMRequest::GetSettings {})
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &[];
                            _serde::de::VariantAccess::struct_variant(
                                __variant,
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<HPMRequest>,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                        (__Field::__field1, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    String,
                                >(__variant),
                                HPMRequest::UpdateSettings,
                            )
                        }
                        (__Field::__field2, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    Vec<u8>,
                                >(__variant),
                                HPMRequest::UploadLogo,
                            )
                        }
                        (__Field::__field3, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    Vec<u8>,
                                >(__variant),
                                HPMRequest::UploadPaymentImage,
                            )
                        }
                        (__Field::__field4, __variant) => {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<HPMRequest>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = HPMRequest;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct variant HPMRequest::ListInvoices",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    _: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    _serde::__private::Ok(HPMRequest::ListInvoices {})
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    _serde::__private::Ok(HPMRequest::ListInvoices {})
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &[];
                            _serde::de::VariantAccess::struct_variant(
                                __variant,
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<HPMRequest>,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                        (__Field::__field5, __variant) => {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<HPMRequest>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = HPMRequest;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct variant HPMRequest::CreateInvoice",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    _: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    _serde::__private::Ok(HPMRequest::CreateInvoice {})
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    _serde::__private::Ok(HPMRequest::CreateInvoice {})
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &[];
                            _serde::de::VariantAccess::struct_variant(
                                __variant,
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<HPMRequest>,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                        (__Field::__field6, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    String,
                                >(__variant),
                                HPMRequest::GetInvoice,
                            )
                        }
                        (__Field::__field7, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    String,
                                >(__variant),
                                HPMRequest::UpdateInvoice,
                            )
                        }
                        (__Field::__field8, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    String,
                                >(__variant),
                                HPMRequest::DeleteInvoice,
                            )
                        }
                        (__Field::__field9, __variant) => {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<HPMRequest>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = HPMRequest;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct variant HPMRequest::AddLineItem",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    _: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    _serde::__private::Ok(HPMRequest::AddLineItem {})
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    _serde::__private::Ok(HPMRequest::AddLineItem {})
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &[];
                            _serde::de::VariantAccess::struct_variant(
                                __variant,
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<HPMRequest>,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                        (__Field::__field10, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    String,
                                >(__variant),
                                HPMRequest::UpdateLineItem,
                            )
                        }
                        (__Field::__field11, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    String,
                                >(__variant),
                                HPMRequest::DeleteLineItem,
                            )
                        }
                        (__Field::__field12, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    String,
                                >(__variant),
                                HPMRequest::ReorderLineItems,
                            )
                        }
                        (__Field::__field13, __variant) => {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<HPMRequest>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = HPMRequest;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct variant HPMRequest::Undo",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    _: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    _serde::__private::Ok(HPMRequest::Undo {})
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    _serde::__private::Ok(HPMRequest::Undo {})
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &[];
                            _serde::de::VariantAccess::struct_variant(
                                __variant,
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<HPMRequest>,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                        (__Field::__field14, __variant) => {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<HPMRequest>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = HPMRequest;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct variant HPMRequest::Redo",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    _: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    _serde::__private::Ok(HPMRequest::Redo {})
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    _serde::__private::Ok(HPMRequest::Redo {})
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &[];
                            _serde::de::VariantAccess::struct_variant(
                                __variant,
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<HPMRequest>,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                        (__Field::__field15, __variant) => {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<HPMRequest>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = HPMRequest;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct variant HPMRequest::CanUndo",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    _: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    _serde::__private::Ok(HPMRequest::CanUndo {})
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    _serde::__private::Ok(HPMRequest::CanUndo {})
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &[];
                            _serde::de::VariantAccess::struct_variant(
                                __variant,
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<HPMRequest>,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                        (__Field::__field16, __variant) => {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<HPMRequest>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = HPMRequest;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct variant HPMRequest::CanRedo",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    _: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    _serde::__private::Ok(HPMRequest::CanRedo {})
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    _serde::__private::Ok(HPMRequest::CanRedo {})
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &[];
                            _serde::de::VariantAccess::struct_variant(
                                __variant,
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<HPMRequest>,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                        (__Field::__field17, __variant) => {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<HPMRequest>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = HPMRequest;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct variant HPMRequest::GeneratePdf",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    _: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    _serde::__private::Ok(HPMRequest::GeneratePdf {})
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    _serde::__private::Ok(HPMRequest::GeneratePdf {})
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &[];
                            _serde::de::VariantAccess::struct_variant(
                                __variant,
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<HPMRequest>,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                        (__Field::__field18, __variant) => {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            enum __Field {
                                __ignore,
                            }
                            #[doc(hidden)]
                            struct __FieldVisitor;
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            #[doc(hidden)]
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<HPMRequest>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = HPMRequest;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct variant HPMRequest::CheckAutosave",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    _: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    _serde::__private::Ok(HPMRequest::CheckAutosave {})
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                        __Field,
                                    >(&mut __map)? {
                                        match __key {
                                            _ => {
                                                let _ = _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(&mut __map)?;
                                            }
                                        }
                                    }
                                    _serde::__private::Ok(HPMRequest::CheckAutosave {})
                                }
                            }
                            #[doc(hidden)]
                            const FIELDS: &'static [&'static str] = &[];
                            _serde::de::VariantAccess::struct_variant(
                                __variant,
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<HPMRequest>,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                    }
                }
            }
            #[doc(hidden)]
            const VARIANTS: &'static [&'static str] = &[
                "GetSettings",
                "UpdateSettings",
                "UploadLogo",
                "UploadPaymentImage",
                "ListInvoices",
                "CreateInvoice",
                "GetInvoice",
                "UpdateInvoice",
                "DeleteInvoice",
                "AddLineItem",
                "UpdateLineItem",
                "DeleteLineItem",
                "ReorderLineItems",
                "Undo",
                "Redo",
                "CanUndo",
                "CanRedo",
                "GeneratePdf",
                "CheckAutosave",
            ];
            _serde::Deserializer::deserialize_enum(
                __deserializer,
                "HPMRequest",
                VARIANTS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<HPMRequest>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
enum HPMResponse {
    GetSettings(Result<String, String>),
    UpdateSettings(Result<String, String>),
    UploadLogo(Result<String, String>),
    UploadPaymentImage(Result<String, String>),
    ListInvoices(Result<String, String>),
    CreateInvoice(Result<String, String>),
    GetInvoice(Result<String, String>),
    UpdateInvoice(Result<String, String>),
    DeleteInvoice(Result<String, String>),
    AddLineItem(Result<String, String>),
    UpdateLineItem(Result<String, String>),
    DeleteLineItem(Result<String, String>),
    ReorderLineItems(Result<String, String>),
    Undo(Result<String, String>),
    Redo(Result<String, String>),
    CanUndo(Result<bool, String>),
    CanRedo(Result<bool, String>),
    GeneratePdf(Result<String, String>),
    CheckAutosave(Result<String, String>),
}
#[automatically_derived]
impl ::core::fmt::Debug for HPMResponse {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            HPMResponse::GetSettings(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "GetSettings",
                    &__self_0,
                )
            }
            HPMResponse::UpdateSettings(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "UpdateSettings",
                    &__self_0,
                )
            }
            HPMResponse::UploadLogo(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "UploadLogo",
                    &__self_0,
                )
            }
            HPMResponse::UploadPaymentImage(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "UploadPaymentImage",
                    &__self_0,
                )
            }
            HPMResponse::ListInvoices(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "ListInvoices",
                    &__self_0,
                )
            }
            HPMResponse::CreateInvoice(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "CreateInvoice",
                    &__self_0,
                )
            }
            HPMResponse::GetInvoice(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "GetInvoice",
                    &__self_0,
                )
            }
            HPMResponse::UpdateInvoice(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "UpdateInvoice",
                    &__self_0,
                )
            }
            HPMResponse::DeleteInvoice(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "DeleteInvoice",
                    &__self_0,
                )
            }
            HPMResponse::AddLineItem(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "AddLineItem",
                    &__self_0,
                )
            }
            HPMResponse::UpdateLineItem(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "UpdateLineItem",
                    &__self_0,
                )
            }
            HPMResponse::DeleteLineItem(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "DeleteLineItem",
                    &__self_0,
                )
            }
            HPMResponse::ReorderLineItems(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "ReorderLineItems",
                    &__self_0,
                )
            }
            HPMResponse::Undo(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Undo", &__self_0)
            }
            HPMResponse::Redo(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Redo", &__self_0)
            }
            HPMResponse::CanUndo(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "CanUndo",
                    &__self_0,
                )
            }
            HPMResponse::CanRedo(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "CanRedo",
                    &__self_0,
                )
            }
            HPMResponse::GeneratePdf(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "GeneratePdf",
                    &__self_0,
                )
            }
            HPMResponse::CheckAutosave(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "CheckAutosave",
                    &__self_0,
                )
            }
        }
    }
}
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for HPMResponse {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            match *self {
                HPMResponse::GetSettings(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "HPMResponse",
                        0u32,
                        "GetSettings",
                        __field0,
                    )
                }
                HPMResponse::UpdateSettings(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "HPMResponse",
                        1u32,
                        "UpdateSettings",
                        __field0,
                    )
                }
                HPMResponse::UploadLogo(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "HPMResponse",
                        2u32,
                        "UploadLogo",
                        __field0,
                    )
                }
                HPMResponse::UploadPaymentImage(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "HPMResponse",
                        3u32,
                        "UploadPaymentImage",
                        __field0,
                    )
                }
                HPMResponse::ListInvoices(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "HPMResponse",
                        4u32,
                        "ListInvoices",
                        __field0,
                    )
                }
                HPMResponse::CreateInvoice(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "HPMResponse",
                        5u32,
                        "CreateInvoice",
                        __field0,
                    )
                }
                HPMResponse::GetInvoice(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "HPMResponse",
                        6u32,
                        "GetInvoice",
                        __field0,
                    )
                }
                HPMResponse::UpdateInvoice(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "HPMResponse",
                        7u32,
                        "UpdateInvoice",
                        __field0,
                    )
                }
                HPMResponse::DeleteInvoice(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "HPMResponse",
                        8u32,
                        "DeleteInvoice",
                        __field0,
                    )
                }
                HPMResponse::AddLineItem(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "HPMResponse",
                        9u32,
                        "AddLineItem",
                        __field0,
                    )
                }
                HPMResponse::UpdateLineItem(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "HPMResponse",
                        10u32,
                        "UpdateLineItem",
                        __field0,
                    )
                }
                HPMResponse::DeleteLineItem(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "HPMResponse",
                        11u32,
                        "DeleteLineItem",
                        __field0,
                    )
                }
                HPMResponse::ReorderLineItems(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "HPMResponse",
                        12u32,
                        "ReorderLineItems",
                        __field0,
                    )
                }
                HPMResponse::Undo(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "HPMResponse",
                        13u32,
                        "Undo",
                        __field0,
                    )
                }
                HPMResponse::Redo(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "HPMResponse",
                        14u32,
                        "Redo",
                        __field0,
                    )
                }
                HPMResponse::CanUndo(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "HPMResponse",
                        15u32,
                        "CanUndo",
                        __field0,
                    )
                }
                HPMResponse::CanRedo(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "HPMResponse",
                        16u32,
                        "CanRedo",
                        __field0,
                    )
                }
                HPMResponse::GeneratePdf(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "HPMResponse",
                        17u32,
                        "GeneratePdf",
                        __field0,
                    )
                }
                HPMResponse::CheckAutosave(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "HPMResponse",
                        18u32,
                        "CheckAutosave",
                        __field0,
                    )
                }
            }
        }
    }
};
#[doc(hidden)]
#[allow(
    non_upper_case_globals,
    unused_attributes,
    unused_qualifications,
    clippy::absolute_paths,
)]
const _: () = {
    #[allow(unused_extern_crates, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for HPMResponse {
        fn deserialize<__D>(
            __deserializer: __D,
        ) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __field3,
                __field4,
                __field5,
                __field6,
                __field7,
                __field8,
                __field9,
                __field10,
                __field11,
                __field12,
                __field13,
                __field14,
                __field15,
                __field16,
                __field17,
                __field18,
            }
            #[doc(hidden)]
            struct __FieldVisitor;
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "variant identifier",
                    )
                }
                fn visit_u64<__E>(
                    self,
                    __value: u64,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        2u64 => _serde::__private::Ok(__Field::__field2),
                        3u64 => _serde::__private::Ok(__Field::__field3),
                        4u64 => _serde::__private::Ok(__Field::__field4),
                        5u64 => _serde::__private::Ok(__Field::__field5),
                        6u64 => _serde::__private::Ok(__Field::__field6),
                        7u64 => _serde::__private::Ok(__Field::__field7),
                        8u64 => _serde::__private::Ok(__Field::__field8),
                        9u64 => _serde::__private::Ok(__Field::__field9),
                        10u64 => _serde::__private::Ok(__Field::__field10),
                        11u64 => _serde::__private::Ok(__Field::__field11),
                        12u64 => _serde::__private::Ok(__Field::__field12),
                        13u64 => _serde::__private::Ok(__Field::__field13),
                        14u64 => _serde::__private::Ok(__Field::__field14),
                        15u64 => _serde::__private::Ok(__Field::__field15),
                        16u64 => _serde::__private::Ok(__Field::__field16),
                        17u64 => _serde::__private::Ok(__Field::__field17),
                        18u64 => _serde::__private::Ok(__Field::__field18),
                        _ => {
                            _serde::__private::Err(
                                _serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 19",
                                ),
                            )
                        }
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "GetSettings" => _serde::__private::Ok(__Field::__field0),
                        "UpdateSettings" => _serde::__private::Ok(__Field::__field1),
                        "UploadLogo" => _serde::__private::Ok(__Field::__field2),
                        "UploadPaymentImage" => _serde::__private::Ok(__Field::__field3),
                        "ListInvoices" => _serde::__private::Ok(__Field::__field4),
                        "CreateInvoice" => _serde::__private::Ok(__Field::__field5),
                        "GetInvoice" => _serde::__private::Ok(__Field::__field6),
                        "UpdateInvoice" => _serde::__private::Ok(__Field::__field7),
                        "DeleteInvoice" => _serde::__private::Ok(__Field::__field8),
                        "AddLineItem" => _serde::__private::Ok(__Field::__field9),
                        "UpdateLineItem" => _serde::__private::Ok(__Field::__field10),
                        "DeleteLineItem" => _serde::__private::Ok(__Field::__field11),
                        "ReorderLineItems" => _serde::__private::Ok(__Field::__field12),
                        "Undo" => _serde::__private::Ok(__Field::__field13),
                        "Redo" => _serde::__private::Ok(__Field::__field14),
                        "CanUndo" => _serde::__private::Ok(__Field::__field15),
                        "CanRedo" => _serde::__private::Ok(__Field::__field16),
                        "GeneratePdf" => _serde::__private::Ok(__Field::__field17),
                        "CheckAutosave" => _serde::__private::Ok(__Field::__field18),
                        _ => {
                            _serde::__private::Err(
                                _serde::de::Error::unknown_variant(__value, VARIANTS),
                            )
                        }
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"GetSettings" => _serde::__private::Ok(__Field::__field0),
                        b"UpdateSettings" => _serde::__private::Ok(__Field::__field1),
                        b"UploadLogo" => _serde::__private::Ok(__Field::__field2),
                        b"UploadPaymentImage" => _serde::__private::Ok(__Field::__field3),
                        b"ListInvoices" => _serde::__private::Ok(__Field::__field4),
                        b"CreateInvoice" => _serde::__private::Ok(__Field::__field5),
                        b"GetInvoice" => _serde::__private::Ok(__Field::__field6),
                        b"UpdateInvoice" => _serde::__private::Ok(__Field::__field7),
                        b"DeleteInvoice" => _serde::__private::Ok(__Field::__field8),
                        b"AddLineItem" => _serde::__private::Ok(__Field::__field9),
                        b"UpdateLineItem" => _serde::__private::Ok(__Field::__field10),
                        b"DeleteLineItem" => _serde::__private::Ok(__Field::__field11),
                        b"ReorderLineItems" => _serde::__private::Ok(__Field::__field12),
                        b"Undo" => _serde::__private::Ok(__Field::__field13),
                        b"Redo" => _serde::__private::Ok(__Field::__field14),
                        b"CanUndo" => _serde::__private::Ok(__Field::__field15),
                        b"CanRedo" => _serde::__private::Ok(__Field::__field16),
                        b"GeneratePdf" => _serde::__private::Ok(__Field::__field17),
                        b"CheckAutosave" => _serde::__private::Ok(__Field::__field18),
                        _ => {
                            let __value = &_serde::__private::from_utf8_lossy(__value);
                            _serde::__private::Err(
                                _serde::de::Error::unknown_variant(__value, VARIANTS),
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(
                        __deserializer,
                        __FieldVisitor,
                    )
                }
            }
            #[doc(hidden)]
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<HPMResponse>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            #[automatically_derived]
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = HPMResponse;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(
                        __formatter,
                        "enum HPMResponse",
                    )
                }
                fn visit_enum<__A>(
                    self,
                    __data: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::EnumAccess<'de>,
                {
                    match _serde::de::EnumAccess::variant(__data)? {
                        (__Field::__field0, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    Result<String, String>,
                                >(__variant),
                                HPMResponse::GetSettings,
                            )
                        }
                        (__Field::__field1, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    Result<String, String>,
                                >(__variant),
                                HPMResponse::UpdateSettings,
                            )
                        }
                        (__Field::__field2, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    Result<String, String>,
                                >(__variant),
                                HPMResponse::UploadLogo,
                            )
                        }
                        (__Field::__field3, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    Result<String, String>,
                                >(__variant),
                                HPMResponse::UploadPaymentImage,
                            )
                        }
                        (__Field::__field4, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    Result<String, String>,
                                >(__variant),
                                HPMResponse::ListInvoices,
                            )
                        }
                        (__Field::__field5, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    Result<String, String>,
                                >(__variant),
                                HPMResponse::CreateInvoice,
                            )
                        }
                        (__Field::__field6, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    Result<String, String>,
                                >(__variant),
                                HPMResponse::GetInvoice,
                            )
                        }
                        (__Field::__field7, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    Result<String, String>,
                                >(__variant),
                                HPMResponse::UpdateInvoice,
                            )
                        }
                        (__Field::__field8, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    Result<String, String>,
                                >(__variant),
                                HPMResponse::DeleteInvoice,
                            )
                        }
                        (__Field::__field9, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    Result<String, String>,
                                >(__variant),
                                HPMResponse::AddLineItem,
                            )
                        }
                        (__Field::__field10, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    Result<String, String>,
                                >(__variant),
                                HPMResponse::UpdateLineItem,
                            )
                        }
                        (__Field::__field11, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    Result<String, String>,
                                >(__variant),
                                HPMResponse::DeleteLineItem,
                            )
                        }
                        (__Field::__field12, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    Result<String, String>,
                                >(__variant),
                                HPMResponse::ReorderLineItems,
                            )
                        }
                        (__Field::__field13, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    Result<String, String>,
                                >(__variant),
                                HPMResponse::Undo,
                            )
                        }
                        (__Field::__field14, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    Result<String, String>,
                                >(__variant),
                                HPMResponse::Redo,
                            )
                        }
                        (__Field::__field15, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    Result<bool, String>,
                                >(__variant),
                                HPMResponse::CanUndo,
                            )
                        }
                        (__Field::__field16, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    Result<bool, String>,
                                >(__variant),
                                HPMResponse::CanRedo,
                            )
                        }
                        (__Field::__field17, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    Result<String, String>,
                                >(__variant),
                                HPMResponse::GeneratePdf,
                            )
                        }
                        (__Field::__field18, __variant) => {
                            _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    Result<String, String>,
                                >(__variant),
                                HPMResponse::CheckAutosave,
                            )
                        }
                    }
                }
            }
            #[doc(hidden)]
            const VARIANTS: &'static [&'static str] = &[
                "GetSettings",
                "UpdateSettings",
                "UploadLogo",
                "UploadPaymentImage",
                "ListInvoices",
                "CreateInvoice",
                "GetInvoice",
                "UpdateInvoice",
                "DeleteInvoice",
                "AddLineItem",
                "UpdateLineItem",
                "DeleteLineItem",
                "ReorderLineItems",
                "Undo",
                "Redo",
                "CanUndo",
                "CanRedo",
                "GeneratePdf",
                "CheckAutosave",
            ];
            _serde::Deserializer::deserialize_enum(
                __deserializer,
                "HPMResponse",
                VARIANTS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<HPMResponse>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
/// Handle messages from the HTTP server
fn handle_http_server_message(
    state: *mut AppState,
    message: hyperware_process_lib::Message,
) {
    match serde_json::from_slice::<
        hyperware_process_lib::http::server::HttpServerRequest,
    >(message.body()) {
        Ok(http_server_request) => {
            match http_server_request {
                hyperware_process_lib::http::server::HttpServerRequest::Http(
                    http_request,
                ) => {
                    hyperware_app_common::APP_CONTEXT
                        .with(|ctx| {
                            ctx.borrow_mut().current_path = Some(
                                http_request
                                    .path()
                                    .clone()
                                    .expect("Failed to get path from HTTP request"),
                            );
                        });
                    let Some(blob) = message.blob() else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event invoice/src/lib.rs:115",
                                        "invoice",
                                        ::tracing::Level::WARN,
                                        ::tracing_core::__macro_support::Option::Some(
                                            "invoice/src/lib.rs",
                                        ),
                                        ::tracing_core::__macro_support::Option::Some(115u32),
                                        ::tracing_core::__macro_support::Option::Some("invoice"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::WARN
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::WARN
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::tracing::__macro_support::Option::Some(
                                                        &format_args!(
                                                            "Failed to get blob for HTTP, sending BAD_REQUEST",
                                                        ) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                        hyperware_process_lib::http::server::send_response(
                            hyperware_process_lib::http::StatusCode::BAD_REQUEST,
                            None,
                            ::alloc::vec::Vec::new(),
                        );
                        return;
                    };
                    match serde_json::from_slice::<HPMRequest>(&blob.bytes) {
                        Ok(request) => {
                            unsafe {
                                match request {
                                    HPMRequest::GetSettings {} => {
                                        let state_ptr: *mut AppState = state;
                                        ::hyperware_app_common::APP_CONTEXT
                                            .with(|ctx| {
                                                ctx.borrow_mut()
                                                    .executor
                                                    .spawn(async move {
                                                        let result = unsafe { (*state_ptr).get_settings().await };
                                                        let response_bytes = serde_json::to_vec(&result).unwrap();
                                                        hyperware_process_lib::http::server::send_response(
                                                            hyperware_process_lib::http::StatusCode::OK,
                                                            None,
                                                            response_bytes,
                                                        );
                                                    })
                                            })
                                    }
                                    HPMRequest::UpdateSettings(param) => {
                                        let param_captured = param;
                                        let state_ptr: *mut AppState = state;
                                        ::hyperware_app_common::APP_CONTEXT
                                            .with(|ctx| {
                                                ctx.borrow_mut()
                                                    .executor
                                                    .spawn(async move {
                                                        let result = unsafe {
                                                            (*state_ptr).update_settings(param_captured).await
                                                        };
                                                        let response_bytes = serde_json::to_vec(&result).unwrap();
                                                        hyperware_process_lib::http::server::send_response(
                                                            hyperware_process_lib::http::StatusCode::OK,
                                                            None,
                                                            response_bytes,
                                                        );
                                                    })
                                            })
                                    }
                                    HPMRequest::UploadLogo(param) => {
                                        let param_captured = param;
                                        let state_ptr: *mut AppState = state;
                                        ::hyperware_app_common::APP_CONTEXT
                                            .with(|ctx| {
                                                ctx.borrow_mut()
                                                    .executor
                                                    .spawn(async move {
                                                        let result = unsafe {
                                                            (*state_ptr).upload_logo(param_captured).await
                                                        };
                                                        let response_bytes = serde_json::to_vec(&result).unwrap();
                                                        hyperware_process_lib::http::server::send_response(
                                                            hyperware_process_lib::http::StatusCode::OK,
                                                            None,
                                                            response_bytes,
                                                        );
                                                    })
                                            })
                                    }
                                    HPMRequest::UploadPaymentImage(param) => {
                                        let param_captured = param;
                                        let state_ptr: *mut AppState = state;
                                        ::hyperware_app_common::APP_CONTEXT
                                            .with(|ctx| {
                                                ctx.borrow_mut()
                                                    .executor
                                                    .spawn(async move {
                                                        let result = unsafe {
                                                            (*state_ptr).upload_payment_image(param_captured).await
                                                        };
                                                        let response_bytes = serde_json::to_vec(&result).unwrap();
                                                        hyperware_process_lib::http::server::send_response(
                                                            hyperware_process_lib::http::StatusCode::OK,
                                                            None,
                                                            response_bytes,
                                                        );
                                                    })
                                            })
                                    }
                                    HPMRequest::ListInvoices {} => {
                                        let state_ptr: *mut AppState = state;
                                        ::hyperware_app_common::APP_CONTEXT
                                            .with(|ctx| {
                                                ctx.borrow_mut()
                                                    .executor
                                                    .spawn(async move {
                                                        let result = unsafe { (*state_ptr).list_invoices().await };
                                                        let response_bytes = serde_json::to_vec(&result).unwrap();
                                                        hyperware_process_lib::http::server::send_response(
                                                            hyperware_process_lib::http::StatusCode::OK,
                                                            None,
                                                            response_bytes,
                                                        );
                                                    })
                                            })
                                    }
                                    HPMRequest::CreateInvoice {} => {
                                        let state_ptr: *mut AppState = state;
                                        ::hyperware_app_common::APP_CONTEXT
                                            .with(|ctx| {
                                                ctx.borrow_mut()
                                                    .executor
                                                    .spawn(async move {
                                                        let result = unsafe { (*state_ptr).create_invoice().await };
                                                        let response_bytes = serde_json::to_vec(&result).unwrap();
                                                        hyperware_process_lib::http::server::send_response(
                                                            hyperware_process_lib::http::StatusCode::OK,
                                                            None,
                                                            response_bytes,
                                                        );
                                                    })
                                            })
                                    }
                                    HPMRequest::GetInvoice(param) => {
                                        let param_captured = param;
                                        let state_ptr: *mut AppState = state;
                                        ::hyperware_app_common::APP_CONTEXT
                                            .with(|ctx| {
                                                ctx.borrow_mut()
                                                    .executor
                                                    .spawn(async move {
                                                        let result = unsafe {
                                                            (*state_ptr).get_invoice(param_captured).await
                                                        };
                                                        let response_bytes = serde_json::to_vec(&result).unwrap();
                                                        hyperware_process_lib::http::server::send_response(
                                                            hyperware_process_lib::http::StatusCode::OK,
                                                            None,
                                                            response_bytes,
                                                        );
                                                    })
                                            })
                                    }
                                    HPMRequest::UpdateInvoice(param) => {
                                        let param_captured = param;
                                        let state_ptr: *mut AppState = state;
                                        ::hyperware_app_common::APP_CONTEXT
                                            .with(|ctx| {
                                                ctx.borrow_mut()
                                                    .executor
                                                    .spawn(async move {
                                                        let result = unsafe {
                                                            (*state_ptr).update_invoice(param_captured).await
                                                        };
                                                        let response_bytes = serde_json::to_vec(&result).unwrap();
                                                        hyperware_process_lib::http::server::send_response(
                                                            hyperware_process_lib::http::StatusCode::OK,
                                                            None,
                                                            response_bytes,
                                                        );
                                                    })
                                            })
                                    }
                                    HPMRequest::DeleteInvoice(param) => {
                                        let param_captured = param;
                                        let state_ptr: *mut AppState = state;
                                        ::hyperware_app_common::APP_CONTEXT
                                            .with(|ctx| {
                                                ctx.borrow_mut()
                                                    .executor
                                                    .spawn(async move {
                                                        let result = unsafe {
                                                            (*state_ptr).delete_invoice(param_captured).await
                                                        };
                                                        let response_bytes = serde_json::to_vec(&result).unwrap();
                                                        hyperware_process_lib::http::server::send_response(
                                                            hyperware_process_lib::http::StatusCode::OK,
                                                            None,
                                                            response_bytes,
                                                        );
                                                    })
                                            })
                                    }
                                    HPMRequest::AddLineItem {} => {
                                        let state_ptr: *mut AppState = state;
                                        ::hyperware_app_common::APP_CONTEXT
                                            .with(|ctx| {
                                                ctx.borrow_mut()
                                                    .executor
                                                    .spawn(async move {
                                                        let result = unsafe { (*state_ptr).add_line_item().await };
                                                        let response_bytes = serde_json::to_vec(&result).unwrap();
                                                        hyperware_process_lib::http::server::send_response(
                                                            hyperware_process_lib::http::StatusCode::OK,
                                                            None,
                                                            response_bytes,
                                                        );
                                                    })
                                            })
                                    }
                                    HPMRequest::UpdateLineItem(param) => {
                                        let param_captured = param;
                                        let state_ptr: *mut AppState = state;
                                        ::hyperware_app_common::APP_CONTEXT
                                            .with(|ctx| {
                                                ctx.borrow_mut()
                                                    .executor
                                                    .spawn(async move {
                                                        let result = unsafe {
                                                            (*state_ptr).update_line_item(param_captured).await
                                                        };
                                                        let response_bytes = serde_json::to_vec(&result).unwrap();
                                                        hyperware_process_lib::http::server::send_response(
                                                            hyperware_process_lib::http::StatusCode::OK,
                                                            None,
                                                            response_bytes,
                                                        );
                                                    })
                                            })
                                    }
                                    HPMRequest::DeleteLineItem(param) => {
                                        let param_captured = param;
                                        let state_ptr: *mut AppState = state;
                                        ::hyperware_app_common::APP_CONTEXT
                                            .with(|ctx| {
                                                ctx.borrow_mut()
                                                    .executor
                                                    .spawn(async move {
                                                        let result = unsafe {
                                                            (*state_ptr).delete_line_item(param_captured).await
                                                        };
                                                        let response_bytes = serde_json::to_vec(&result).unwrap();
                                                        hyperware_process_lib::http::server::send_response(
                                                            hyperware_process_lib::http::StatusCode::OK,
                                                            None,
                                                            response_bytes,
                                                        );
                                                    })
                                            })
                                    }
                                    HPMRequest::ReorderLineItems(param) => {
                                        let param_captured = param;
                                        let state_ptr: *mut AppState = state;
                                        ::hyperware_app_common::APP_CONTEXT
                                            .with(|ctx| {
                                                ctx.borrow_mut()
                                                    .executor
                                                    .spawn(async move {
                                                        let result = unsafe {
                                                            (*state_ptr).reorder_line_items(param_captured).await
                                                        };
                                                        let response_bytes = serde_json::to_vec(&result).unwrap();
                                                        hyperware_process_lib::http::server::send_response(
                                                            hyperware_process_lib::http::StatusCode::OK,
                                                            None,
                                                            response_bytes,
                                                        );
                                                    })
                                            })
                                    }
                                    HPMRequest::Undo {} => {
                                        let state_ptr: *mut AppState = state;
                                        ::hyperware_app_common::APP_CONTEXT
                                            .with(|ctx| {
                                                ctx.borrow_mut()
                                                    .executor
                                                    .spawn(async move {
                                                        let result = unsafe { (*state_ptr).undo().await };
                                                        let response_bytes = serde_json::to_vec(&result).unwrap();
                                                        hyperware_process_lib::http::server::send_response(
                                                            hyperware_process_lib::http::StatusCode::OK,
                                                            None,
                                                            response_bytes,
                                                        );
                                                    })
                                            })
                                    }
                                    HPMRequest::Redo {} => {
                                        let state_ptr: *mut AppState = state;
                                        ::hyperware_app_common::APP_CONTEXT
                                            .with(|ctx| {
                                                ctx.borrow_mut()
                                                    .executor
                                                    .spawn(async move {
                                                        let result = unsafe { (*state_ptr).redo().await };
                                                        let response_bytes = serde_json::to_vec(&result).unwrap();
                                                        hyperware_process_lib::http::server::send_response(
                                                            hyperware_process_lib::http::StatusCode::OK,
                                                            None,
                                                            response_bytes,
                                                        );
                                                    })
                                            })
                                    }
                                    HPMRequest::CanUndo {} => {
                                        let state_ptr: *mut AppState = state;
                                        ::hyperware_app_common::APP_CONTEXT
                                            .with(|ctx| {
                                                ctx.borrow_mut()
                                                    .executor
                                                    .spawn(async move {
                                                        let result = unsafe { (*state_ptr).can_undo().await };
                                                        let response_bytes = serde_json::to_vec(&result).unwrap();
                                                        hyperware_process_lib::http::server::send_response(
                                                            hyperware_process_lib::http::StatusCode::OK,
                                                            None,
                                                            response_bytes,
                                                        );
                                                    })
                                            })
                                    }
                                    HPMRequest::CanRedo {} => {
                                        let state_ptr: *mut AppState = state;
                                        ::hyperware_app_common::APP_CONTEXT
                                            .with(|ctx| {
                                                ctx.borrow_mut()
                                                    .executor
                                                    .spawn(async move {
                                                        let result = unsafe { (*state_ptr).can_redo().await };
                                                        let response_bytes = serde_json::to_vec(&result).unwrap();
                                                        hyperware_process_lib::http::server::send_response(
                                                            hyperware_process_lib::http::StatusCode::OK,
                                                            None,
                                                            response_bytes,
                                                        );
                                                    })
                                            })
                                    }
                                    HPMRequest::GeneratePdf {} => {
                                        let state_ptr: *mut AppState = state;
                                        ::hyperware_app_common::APP_CONTEXT
                                            .with(|ctx| {
                                                ctx.borrow_mut()
                                                    .executor
                                                    .spawn(async move {
                                                        let result = unsafe { (*state_ptr).generate_pdf().await };
                                                        let response_bytes = serde_json::to_vec(&result).unwrap();
                                                        hyperware_process_lib::http::server::send_response(
                                                            hyperware_process_lib::http::StatusCode::OK,
                                                            None,
                                                            response_bytes,
                                                        );
                                                    })
                                            })
                                    }
                                    HPMRequest::CheckAutosave {} => {
                                        let state_ptr: *mut AppState = state;
                                        ::hyperware_app_common::APP_CONTEXT
                                            .with(|ctx| {
                                                ctx.borrow_mut()
                                                    .executor
                                                    .spawn(async move {
                                                        let result = unsafe { (*state_ptr).check_autosave().await };
                                                        let response_bytes = serde_json::to_vec(&result).unwrap();
                                                        hyperware_process_lib::http::server::send_response(
                                                            hyperware_process_lib::http::StatusCode::OK,
                                                            None,
                                                            response_bytes,
                                                        );
                                                    })
                                            })
                                    }
                                    _ => {
                                        ::core::panicking::panic_fmt(
                                            format_args!(
                                                "internal error: entered unreachable code: {0}",
                                                format_args!(
                                                    "Non-http request variant received in http handler",
                                                ),
                                            ),
                                        );
                                    }
                                }
                                hyperware_app_common::maybe_save_state(&mut *state);
                            }
                        }
                        Err(e) => {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event invoice/src/lib.rs:115",
                                            "invoice",
                                            ::tracing::Level::WARN,
                                            ::tracing_core::__macro_support::Option::Some(
                                                "invoice/src/lib.rs",
                                            ),
                                            ::tracing_core::__macro_support::Option::Some(115u32),
                                            ::tracing_core::__macro_support::Option::Some("invoice"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::WARN
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::WARN
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::tracing::__macro_support::Option::Some(
                                                            &format_args!(
                                                                "Failed to deserialize HTTP request into HPMRequest enum: {0}\n{1:?}",
                                                                e,
                                                                serde_json::from_slice::<serde_json::Value>(&blob.bytes),
                                                            ) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                            hyperware_process_lib::http::server::send_response(
                                hyperware_process_lib::http::StatusCode::BAD_REQUEST,
                                None,
                                ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("Invalid request format: {0}", e),
                                        );
                                        res
                                    })
                                    .into_bytes(),
                            );
                        }
                    }
                    hyperware_app_common::APP_CONTEXT
                        .with(|ctx| {
                            ctx.borrow_mut().current_path = None;
                        });
                }
                hyperware_process_lib::http::server::HttpServerRequest::WebSocketPush {
                    channel_id,
                    message_type,
                } => {
                    let Some(blob) = message.blob() else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event invoice/src/lib.rs:115",
                                        "invoice",
                                        ::tracing::Level::WARN,
                                        ::tracing_core::__macro_support::Option::Some(
                                            "invoice/src/lib.rs",
                                        ),
                                        ::tracing_core::__macro_support::Option::Some(115u32),
                                        ::tracing_core::__macro_support::Option::Some("invoice"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::WARN
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::WARN
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::tracing::__macro_support::Option::Some(
                                                        &format_args!(
                                                            "Failed to get blob for WebSocketPush, exiting",
                                                        ) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                        return;
                    };
                    unsafe {
                        hyperware_app_common::maybe_save_state(&mut *state);
                    }
                }
                hyperware_process_lib::http::server::HttpServerRequest::WebSocketOpen {
                    path,
                    channel_id,
                } => {
                    hyperware_app_common::get_server()
                        .unwrap()
                        .handle_websocket_open(&path, channel_id);
                }
                hyperware_process_lib::http::server::HttpServerRequest::WebSocketClose(
                    channel_id,
                ) => {
                    hyperware_app_common::get_server()
                        .unwrap()
                        .handle_websocket_close(channel_id);
                }
            }
        }
        Err(e) => {
            {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "event invoice/src/lib.rs:115",
                            "invoice",
                            ::tracing::Level::WARN,
                            ::tracing_core::__macro_support::Option::Some(
                                "invoice/src/lib.rs",
                            ),
                            ::tracing_core::__macro_support::Option::Some(115u32),
                            ::tracing_core::__macro_support::Option::Some("invoice"),
                            ::tracing_core::field::FieldSet::new(
                                &["message"],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::EVENT,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let enabled = ::tracing::Level::WARN
                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::WARN
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        let interest = __CALLSITE.interest();
                        !interest.is_never()
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                    };
                if enabled {
                    (|value_set: ::tracing::field::ValueSet| {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Event::dispatch(meta, &value_set);
                    })({
                        #[allow(unused_imports)]
                        use ::tracing::field::{debug, display, Value};
                        let mut iter = __CALLSITE.metadata().fields().iter();
                        __CALLSITE
                            .metadata()
                            .fields()
                            .value_set(
                                &[
                                    (
                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                            .expect("FieldSet corrupted (this is a bug)"),
                                        ::tracing::__macro_support::Option::Some(
                                            &format_args!("Failed to parse HTTP server request: {0}", e)
                                                as &dyn Value,
                                        ),
                                    ),
                                ],
                            )
                    });
                } else {
                }
            };
        }
    }
}
/// Handle local messages
fn handle_local_message(state: *mut AppState, message: hyperware_process_lib::Message) {
    match serde_json::from_slice::<serde_json::Value>(message.body()) {
        Ok(req_value) => {
            match serde_json::from_value::<HPMRequest>(req_value.clone()) {
                Ok(request) => {
                    unsafe {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event invoice/src/lib.rs:115",
                                        "invoice",
                                        ::tracing::Level::WARN,
                                        ::tracing_core::__macro_support::Option::Some(
                                            "invoice/src/lib.rs",
                                        ),
                                        ::tracing_core::__macro_support::Option::Some(115u32),
                                        ::tracing_core::__macro_support::Option::Some("invoice"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::WARN
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::WARN
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::tracing::__macro_support::Option::Some(
                                                        &format_args!(
                                                            "No local handlers defined but received a local request",
                                                        ) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                        hyperware_app_common::maybe_save_state(&mut *state);
                    }
                }
                Err(e) => {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event invoice/src/lib.rs:115",
                                    "invoice",
                                    ::tracing::Level::WARN,
                                    ::tracing_core::__macro_support::Option::Some(
                                        "invoice/src/lib.rs",
                                    ),
                                    ::tracing_core::__macro_support::Option::Some(115u32),
                                    ::tracing_core::__macro_support::Option::Some("invoice"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::tracing::__macro_support::Option::Some(
                                                    &format_args!(
                                                        "Failed to deserialize local request into HPMRequest enum: {0}",
                                                        e,
                                                    ) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                }
            }
        }
        Err(e) => {
            {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "event invoice/src/lib.rs:115",
                            "invoice",
                            ::tracing::Level::WARN,
                            ::tracing_core::__macro_support::Option::Some(
                                "invoice/src/lib.rs",
                            ),
                            ::tracing_core::__macro_support::Option::Some(115u32),
                            ::tracing_core::__macro_support::Option::Some("invoice"),
                            ::tracing_core::field::FieldSet::new(
                                &["message"],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::EVENT,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let enabled = ::tracing::Level::WARN
                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::WARN
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        let interest = __CALLSITE.interest();
                        !interest.is_never()
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                    };
                if enabled {
                    (|value_set: ::tracing::field::ValueSet| {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Event::dispatch(meta, &value_set);
                    })({
                        #[allow(unused_imports)]
                        use ::tracing::field::{debug, display, Value};
                        let mut iter = __CALLSITE.metadata().fields().iter();
                        __CALLSITE
                            .metadata()
                            .fields()
                            .value_set(
                                &[
                                    (
                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                            .expect("FieldSet corrupted (this is a bug)"),
                                        ::tracing::__macro_support::Option::Some(
                                            &format_args!(
                                                "Failed to parse message body as JSON: {0}",
                                                e,
                                            ) as &dyn Value,
                                        ),
                                    ),
                                ],
                            )
                    });
                } else {
                }
            };
        }
    }
}
/// Handle remote messages
fn handle_remote_message(state: *mut AppState, message: hyperware_process_lib::Message) {
    match serde_json::from_slice::<serde_json::Value>(message.body()) {
        Ok(req_value) => {
            match serde_json::from_value::<HPMRequest>(req_value.clone()) {
                Ok(request) => {
                    unsafe {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event invoice/src/lib.rs:115",
                                        "invoice",
                                        ::tracing::Level::WARN,
                                        ::tracing_core::__macro_support::Option::Some(
                                            "invoice/src/lib.rs",
                                        ),
                                        ::tracing_core::__macro_support::Option::Some(115u32),
                                        ::tracing_core::__macro_support::Option::Some("invoice"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::WARN
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::WARN
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::tracing::__macro_support::Option::Some(
                                                        &format_args!(
                                                            "No remote handlers defined but received a remote request",
                                                        ) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                        hyperware_app_common::maybe_save_state(&mut *state);
                    }
                }
                Err(e) => {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event invoice/src/lib.rs:115",
                                    "invoice",
                                    ::tracing::Level::WARN,
                                    ::tracing_core::__macro_support::Option::Some(
                                        "invoice/src/lib.rs",
                                    ),
                                    ::tracing_core::__macro_support::Option::Some(115u32),
                                    ::tracing_core::__macro_support::Option::Some("invoice"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::tracing::__macro_support::Option::Some(
                                                    &format_args!(
                                                        "Failed to deserialize remote request into HPMRequest enum: {0}",
                                                        e,
                                                    ) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event invoice/src/lib.rs:115",
                                    "invoice",
                                    ::tracing::Level::WARN,
                                    ::tracing_core::__macro_support::Option::Some(
                                        "invoice/src/lib.rs",
                                    ),
                                    ::tracing_core::__macro_support::Option::Some(115u32),
                                    ::tracing_core::__macro_support::Option::Some("invoice"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::WARN
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::WARN
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::tracing::__macro_support::Option::Some(
                                                    &format_args!("Raw request value: {0:?}", req_value)
                                                        as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                }
            }
        }
        Err(e) => {
            {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "event invoice/src/lib.rs:115",
                            "invoice",
                            ::tracing::Level::WARN,
                            ::tracing_core::__macro_support::Option::Some(
                                "invoice/src/lib.rs",
                            ),
                            ::tracing_core::__macro_support::Option::Some(115u32),
                            ::tracing_core::__macro_support::Option::Some("invoice"),
                            ::tracing_core::field::FieldSet::new(
                                &["message"],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::EVENT,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let enabled = ::tracing::Level::WARN
                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::WARN
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        let interest = __CALLSITE.interest();
                        !interest.is_never()
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                    };
                if enabled {
                    (|value_set: ::tracing::field::ValueSet| {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Event::dispatch(meta, &value_set);
                    })({
                        #[allow(unused_imports)]
                        use ::tracing::field::{debug, display, Value};
                        let mut iter = __CALLSITE.metadata().fields().iter();
                        __CALLSITE
                            .metadata()
                            .fields()
                            .value_set(
                                &[
                                    (
                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                            .expect("FieldSet corrupted (this is a bug)"),
                                        ::tracing::__macro_support::Option::Some(
                                            &format_args!(
                                                "Failed to parse message body as JSON: {0}",
                                                e,
                                            ) as &dyn Value,
                                        ),
                                    ),
                                ],
                            )
                    });
                } else {
                }
            };
        }
    }
}
struct Component;
impl Guest for Component {
    fn init(_our: String) {
        let mut state = hyperware_app_common::initialize_state::<AppState>();
        let app_name = "Invoice";
        let app_icon = None;
        let app_widget = None;
        let ui_config = Some(HttpBindingConfig::default());
        let endpoints = <[_]>::into_vec(
            #[rustc_box]
            ::alloc::boxed::Box::new([
                Binding::Http {
                    path: "/api",
                    config: HttpBindingConfig::new(false, false, false, None),
                },
            ]),
        );
        if app_icon.is_some() && app_widget.is_some() {
            hyperware_process_lib::homepage::add_to_homepage(
                app_name,
                app_icon,
                Some("/"),
                app_widget,
            );
        }
        hyperware_process_lib::logging::init_logging(
                hyperware_process_lib::logging::Level::DEBUG,
                hyperware_process_lib::logging::Level::INFO,
                None,
                Some((0, 0, 1, 1)),
                None,
            )
            .unwrap();
        let mut server = hyperware_app_common::setup_server(
            ui_config.as_ref(),
            &endpoints,
        );
        hyperware_app_common::APP_CONTEXT
            .with(|ctx| {
                ctx.borrow_mut().current_server = Some(&mut server);
            });
        if Some("initialize").is_some() {
            let state_ptr: *mut AppState = &mut state;
            ::hyperware_app_common::APP_CONTEXT
                .with(|ctx| {
                    ctx.borrow_mut()
                        .executor
                        .spawn(async move {
                            unsafe { (*state_ptr).initialize().await };
                        })
                })
        }
        loop {
            hyperware_app_common::APP_CONTEXT
                .with(|ctx| {
                    ctx.borrow_mut().executor.poll_all_tasks();
                });
            match hyperware_process_lib::await_message() {
                Ok(message) => {
                    CURRENT_MESSAGE
                        .with(|cell| {
                            *cell.borrow_mut() = Some(message.clone());
                        });
                    match message {
                        hyperware_process_lib::Message::Response {
                            body,
                            context,
                            ..
                        } => {
                            let correlation_id = context
                                .as_deref()
                                .map(|bytes| String::from_utf8_lossy(bytes).to_string())
                                .unwrap_or_else(|| "no context".to_string());
                            hyperware_app_common::RESPONSE_REGISTRY
                                .with(|registry| {
                                    let mut registry_mut = registry.borrow_mut();
                                    registry_mut.insert(correlation_id, body);
                                });
                        }
                        hyperware_process_lib::Message::Request { .. } => {
                            if message.is_local()
                                && message.source().process == "http-server:distro:sys"
                            {
                                handle_http_server_message(&mut state, message);
                            } else if message.is_local() {
                                handle_local_message(&mut state, message);
                            } else {
                                handle_remote_message(&mut state, message);
                            }
                        }
                    }
                }
                Err(ref error) => {
                    if let hyperware_process_lib::SendError {
                        context: Some(context),
                        ..
                    } = error {
                        let correlation_id = String::from_utf8_lossy(context)
                            .to_string();
                        hyperware_app_common::RESPONSE_REGISTRY
                            .with(|registry| {
                                let mut registry_mut = registry.borrow_mut();
                                registry_mut
                                    .insert(correlation_id, serde_json::to_vec(error).unwrap());
                            });
                    }
                }
            }
        }
    }
}
const _: () = {
    #[export_name = "init"]
    unsafe extern "C" fn export_init(arg0: *mut u8, arg1: usize) {
        self::_export_init_cabi::<Component>(arg0, arg1)
    }
};
fn calculate_invoice_total(invoice: &Invoice) -> f64 {
    let mut subtotal = 0.0;
    for item in &invoice.line_items {
        let line_total = item.quantity * item.rate;
        let line_discount = line_total * (item.discount_percent / 100.0);
        subtotal += line_total - line_discount;
    }
    let invoice_discount = subtotal * (invoice.discount_percent / 100.0);
    let after_discount = subtotal - invoice_discount;
    let tax = after_discount * (invoice.tax_percent / 100.0);
    after_discount + tax
}
impl AppState {
    fn load_invoice_summaries(&mut self, drive_path: &str) {
        match open_dir(drive_path, false, Some(5)) {
            Ok(dir) => {
                if let Ok(entries) = dir.read() {
                    for entry in entries {
                        if entry.file_type == vfs::FileType::Directory {
                            self.load_invoices_from_date_dir(
                                &::alloc::__export::must_use({
                                    let res = ::alloc::fmt::format(
                                        format_args!("{0}/{1}", drive_path, entry.path),
                                    );
                                    res
                                }),
                            );
                        }
                    }
                }
            }
            Err(_) => {
                ::std::io::_print(format_args!("Could not open drive directory\n"));
            }
        }
    }
    fn load_invoices_from_date_dir(&mut self, date_dir_path: &str) {
        match open_dir(date_dir_path, false, Some(5)) {
            Ok(dir) => {
                if let Ok(entries) = dir.read() {
                    for entry in entries {
                        if entry.file_type == vfs::FileType::Directory {
                            let invoice_path = ::alloc::__export::must_use({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "{0}/{1}/invoice.json",
                                        date_dir_path,
                                        entry.path,
                                    ),
                                );
                                res
                            });
                            if let Ok(file) = open_file(&invoice_path, false, Some(5)) {
                                if let Ok(data) = file.read_to_string() {
                                    if let Ok(invoice) = serde_json::from_str::<
                                        Invoice,
                                    >(&data) {
                                        let summary = InvoiceSummary {
                                            id: invoice.id.clone(),
                                            number: invoice.number.clone(),
                                            name: invoice.name.clone(),
                                            date: invoice.date.clone(),
                                            total: calculate_invoice_total(&invoice),
                                            status: invoice.status.clone(),
                                        };
                                        self.invoices.insert(invoice.id.clone(), summary);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            Err(_) => {}
        }
    }
    fn save_current_invoice(&mut self) -> Result<(), String> {
        if let Some(ref invoice) = self.current_invoice {
            let package_id = our().package_id();
            let drive_path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("/{0}/invoice", package_id));
                res
            });
            let date_dir = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}/{1}", drive_path, invoice.date),
                );
                res
            });
            let _ = open_dir(&date_dir, true, Some(5));
            let invoice_dir_name = if let Some(ref name) = invoice.name {
                name.clone()
            } else {
                invoice.number.clone()
            };
            let invoice_dir = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}/{1}", date_dir, invoice_dir_name),
                );
                res
            });
            let _ = open_dir(&invoice_dir, true, Some(5));
            let invoice_path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}/invoice.json", invoice_dir),
                );
                res
            });
            match create_file(&invoice_path, Some(5)) {
                Ok(file) => {
                    let data = serde_json::to_vec(invoice)
                        .map_err(|e| ::alloc::__export::must_use({
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to serialize invoice: {0}", e),
                            );
                            res
                        }))?;
                    file.write(&data)
                        .map_err(|e| ::alloc::__export::must_use({
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to write invoice: {0}", e),
                            );
                            res
                        }))?;
                    self.has_unsaved_changes = false;
                    Ok(())
                }
                Err(e) => {
                    Err(
                        ::alloc::__export::must_use({
                            let res = ::alloc::fmt::format(
                                format_args!("Failed to create invoice file: {0}", e),
                            );
                            res
                        }),
                    )
                }
            }
        } else {
            Ok(())
        }
    }
    fn generate_invoice_html(&self, invoice: &Invoice) -> String {
        let subtotal = invoice
            .line_items
            .iter()
            .map(|item| {
                let line_total = item.quantity * item.rate;
                line_total - (line_total * item.discount_percent / 100.0)
            })
            .sum::<f64>();
        let invoice_discount = subtotal * invoice.discount_percent / 100.0;
        let after_discount = subtotal - invoice_discount;
        let tax = after_discount * invoice.tax_percent / 100.0;
        let total = after_discount + tax;
        ::alloc::__export::must_use({
            let res = ::alloc::fmt::format(
                format_args!(
                    "\n<!DOCTYPE html>\n<html>\n<head>\n    <style>\n        body {{ font-family: Arial, sans-serif; margin: 40px; }}\n        .header {{ display: flex; justify-content: space-between; margin-bottom: 40px; }}\n        .invoice-details {{ text-align: right; }}\n        .contact-info {{ margin-bottom: 30px; }}\n        table {{ width: 100%; border-collapse: collapse; margin: 20px 0; }}\n        th, td {{ padding: 10px; text-align: left; border-bottom: 1px solid #ddd; }}\n        th {{ background-color: #f5f5f5; }}\n        .totals {{ text-align: right; margin-top: 20px; }}\n        .total-row {{ display: flex; justify-content: flex-end; margin: 5px 0; }}\n        .total-label {{ width: 150px; }}\n        .total-value {{ width: 100px; text-align: right; }}\n    </style>\n</head>\n<body>\n    <div class=\"header\">\n        <div class=\"invoicer\">\n            <h2>{0}</h2>\n            <div class=\"contact-info\">\n                <p>{1}</p>\n                <p>{2}</p>\n                <p>{3}</p>\n            </div>\n        </div>\n        <div class=\"invoice-details\">\n            <h1>INVOICE</h1>\n            <p><strong>Invoice #:</strong> {4}</p>\n            <p><strong>Date:</strong> {5}</p>\n            <p><strong>Due Date:</strong> {6}</p>\n        </div>\n    </div>\n    \n    <div class=\"invoicee\">\n        <h3>Bill To:</h3>\n        <div class=\"contact-info\">\n            <p><strong>{7}</strong></p>\n            <p>{8}</p>\n            <p>{9}</p>\n            <p>{10}</p>\n        </div>\n    </div>\n    \n    <table>\n        <thead>\n            <tr>\n                <th>Description</th>\n                <th>Quantity</th>\n                <th>Rate</th>\n                <th>Discount</th>\n                <th>Amount</th>\n            </tr>\n        </thead>\n        <tbody>\n            {11}\n        </tbody>\n    </table>\n    \n    <div class=\"totals\">\n        <div class=\"total-row\">\n            <span class=\"total-label\">Subtotal:</span>\n            <span class=\"total-value\">${12:.2}</span>\n        </div>\n        <div class=\"total-row\">\n            <span class=\"total-label\">Discount ({13}%):</span>\n            <span class=\"total-value\">-${14:.2}</span>\n        </div>\n        <div class=\"total-row\">\n            <span class=\"total-label\">Tax ({15}%):</span>\n            <span class=\"total-value\">${16:.2}</span>\n        </div>\n        <div class=\"total-row\" style=\"font-weight: bold; font-size: 1.2em;\">\n            <span class=\"total-label\">Total:</span>\n            <span class=\"total-value\">${17:.2}</span>\n        </div>\n    </div>\n    \n    {18}\n    \n    {19}\n</body>\n</html>\n        ",
                    invoice.invoicer.name,
                    invoice.invoicer.company.as_ref().unwrap_or(&String::new()),
                    invoice.invoicer.address,
                    invoice.invoicer.email.as_ref().unwrap_or(&String::new()),
                    invoice.number,
                    invoice.date,
                    invoice.due_date.as_ref().unwrap_or(&String::new()),
                    invoice.invoicee.name,
                    invoice.invoicee.company.as_ref().unwrap_or(&String::new()),
                    invoice.invoicee.address,
                    invoice.invoicee.email.as_ref().unwrap_or(&String::new()),
                    invoice
                        .line_items
                        .iter()
                        .map(|item| {
                            let line_total = item.quantity * item.rate;
                            let amount = line_total
                                - (line_total * item.discount_percent / 100.0);
                            ::alloc::__export::must_use({
                                let res = ::alloc::fmt::format(
                                    format_args!(
                                        "<tr><td>{0}</td><td>{1}</td><td>${2:.2}</td><td>{3}%</td><td>${4:.2}</td></tr>",
                                        item.description,
                                        item.quantity,
                                        item.rate,
                                        item.discount_percent,
                                        amount,
                                    ),
                                );
                                res
                            })
                        })
                        .collect::<Vec<_>>()
                        .join("\n"),
                    subtotal,
                    invoice.discount_percent,
                    invoice_discount,
                    invoice.tax_percent,
                    tax,
                    total,
                    invoice
                        .notes
                        .as_ref()
                        .map(|n| ::alloc::__export::must_use({
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "<div class=\'notes\'><h3>Notes:</h3><p>{0}</p></div>",
                                    n,
                                ),
                            );
                            res
                        }))
                        .unwrap_or_default(),
                    invoice
                        .payment_info
                        .as_ref()
                        .map(|p| ::alloc::__export::must_use({
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "<div class=\'payment\'><h3>Payment Information:</h3><p>{0}</p></div>",
                                    p,
                                ),
                            );
                            res
                        }))
                        .unwrap_or_default(),
                ),
            );
            res
        })
    }
}
